<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Dynamically Typed Languages</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html --> 
<meta name="src" content="aic2008.tex"> 
<meta name="date" content="2010-12-30 17:12:00"> 
<link rel="stylesheet" type="text/css" href="../paper.css">
<link rel="stylesheet" type="text/css" href="aic2008.css"> 
</head>





<body id="bg">
<table id="header">
<tr>
<td align = "left"><a href = "/laurie/">Home</a> > <a href="../../">Publications</a></td>
<td align = "right"><a href = "mailto:laurie@tratt.net">laurie@tratt.net</a></td>
</tr>
</table>
	
<hr />

<div align="center" style="padding: 30px; width:35em; margin: auto"><b>Cite this paper as:</b><br> <em>Dynamically typed languages, Laurence Tratt, Advances in Computers, vol. 77, pages 149-184, July 2009 (<a href="../../bibtex/tratt__dynamically_typed_languages.bib">BibTeX file</a>).</em></div>


<div id="main">
<!-- main content -->

   <div class="maketitle">

<a 
 id="x1-2r1"></a>



<h2 class="titleHead">Dynamically Typed Languages</h2>
<div>Laurence Tratt <span 
class="cmtt-10"><a href="mailto:laurie@tratt.net">laurie@tratt.net</a></span><br />
Bournemouth University, Poole, Dorset, BH12 5BB, United Kingdom.</div>
<div class="date"><span 
class="cmr-9">Mar 13, 2009</span></div>
<a 
 id="Q1-1-1"></a>
<a 
 id="Q1-1-2"></a>
   </div>
   <div 
class="abstract" 
>
     <span 
class="cmbx-9">Abstract.</span> <span 
class="cmr-9">Dynamically typed languages such as Python and Ruby have</span>
     <span 
class="cmr-9">experienced a rapid growth in popularity in recent times. However, there</span>
     <span 
class="cmr-9">is much confusion as to what makes these languages interesting relative</span>
     <span 
class="cmr-9">to statically typed languages, and little knowledge of their rich history. In</span>
     <span 
class="cmr-9">this chapter I explore the general topic of dynamically typed languages,</span>
     <span 
class="cmr-9">how they differ from statically typed languages, their history, and their</span>
     <span 
class="cmr-9">defining features.</span>
</div>
   <h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-10001"></a>Introduction</h3>
<!--l. 45--><p class="noindent" >As computing is often split into software and hardware, so programming languages
are often split into dynamically and statically typed languages. The traditional,
simplified, definition of dynamically typed languages are that they do not enforce or
check type-safety at compile-time, deferring such checks until run-time. While
factually true, this definition leaves out what makes dynamically typed languages
interesting&#8212;for example that they lower development costs <span class="cite">[<a 
href="#Xousterhout__scripting_higher_level_programming_for_the_21st_century">Ous98</a>]</span> and
provide the flexibility required by specific domains such as data processing
<span class="cite">[<a 
href="#Xmeijer_drayton__static_typing_when_possible_dynamic_typing_when_needed_the_end_of_the_cold_war_between_programming_languages">MD04</a>]</span>.
<!--l. 47--><p class="indent" >   For many people, dynamically typed languages are the youthful face of a new style
of programming introduced in the past few years. In fact, they trace their roots back
to the earliest days of high-level programming languages in the 1950&#8217;s via
Lisp&#x00A0;<span class="cite">[<a 
href="#Xmccarthy__recursive_functions_of_symbolic_expressions_and_their_computation_by_machine_part_i">McC60</a>]</span>. Many important techniques have been pioneered in dynamically typed
languages from lexical scoping&#x00A0;<span class="cite">[<a 
href="#Xsussman_steele__scheme_an_interpreter_for_extended_lambda_calculus">SJ75</a>]</span> to Just-In-Time (JIT) compilation&#x00A0;<span class="cite">[<a 
href="#Xaycock__a_brief_history_of_just_in_time">Ayc03</a>]</span>, and
they remain a breeding ground for new ideas.
<!--l. 49--><p class="indent" >   Systems programming &#8211; seen as &#8216;serious&#8217; and thus demanding statically typed
languages &#8211; is often contrasted with scripting programming &#8211; seen as &#8216;amateurish&#8217;
and thus needing little more than dynamically typed languages&#x00A0;<span class="cite">[<a 
href="#Xousterhout__scripting_higher_level_programming_for_the_21st_century">Ous98</a>]</span>.

The derogative use of the term &#8216;scripting&#8217; led to the creation of other terms
such as &#8216;latently typed&#8217; and &#8216;lightweight languages&#8217; to avoid the associated
stigma. In reality the absence or presence of static typing has a number of
effects on the use and applicability of a language that simple comparisons
ignore&#x00A0;<span class="cite">[<a 
href="#Xpaulson__developers_shift_to_dynamic_programming_languages">Pau07</a>]</span>. So while some tasks such as low-level systems (e.g. operating
systems), resource critical systems (e.g. databases), or safety critical systems
(e.g. systems for nuclear reactors) benefit from the extra rigour of statically
typed languages, for many other systems the associated costs outweigh the
benefits&#x00A0;<span class="cite">[<a 
href="#Xloui__in_praise_of_scripting_real_programming_pragmatism">Lou08</a>]</span>. Gradually, dynamically typed languages have come to be seen as a
valid part of the software development toolkit, and not merely second-class
citizens&#x00A0;<span class="cite">[<a 
href="#Xspinellis_guruprasad__lightweight_languages_as_software_engineering_tools">SG97</a>]</span>.
<!--l. 51--><p class="indent" >   From the mainstream&#8217;s perspective, dynamically typed languages have finally
come of age. More than ever before, they are used to build widely used real-world
systems, often for the web, but increasingly for domains that were previously the sole
preserve of statically typed languages (e.g.&#x00A0;<span class="cite">[<a 
href="#Xkarabuk_grant__a_common_medium_for_programming_operations_research_models">KG07</a>]</span>), often because of lower
development costs and increased flexibility&#x00A0;<span class="cite">[<a 
href="#Xmadsen_magnusson_molier_pedersen__strong_typing_of_object_oriented_languages_revisited">MMMP90</a>,&#x00A0;<a 
href="#Xnorvig__paradigms_of_artificial_intelligence_programming_case_studies_in_common_lisp">Nor92</a>]</span>.
<!--l. 53--><p class="indent" >   It should be noted that since there is no central authority defining dynamically
typed languages, there is great variation within those languages which are typically
classified as dynamically typed languages; nevertheless all such languages share a
great deal in common. In this chapter, I explore the general topic of dynamically
typed languages, how they differ from statically typed languages, their history, and
their defining features. The purpose of this chapter is not to be a cheer-leader for
dynamically typed languages&#8212;it is my contention that both statically typed and
dynamically typed languages are required for the increasingly broad range of tasks
that software is put to. Rather this chapter aims to explain what dynamically typed
languages are and, by extension, to show where they may and may not be
useful.
<!--l. 57--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">2   </span> <a 
 id="x1-20002"></a>Defining types</h3>
<!--l. 59--><p class="noindent" >The lack of a widely understood definition of dynamically typed languages has
resulted in many misunderstandings about what dynamic typing is. Perhaps because
of this, alternative terms such as &#8216;soft typing&#8217; are sometimes used instead. Earlier
I gave the simplified, and oft-heard, definition that a dynamically typed
language is one that does not check or enforce type-safety at compile-time.
Inevitably this simplified definition does not capture everything it should&#8212;the
subtleties and variations in the use of dynamic typing preclude a short, precise
definition.
<!--l. 61--><p class="indent" >   In this section, I define various terms relating to dynamically typed languages,
building up an increasingly accurate picture of what is meant by this term. Further
reading on these topics can be found in&#x00A0;<span class="cite">[<a 
href="#Xcardelli__type_systems">Car97</a>,&#x00A0;<a 
href="#Xpierce__types_and_programming_languages">Pie02</a>]</span>.
<!--l. 64--><p class="noindent" >

   <h4 class="subsectionHead"><span class="titlemark">2.1   </span> <a 
 id="x1-30002.1"></a>Types</h4>
<!--l. 68--><p class="noindent" >At an abstract level, a type is a constraint which defines the set of valid values which
<span 
class="cmti-10">conform </span>to it. At the simplest level all apples conform to an &#8216;Apples&#8217; type and all
oranges to an &#8216;Oranges&#8217; type. Types often define additional constraints: red apples are
conformant to the &#8216;Red Apples&#8217; type, whereas green apples are not. Types are
typically organised into hierarchies, meaning that all apples which conform to the
&#8216;Red Apples&#8217; type also conform to the &#8216;Apples&#8217; type but not necessarily vice
versa.
<!--l. 70--><p class="indent" >   In programming languages, types are typically used to both classify values, and to
determine the valid operations for a given type. For example the <span 
class="cmtt-10">int </span>type in most
programming language represents integers, upon which the operations <span 
class="cmtt-10">+</span>, <span 
class="cmtt-10">-</span>, and so on
are valid. Most programming languages define a small number of built-in types, and
allow user programs to add new types to the system. While, abstractly, most types
define an infinite set, many built-in programming language types represent finite sets;
for example, in most languages the <span 
class="cmtt-10">int </span>type is tied to an underlying machine
representation of <span 
class="cmti-10">n </span>bits meaning that only a finite subset of integers conform to
it.
<!--l. 74--><p class="indent" >   In many Object Orientated (OO) programming languages, the notions of type and
class are conflated. That is, a class &#8216;Apple&#8217; which defines the attribute &#8216;pip&#8217; and the
operation &#8216;peel&#8217; also implicitly defines a type of the same name to which
instances of the class automatically conform to. Because classes do not always
define types to which the classes&#8217; instances conform&#x00A0;<span class="cite">[<a 
href="#Xcook_hill_canning__inheritance_is_not_subtyping">CHC90</a>,&#x00A0;<a 
href="#Xtheory_of_objects">AC96</a>]</span>, in
this chapter I treat the two notions separately. This means that, abstractly,
one must define a separate type &#8216;Apples Type&#8217; to which instances of the
&#8216;Apple Class&#8217; conform to. This definition of types may seem unnecessarily
abstract but, as shall be seen later, the notion of type is used in many different
contexts.
<!--l. 77--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.2   </span> <a 
 id="x1-40002.2"></a>Compile-time vs. run-time</h4>
<!--l. 79--><p class="noindent" >In this chapter, I differentiate between errors which happen at <span 
class="cmti-10">compile-time </span>and
<span 
class="cmti-10">run-time</span>. Compile-time errors are those which are determined by analyzing program
code without executing it; run-time errors are those that occur during program
execution.
<!--l. 81--><p class="indent" >   Statically typed languages typically have clearly distinct compile-time
and run-time phases, with program code converted by a compiler into a
binary executable which is then run separately. In most dynamically typed
languages (e.g. Converge, Perl, and Python) &#8216;running&#8217; a file both compiles
and executes it. The blurring, from an external perspective, of these two
stages often leads to dynamically typed languages being incorrectly classified
as &#8216;interpreted&#8217; languages. Internally, most dynamically typed languages
have distinct compilation and execution phases and therefore I use the terms
compile-time and run-time identically for both statically and dynamically typed
languages.

<!--l. 84--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.3   </span> <a 
 id="x1-50002.3"></a>Static typing</h4>
<!--l. 88--><p class="noindent" >Before defining what dynamic typing is, it is easiest to define its &#8216;opposite&#8217;. Statically
typed languages are those which define and enforce types at compile-time. Consider
the following Java&#x00A0;<span class="cite">[<a 
href="#Xgosling00java">GJSB00</a>]</span> code:
   <div class="fancyvrb" id="fancyvrb1">
<a 
 id="x1-5002r1"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;int</span><span 
class="cmtt-9">&#x00A0;i</span><span 
class="cmtt-9">&#x00A0;=</span><span 
class="cmtt-9">&#x00A0;3;</span>
<br class="fancyvrb" /><a 
 id="x1-5004r2"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;String</span><span 
class="cmtt-9">&#x00A0;s</span><span 
class="cmtt-9">&#x00A0;=</span><span 
class="cmtt-9">&#x00A0;"4";</span>
<br class="fancyvrb" /><a 
 id="x1-5006r3"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;int</span><span 
class="cmtt-9">&#x00A0;x</span><span 
class="cmtt-9">&#x00A0;=</span><span 
class="cmtt-9">&#x00A0;i</span><span 
class="cmtt-9">&#x00A0;+</span><span 
class="cmtt-9">&#x00A0;s;</span>
   </div>
<!--l. 94--><p class="noindent" >It uses two built-in Java types: <span 
class="cmtt-10">int </span>(representing integers) and <span 
class="cmtt-10">String </span>(Unicode
character arrays). While a layman might expect that when this program is run, <span 
class="cmtt-10">x </span>will
be set to <span 
class="cmtt-10">7</span>, the Java compiler refuses to compile this code; the compile-time error
that results says that the <span 
class="cmtt-10">+ </span>operation is not defined between values of type <span 
class="cmtt-10">int </span>and
<span 
class="cmtt-10">String </span>(though see Section&#x00A0;<a 
href="#x1-100002.6">2.6<!--tex4ht:ref: implicit type conversions --></a> to see why the opposite does in fact work). This is
the essence of static typing: code which violates a type&#8217;s definition is invalid and is
not compiled. Such type related errors can thus never occur in run-time
code.
   <h5 class="subsubsectionHead"><a 
 id="x1-60002.3"></a>Implicit type declarations</h5>
<!--l. 99--><p class="noindent" >Many statically typed languages, such as Java, require the explicit static <span 
class="cmti-10">declaration</span>
of types. That is, whenever a type is used it must be declared before hand, hence <span 
class="cmtt-10">int</span>
<span 
class="cmtt-10">i = 3 </span>and so on.
<!--l. 101--><p class="indent" >   It is often incorrectly assumed that all statically typed languages require explicit
type declarations. Some statically typed languages can automatically infer
the correct type of many expressions, requiring explicit declarations only
when automatic inference by the compiler fails. For example, the following
Haskell&#x00A0;<span class="cite">[<a 
href="#Xpeyton_jones__haskell_98_languages_and_libraries">Jon03</a>]</span> code gives an equivalent compile-time error message to its
Java cousin, despite the fact that the types of <span 
class="cmtt-10">i </span>and <span 
class="cmtt-10">s </span>are not explicitly
declared:
   <div class="fancyvrb" id="fancyvrb2">
<a 
 id="x1-6002r1"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;let</span>
<br class="fancyvrb" /><a 
 id="x1-6004r2"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;i</span><span 
class="cmtt-9">&#x00A0;=</span><span 
class="cmtt-9">&#x00A0;3</span>
<br class="fancyvrb" /><a 
 id="x1-6006r3"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;s</span><span 
class="cmtt-9">&#x00A0;=</span><span 
class="cmtt-9">&#x00A0;"4"</span>
<br class="fancyvrb" /><a 
 id="x1-6008r4"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;in</span>
<br class="fancyvrb" /><a 
 id="x1-6010r5"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;i</span><span 
class="cmtt-9">&#x00A0;+</span><span 
class="cmtt-9">&#x00A0;s</span>
   </div>
<!--l. 109--><p class="noindent" >In this chapter, I define the term &#8216;statically typed languages&#8217; to include both implicitly
and explicitly statically typed languages.

   <h5 class="subsubsectionHead"><a 
 id="x1-70002.3"></a>Nominal and structural typing</h5>
<!--l. 116--><p class="noindent" >As stated earlier, types are typically organised into hierarchies. There are
two chief mechanisms for organising such hierarchies. Nominal typing, as
found in languages such as Java, is when an explicit named relationship
between two types is recorded; for example, a user explicitly stating that
Oranges are a sub-type of Fruit. Structural typing, as found in languages such
as Haskell, is when the components of two types allow a type system to
automatically infer that they are related in some way. For example, the Orange type
contains all the components of the Fruit type, plus an extra &#8216;peel thickness&#8217;
component&#8212;a structurally typed system will automatically infer that all Oranges
are Fruits, but that opposite is not necessarily true. Sturctural typing as
described here is only found in statically typed languages although a similar
feature &#8211; duck typing &#8211; is found in dynamically typed languages (see Section
<a 
href="#x1-420005.7">5.7<!--tex4ht:ref: duck typing --></a>).
<!--l. 120--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.4   </span> <a 
 id="x1-80002.4"></a>Dynamic typing</h4>
<!--l. 122--><p class="noindent" >Dynamic typing, at its simplest level, is when type checks are left until run-time. It is
important to note that this is different than being <span 
class="cmti-10">typeless</span>: both statically and
dynamically typed languages are typed, the chief technical difference between them
being <span 
class="cmti-10">when </span>types are enforced. For example the following Converge&#x00A0;<span class="cite">[<a 
href="#Xtratt__converge_manual">Tra07</a>]</span> code
compiles correctly but when run, the <span 
class="cmtt-10">Int.+ </span>function raises a run-time type exception
<span 
class="cmtt-10">Expected arg 2 to be conformant to Number but got instance of</span>
<span 
class="cmtt-10">String</span>:
   <div class="fancyvrb" id="fancyvrb3">
<a 
 id="x1-8002r1"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;i</span><span 
class="cmtt-9">&#x00A0;:=</span><span 
class="cmtt-9">&#x00A0;3</span>
<br class="fancyvrb" /><a 
 id="x1-8004r2"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;s</span><span 
class="cmtt-9">&#x00A0;:=</span><span 
class="cmtt-9">&#x00A0;"4"</span>
<br class="fancyvrb" /><a 
 id="x1-8006r3"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;x</span><span 
class="cmtt-9">&#x00A0;:=</span><span 
class="cmtt-9">&#x00A0;i</span><span 
class="cmtt-9">&#x00A0;+</span><span 
class="cmtt-9">&#x00A0;s</span>
   </div>
<!--l. 128--><p class="noindent" >In this example one can trivially statically analyse the code and determine the eventual
run-time error. However, in general, dynamically typed languages allow code which is
more expressive than any current type system can statically check&#x00A0;<span class="cite">[<a 
href="#Xcartwright_fagan__soft_typing">CF91</a>]</span>.
For example, in non-OO languages static type systems typically prevent an
individual function from having multiple return points if each returns results of
differing, incompatible, types. In OO languages, on the other hand, the compiler
statically determines the set of methods (considering subtypes) that an object
method call refers to; in dynamically typed languages the method lookup
happens at run-time. This run-time lookup is known as <span 
class="cmti-10">late binding </span>and allows
objects to dynamically alter their behaviour, allowing greater flexibility in the
manipulation of objects, the price being that lookups can fail as in the above
example.
<!--l. 132--><p class="noindent" >

   <h4 class="subsectionHead"><span class="titlemark">2.5   </span> <a 
 id="x1-90002.5"></a>Safe and unsafe typing</h4>
<!--l. 136--><p class="noindent" >Programs written with static types are often said to be
<span 
class="cmti-10">safe</span><span class="footnote-mark"><a 
href="aic20082.html#fn1x0"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-9001f1"></a>
in the sense that type-related errors caught at compile-time can not occur at
run-time. However most statically typed languages allow user programs to <span 
class="cmti-10">cast </span>(i.e.
force) values of one type to be considered as conformant to another type. For
example, in C one can cast an underlying <span 
class="cmtt-10">int </span>value to be considered as an Orange,
even if this is semantically nonsensical; instances of the two types are unlikely to
share the same memory representation, and indeed may use different quantities of
memory. Programs which abuse this feature can crash arbitrarily. Languages whose
type systems can be completely overruled by the user are said to have an <span 
class="cmti-10">unsafe</span>
typing system.
<!--l. 138--><p class="indent" >   In contrast to unsafe typing, languages with a safe type system do not allow the
user to subvert it. This can be achieved either by disallowing casting (e.g. Haskell) or
inserting run-time checks to ensure that casts do not subvert the type system (e.g.
Java). For example, an object which conforms to the Red Apple type can always be
cast to the Apple type. However objects which conform to the Apple type can only be
cast to the Red Apple type if the object genuinely conforms to the Red Apple type
(or one of its sub-types); attempting to cast a Green Apple object to the
Red Apple type will cause a run-time check to fail and an exception to be
raised.
<!--l. 140--><p class="indent" >   The concept of safe and unsafe type systems is orthogonal to that of
static and dynamic typing. Static type systems can be safe (Java) or
unsafe (C); all dynamically typed languages of which I am aware are
safe<span class="footnote-mark"><a 
href="aic20083.html#fn2x0"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-9002f2"></a>.
   <h4 class="subsectionHead"><span class="titlemark">2.6   </span> <a 
 id="x1-100002.6"></a>Implicit type conversions</h4>
<!--l. 147--><p class="noindent" >In many languages &#8211; both statically and dynamically typed &#8211; a number of implicit
type conversions (also known as &#8216;coercions&#8217;) are defined. This means that, in a given
context, values of an &#8216;incorrect&#8217; type are automatically converted into the &#8216;correct&#8217;
type. For example, in Perl&#x00A0;<span class="cite">[<a 
href="#Xwall00programming">WCO00</a>]</span>, the addition of a number and a string evaluates
to a number as the string is implicitly converted into a number; in contrast in
Python&#x00A0;<span class="cite">[<a 
href="#Xpython2.3languagereference">vR03</a>]</span> a run-time type error is raised. The C language defines a large
number of implicit type conversions between number types. At the extreme
end of the spectrum, the TCL language implicitly converts every type into
a string&#x00A0;<span class="cite">[<a 
href="#Xousterhout__tcl_and_the_tk_toolkit">Ous94</a>]</span>. Implicit type conversions need not be symmetrical; for

example in Java adding a string to a number gives a compile-time warning (see
Section&#x00A0;<a 
href="#x1-50002.3">2.3<!--tex4ht:ref: static typing --></a> for an example) while adding a number to a string returns a
string.
<!--l. 150--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.7   </span> <a 
 id="x1-110002.7"></a>Terminology summary</h4>
   <div class="table">

<!--l. 152--><p class="indent" >   <a 
 id="x1-110011"></a><hr class="float"><div class="float" 
>

<div class="center" 
>
<!--l. 153--><p class="noindent" >
<div class="tabular">
 <table id="TBL-1" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-1-1g"><col 
id="TBL-1-1"><col 
id="TBL-1-2"><col 
id="TBL-1-3"><col 
id="TBL-1-4"><col 
id="TBL-1-5"><col 
id="TBL-1-6"><col 
id="TBL-1-7"><col 
id="TBL-1-8"></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-1-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-1-1"  
class="td01">                       </td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-1-2"  
class="td11">C</td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-1-3"  
class="td11">Converge</td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-1-4"  
class="td11">Haskell</td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-1-5"  
class="td11">Java</td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-1-6"  
class="td11">Perl</td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-1-7"  
class="td11">Python</td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-1-8"  
class="td10">Ruby</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-1-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-2-1"  
class="td01">Compile-time type checking</td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-2-2"  
class="td11"><span 
class="cmsy-10">&#x2219;</span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-2-3"  
class="td11">    <span 
class="cmsy-10">&#x2218;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-2-4"  
class="td11">   <span 
class="cmsy-10">&#x2219;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-2-5"  
class="td11">  <span 
class="cmsy-10">&#x2219; </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-2-6"  
class="td11"> <span 
class="cmsy-10">&#x2218; </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-2-7"  
class="td11">   <span 
class="cmsy-10">&#x2218;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-2-8"  
class="td10">  <span 
class="cmsy-10">&#x2218; </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-1-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-3-1"  
class="td01">Run-time type checking      </td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-3-2"  
class="td11"><span 
class="cmsy-10">&#x2218;</span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-3-3"  
class="td11">    <span 
class="cmsy-10">&#x2219;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-3-4"  
class="td11">   <span 
class="cmsy-10">&#x2218;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-3-5"  
class="td11">  <span 
class="cmsy-10">&#x2219; </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-3-6"  
class="td11"> <span 
class="cmsy-10">&#x2219; </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-3-7"  
class="td11">   <span 
class="cmsy-10">&#x2219;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-3-8"  
class="td10">  <span 
class="cmsy-10">&#x2219; </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-1-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-4-1"  
class="td01">Safe typing                      </td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-4-2"  
class="td11"><span 
class="cmsy-10">&#x2218;</span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-4-3"  
class="td11">    <span 
class="cmsy-10">&#x2219;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-4-4"  
class="td11">   <span 
class="cmsy-10">&#x2219;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-4-5"  
class="td11">  <span 
class="cmsy-10">&#x2219; </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-4-6"  
class="td11"> <span 
class="cmsy-10">&#x2219; </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-4-7"  
class="td11">   <span 
class="cmsy-10">&#x2219;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-4-8"  
class="td10">  <span 
class="cmsy-10">&#x2219; </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-1-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-5-1"  
class="td01">Implicit typing                 </td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-5-2"  
class="td11"><span 
class="cmsy-10">&#x2218;</span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-5-3"  
class="td11">   n/a    </td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-5-4"  
class="td11">   <span 
class="cmsy-10">&#x2219;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-5-5"  
class="td11">  <span 
class="cmsy-10">&#x2218; </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-5-6"  
class="td11"> n/a </td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-5-7"  
class="td11">  n/a   </td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-5-8"  
class="td10"> n/a </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-1-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-6-1"  
class="td01">Structural typing              </td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-6-2"  
class="td11"><span 
class="cmsy-10">&#x2218;</span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-6-3"  
class="td11">   n/a    </td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-6-4"  
class="td11">   <span 
class="cmsy-10">&#x2219;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-6-5"  
class="td11">  <span 
class="cmsy-10">&#x2218; </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-6-6"  
class="td11"> n/a </td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-6-7"  
class="td11">  n/a   </td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-6-8"  
class="td10"> n/a </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-1-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-7-1"  
class="td01">Run-time type errors         </td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-7-2"  
class="td11"><span 
class="cmsy-10">&#x2218;</span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-7-3"  
class="td11">    <span 
class="cmsy-10">&#x2219;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-7-4"  
class="td11">   <span 
class="cmsy-10">&#x2218;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-7-5"  
class="td11">  <span 
class="cmsy-10">&#x2219; </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-7-6"  
class="td11"> <span 
class="cmsy-10">&#x2219; </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-7-7"  
class="td11">   <span 
class="cmsy-10">&#x2219;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-7-8"  
class="td10">  <span 
class="cmsy-10">&#x2219; </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-1-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-8-1"  
class="td01">Implicit type conversions    </td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-8-2"  
class="td11"><span 
class="cmsy-10">&#x2219;</span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-8-3"  
class="td11">    <span 
class="cmsy-10">&#x2218;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-8-4"  
class="td11">   <span 
class="cmsy-10">&#x2218;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-8-5"  
class="td11">  <span 
class="cmsy-10">&#x2219; </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-8-6"  
class="td11"> <span 
class="cmsy-10">&#x2219; </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-8-7"  
class="td11">   <span 
class="cmsy-10">&#x2218;  </span></td><td  style="white-space:nowrap; text-align:center;" id="TBL-1-8-8"  
class="td10">  <span 
class="cmsy-10">&#x2219; </span></td>

</tr><tr  
 style="vertical-align:baseline;" id="TBL-1-9-"><td  style="white-space:nowrap; text-align:left;" id="TBL-1-9-1"  
class="td01">                       </td></tr></table></div></div>
<br /> <div class="caption" 
><span class="id">Table&#x00A0;1:  </span><span  
class="content">Language  comparison  with  respect  to  typing  (&#8216;n/a&#8217;  meaning  &#8216;not
applicable&#8217;).</span></div><!--tex4ht:label?: x1-110011 -->

   </div><hr class="endfloat" />
   </div>
<!--l. 171--><p class="indent" >   Table&#x00A0;<a 
href="#x1-110011">1<!--tex4ht:ref: table:language comparison with respect to typing --></a> shows a comparison of a number of languages with respect to the terms
defined in this section. As is clearly shown, languages utilise types in almost every
conceivable combination, making the traditional &#8216;hard&#8217; distinction between
statically and dynamically typed languages seem very simplistic. Both classes of
languages are typed, the chief technical difference between them being <span 
class="cmti-10">when</span>
types are enforced. The terms &#8216;statically typed&#8217; and &#8216;dynamically typed&#8217;
are the source of much confusion but are sufficiently embedded within the
community that it is unlikely that they will be superseded&#8212;hence why I use those
terms in this chapter. However readers may find it more helpful to think
of &#8216;static typing&#8217; as that performed at compile-time and dynamic typing
that performed at run-time. This can help understand the real-world, where
most &#8216;statically typed&#8217; languages also utilise run-time type checking, and
where some &#8216;dynamically typed&#8217; languages allow optional compile-time type
checking.
   <h3 class="sectionHead"><span class="titlemark">3   </span> <a 
 id="x1-120003"></a>Disadvantages of static typing</h3>
<!--l. 179--><p class="noindent" >The advantages of static typing are widely known&#x00A0;<span class="cite">[<a 
href="#Xbracha__pluggable_type_systems">Bra04</a>]</span> and include:
   <ul class="itemize1">
   <li class="itemize">Each error detected at compile-time prevents a run-time error.
   </li>
   <li class="itemize">Types are a form of documentation / comment.
   </li>
   <li class="itemize">Types enable many forms of optimisation.</li></ul>
<!--l. 191--><p class="indent" >   Taken at face value, the first of these is a particularly compelling argument: why
would anyone choose to use less reliable languages? In reality the absence or presence
of static typing has a number of effects on the use and applicability of a
language that are not explained by the above. In particular, because the
overwhelming body of research on programming languages has been on statically
typed languages, the disadvantages of statically typed languages are rarely
enumerated. In this section I enumerate some of the weaknesses of static
typing and why it is therefore not equally applicable to every programming
task.
<!--l. 194--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.1   </span> <a 
 id="x1-130003.1"></a>Static types are inexpressive</h4>
<!--l. 196--><p class="noindent" >As defined in Section&#x00A0;<a 
href="#x1-30002.1">2.1<!--tex4ht:ref: types --></a>, types are constraints. In practice, programming
language types most closely conform to the intuitive notion of &#8216;shape&#8217; or
&#8216;form&#8217;. Perhaps surprisingly, in some situations types can be too permissive
and in others too restrictive (for an extreme example of this duality, see

overloading in Java&#x00A0;<span class="cite">[<a 
href="#Xancona_zucca_drossopoulou__overloading_and_inheritance">AZD01</a>]</span>). Furthermore as static types need to be checked at
compile-time, by definition they lack run-time information about values, further
limiting their expressivity (interestingly, the types used in dynamically typed
languages are virtually identical in expressivity to those used in statically
typed languages, probably due to cultural expectations rather than technical
issues).
   <h5 class="subsubsectionHead"><a 
 id="x1-140003.1"></a>Overly permissive types</h5>
<!--l. 201--><p class="noindent" >Consider the following Java code which fails at run-time with a <span 
class="cmtt-10">division by zero</span>
exception:
   <div class="fancyvrb" id="fancyvrb4">
<a 
 id="x1-14002r1"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;int</span><span 
class="cmtt-9">&#x00A0;x</span><span 
class="cmtt-9">&#x00A0;=</span><span 
class="cmtt-9">&#x00A0;2;</span>
<br class="fancyvrb" /><a 
 id="x1-14004r2"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;int</span><span 
class="cmtt-9">&#x00A0;y</span><span 
class="cmtt-9">&#x00A0;=</span><span 
class="cmtt-9">&#x00A0;0;</span>
<br class="fancyvrb" /><a 
 id="x1-14006r3"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;int</span><span 
class="cmtt-9">&#x00A0;z</span><span 
class="cmtt-9">&#x00A0;=</span><span 
class="cmtt-9">&#x00A0;x</span><span 
class="cmtt-9">&#x00A0;/</span><span 
class="cmtt-9">&#x00A0;y;</span>
   </div>
<!--l. 207--><p class="noindent" >Looking at this, programmers of even moderate experience can statically spot the cause
of the error: the divisor should not be zero. Java&#8217;s compiler can not statically detect
this error because the <span 
class="cmtt-10">int </span>type represents real numbers including zero; thus the above
code is statically type correct according to Java&#8217;s types. Not only is there not a type
in Java which represents the real numbers excluding zero, there is no mechanism for
defining such a type in a way that would result in equivalent code leading to a
compile-time error. This limitation is shared by virtually all statically typed
languages.
<!--l. 209--><p class="indent" >   As suggested above, the static types available in todays mainstream languages are
particularly inexpressive. Though research languages such as Haskell contain more
advanced type systems, they still have many practical limitations. Consider the <span 
class="cmtt-10">head</span>
function, which takes a list and returns its first element; given an empty list, <span 
class="cmtt-10">head</span>
raises a run-time exception. Taking the head of an empty list is a common
programming error, and is particularly frustrating in programming languages such as
Haskell whose run-time error reporting makes tracking down run-time errors
difficult&#x00A0;<span class="cite">[<a 
href="#Xshields_sheard_peyton_jones__dynamic_typing_as_staged_type_inference">SSJ98</a>]</span>. It is possible to make a new list type, and a corresponding <span 
class="cmtt-10">head</span>
function, which can statically guarantee that the head of an empty list will never be
taken&#x00A0;<span class="cite">[<a 
href="#Xxi_pfenning__eliminating_array_bound_checking_through_dependent_types">XP98</a>]</span>; however this only works for lists whose size is always statically known.
Lists that are created on the basis of user input &#8211; a far more likely scenario &#8211; are
highly unlikely to be statically checkable. Trying to use a type system in
this way adds significant complexity to user programs with only minimal
benefits.
<!--l. 211--><p class="indent" >   Because of the general inexpressiveness of static types, an entirely separate strand
of research tries to statically analyse programs to detect errors that escape
static type checkers (see e.g.&#x00A0;<span class="cite">[<a 
href="#Xmitchell_runciman__unfailing_haskell_a_static_checker_for_pattern_matching">MR05</a>]</span> for work directly related to the <span 
class="cmtt-10">head</span>
function).
   <h5 class="subsubsectionHead"><a 
 id="x1-150003.1"></a>Overly restrictive types</h5>

<!--l. 216--><p class="noindent" >Since any practical type system needs to be both decidable and sound, they are not
complete; in other words, certain valid programs will be rejected by the type
checker&#x00A0;<span class="cite">[<a 
href="#Xaiken_wimmers_lakshman__soft_typing_with_conditional_types">AWL94</a>,&#x00A0;<a 
href="#Xmatthews__static_and_dynamic_type_checking">Mat90</a>]</span>. For example, type systems provide a fixed, typically small
(or even empty), number of ways of relating types, with object orientated languages
allowing types to be defined as sub-types of others allowing a certain kind of
polymorphism. However programmers often need to express relationships between
types that static types prevent, even in research languages with advanced type
systems such as ML&#x00A0;<span class="cite">[<a 
href="#Xcartwright_fagan__soft_typing">CF91</a>]</span>.
   <h5 class="subsubsectionHead"><a 
 id="x1-160003.1"></a>Type system complexity</h5>
<!--l. 221--><p class="noindent" >From a pragmatic point of view, relatively small increases in the expressivity of static
type systems cause a disproportionately large increase in complexity&#x00A0;<span class="cite">[<a 
href="#Xmacqueen__reflections_on_standard_ml">Mac93</a>,&#x00A0;<a 
href="#Xmeijer_drayton__static_typing_when_possible_dynamic_typing_when_needed_the_end_of_the_cold_war_between_programming_languages">MD04</a>]</span>.
This can be seen clearly in Abadi and Cardelli&#8217;s theoretical work which defines static
type systems of increasing expressiveness for object orientated languages&#x00A0;<span class="cite">[<a 
href="#Xtheory_of_objects">AC96</a>]</span>;
their latter systems, though expressive, are sufficiently complex that, to the best of
my knowledge, they have never been implemented in any language.
<!--l. 226--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.2   </span> <a 
 id="x1-170003.2"></a>Types are represented by a separate language</h4>
<!--l. 228--><p class="noindent" >Since most of us are used to the presence of explicit static types, it is easy to overlook
the fact that they are represented by an entirely different language from the base
programming language. In other words, when learning the syntax and semantics
of programming <span 
class="cmti-10">X</span>, one must also learn the syntactically and semantically
distinct static type language <span 
class="cmti-10">XT</span>. That <span 
class="cmti-10">X </span>and <span 
class="cmti-10">XT </span>are, at heart, separate
languages can be seen by the very different types of errors that result from
violating each&#8217;s semantics. While programming languages have developed
various mechanisms when presenting error information to aid programmers,
the error messages from static type systems are often baroque and hard to
understand&#x00A0;<span class="cite">[<a 
href="#Xmeijer__confessions_of_a_used_programming_language_salesman">Mei07</a>]</span>.
<!--l. 231--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.3   </span> <a 
 id="x1-180003.3"></a>Type systems&#8217; correctness</h4>
<!--l. 233--><p class="noindent" >Static type systems are often the most complex parts of a programming language&#8217;s
specification. Because of this it is easy for them to contain errors which then result in
&#8216;impossible&#8217; run-time behaviour&#x00A0;<span class="cite">[<a 
href="#Xcardelli__type_systems">Car97</a>]</span>.
<!--l. 235--><p class="indent" >   A famous example comes from Eiffel&#x00A0;<span class="cite">[<a 
href="#Xmeyer__eiffel_the_language">Mey92</a>]</span>, one of the first &#8216;mainstream&#8217;
object orientated languages. Eiffel allows overridden methods to use subtypes
of the parameters in the superclass. Consider classes <span 
class="cmtt-10">A1</span>, <span 
class="cmtt-10">A2</span>, <span 
class="cmtt-10">B1</span>, <span 
class="cmtt-10">B2</span>, and
<span 
class="cmtt-10">B3</span>, where <span 
class="cmtt-10">A2 </span>subclasses <span 
class="cmtt-10">A1</span>, and <span 
class="cmtt-10">B3 </span>subclasses <span 
class="cmtt-10">B2 </span>which subclasses <span 
class="cmtt-10">B1</span>. In
object orientated languages in general, instances of subclasses (e.g. <span 
class="cmtt-10">A2</span>) can be
considered as instances of superclasses (e.g. <span 
class="cmtt-10">A1</span>); intuitively this is because

subclasses have type-identical versions of everything in the superclass plus,
optionally, extra things. Eiffel subtly changes this, so that subclasses can contain
type-compatible versions of everything in the superclass plus, optionally,
extra things. Therefore in Eiffel one can define a method <span 
class="cmtt-10">m(p1:B2) </span>(meaning
that <span 
class="cmtt-10">m </span>has a parameter <span 
class="cmtt-10">p1 </span>of type <span 
class="cmtt-10">B2</span>) in class <span 
class="cmtt-10">A1 </span>that is overridden in class
<span 
class="cmtt-10">A2 </span>by <span 
class="cmtt-10">m(p1:B3)</span>. If an instance of <span 
class="cmtt-10">A2 </span>is considered to be an instance of its
superclass <span 
class="cmtt-10">A1</span>, then an instance of <span 
class="cmtt-10">B2 </span>can validly be passed to <span 
class="cmtt-10">A2::m </span>which
may then attempt to access an attribute present only in instances of the
subclass <span 
class="cmtt-10">B3</span>. Such <span 
class="cmti-10">covariant </span>typing is unsafe and programs which utilise it
can crash arbitrarily at run-time despite it satisfying Eiffel&#8217;s type safety
rules&#x00A0;<span class="cite">[<a 
href="#Xcook__a_proposal_for_making_eiffel_type_safe">Coo89</a>]</span>.
<!--l. 237--><p class="indent" >   As the Eiffel example suggests, and despite their formal veneer, the vast majority
of static type systems are not proved correct; some are sufficiently complex
that a full proof of correctness is impractical or impossible&#x00A0;<span class="cite">[<a 
href="#Xbracha__pluggable_type_systems">Bra04</a>]</span>. Eiffel
again gives us a good example of the subtleties that type systems involve:
counter-intuitively type theory shows that <span 
class="cmtt-10">A2::m </span>could safely use super-types of the
parameter types in <span 
class="cmtt-10">A1::m </span>(i.e. <span 
class="cmti-10">contravariant </span>typing), so <span 
class="cmtt-10">A2::m(p1:B1) </span>is
type-safe&#x00A0;<span class="cite">[<a 
href="#Xcastagna__covariance_versus_contravariance_conflict_without_a_cause">Cas95</a>]</span>.
<!--l. 239--><p class="indent" >   Flaws discovered in type systems are particularly invidious, because changes to
type systems will typically break most extant programs; for this reason, even
modern versions of Eiffel contain the above flaw (whilst alleviating it to some
extent).
<!--l. 242--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.4   </span> <a 
 id="x1-190003.4"></a>System ossification</h4>
<!--l. 246--><p class="noindent" >Virtually all software systems are changed, often continuously, and rarely in a
planned or anticipated manner, after their original development&#x00A0;<span class="cite">[<a 
href="#Xlehman_belady__program_evolution_processes_of_software_change">LB85</a>]</span>.
It is therefore an implicit requirement that software be amenable to such
change, which further implies that programming languages facilitate such
change.
<!--l. 248--><p class="indent" >   When changing a program, it is often desirable to change small sections at a time
and see the effect of that change on that particular part of the program, so that any
new errors can be easily related to the change; when performing such changes it is
often expected that the program as a whole may not work correctly. Static type
systems often prevent this type of development, because they require that the system
as a whole is always type correct: it is not possible to temporarily turn off static
type-checking. As static types make changing a system difficult, they inevitably cause
systems to prematurely ossify, making them harder to adapt to successive
changes&#x00A0;<span class="cite">[<a 
href="#Xnierstrasz_bergel_denker_ducasse_galli_wuyts__on_the_revival_of_dynamic_languages">NBD<sup><span 
class="cmr-7">+</span></sup>05</a>]</span>.
<!--l. 251--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">3.5   </span> <a 
 id="x1-200003.5"></a>Run-time dynamicity</h4>

<!--l. 255--><p class="noindent" >Software is increasingly required to inspect and alter its behaviour at run-time, often
in the context of critical systems that are expected to run without downtime, which
must be patched whilst still running&#x00A0;<span class="cite">[<a 
href="#Xhicks_nettles__dynamic_software_updating">HN05</a>]</span>. Traditionally statically typed languages&#8217;
compilers have discarded most information about a programs structure, its types, and
so on during the compilation process, as they are not considered central to the
programs execution. This means that most such languages are incapable of
meaningful <span 
class="cmti-10">reflection</span>&#x00A0;<span class="cite">[<a 
href="#Xdemers_malenfant__reflection_in_logic_functional_and_object_oriented_programming_a_short_comparative_study">DM95</a>]</span>. Of those that do (e.g. Java), the ability to change
the run-time behaviour of a program is relatively limited because of the
possibility of subverting the type system. This means that statically typed
languages have typically proved difficult to use in systems that require run-time
dynamicity&#x00A0;<span class="cite">[<a 
href="#Xnierstrasz_bergel_denker_ducasse_galli_wuyts__on_the_revival_of_dynamic_languages">NBD<sup><span 
class="cmr-7">+</span></sup>05</a>]</span>.
<!--l. 259--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">4   </span> <a 
 id="x1-210004"></a>History</h3>
<!--l. 261--><p class="noindent" >Dynamically typed languages have a long and varied history. While few dynamically
typed languages have had a direct impact on the programming mainstream, they have
had a disproportionate effect on programming languages in general. Perhaps because
of their inherently flexible nature, or the nature of the people attracted to
them, dynamically typed languages have pioneered a bewildering array of
features. Thus the history of dynamically typed languages is intertwined
with that of statically typed programming languages which, often after a
significant delay, have incorporated the features pioneered in dynamically typed
languages.
<!--l. 263--><p class="indent" >   To the best of my knowledge, a history of dynamically typed languages has not
yet been published, although the History of Programming Languages (HOPL)
conferences<span class="footnote-mark"><a 
href="aic20084.html#fn3x0"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-21001f3"></a>
include histories of several of the most important languages (see
e.g.&#x00A0;<span class="cite">[<a 
href="#Xsteele_gabriel__the_evolution_of_lisp">SG96</a>,&#x00A0;<a 
href="#Xkay__the_early_history_of_smalltalk">Kay96</a>,&#x00A0;<a 
href="#Xgriswold_griswold__history_of_the_icon_programming_language">GG96a</a>]</span>). A full history is far beyond the scope of this chapter.
However there have been several important innovations and trends which explain the
direction that dynamically typed languages have taken and why current dynamically
typed languages take the shape they do. The initial history of dynamically
typed languages is largely of individual languages &#8211; Lisp and Smalltalk in
particular &#8211; while the more recent history sees groups of languages &#8211; such as
so-called &#8216;scripting&#8217; languages including Perl, Python, and Ruby &#8211; forging
a common direction. Therefore this section enumerates, in approximately
chronological order, the major points in the evolution of dynamically typed
languages.
   <h4 class="subsectionHead"><span class="titlemark">4.1   </span> <a 
 id="x1-220004.1"></a>Lisp and its derivatives</h4>

<!--l. 268--><p class="noindent" >Arguably the first dynamically typed language, certainly the oldest still in use, and
without doubt the most influential dynamically typed language is Lisp&#x00A0;<span class="cite">[<a 
href="#Xmccarthy__recursive_functions_of_symbolic_expressions_and_their_computation_by_machine_part_i">McC60</a>]</span>.
Created in the 1950&#8217;s, Lisp was originally intended as a practical notation for the
<span 
class="cmmi-10">&#x03BB;</span>-calculus &#x00A0;<span class="cite">[<a 
href="#Xmccarthy__history_of_lisp">McC78</a>]</span>. Lisp is notable for its minimal syntax, the smallest of any extant
programming language used in the real-world, allowing it a similarly small and
uniform semantics. This simplicity &#8211; it was quickly discovered that it is possible to
specify a minimal Lisp interpreter in a single page of Lisp code &#8211; made its
implementation practical on machines of the day. That the innovations pioneered by,
and within, Lisp are too many too mention can be inferred from its introduction of
the <span 
class="cmtt-10">if-then-else </span>construct now taken for granted in virtually all programming
languages.
<!--l. 270--><p class="indent" >   Simply labelled, Lisp is an impure functional language. To modern eyes, Lisp is
unusual because its concrete syntax uses prefix notation as can be seen from this
simple example of a Fibonacci function:
   <div class="fancyvrb" id="fancyvrb5">
<a 
 id="x1-22002r1"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;(defun</span><span 
class="cmtt-9">&#x00A0;fib</span><span 
class="cmtt-9">&#x00A0;(n)</span>
<br class="fancyvrb" /><a 
 id="x1-22004r2"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;(if</span><span 
class="cmtt-9">&#x00A0;(=</span><span 
class="cmtt-9">&#x00A0;n</span><span 
class="cmtt-9">&#x00A0;0)</span>
<br class="fancyvrb" /><a 
 id="x1-22006r3"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;0</span>
<br class="fancyvrb" /><a 
 id="x1-22008r4"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;(if</span><span 
class="cmtt-9">&#x00A0;(=</span><span 
class="cmtt-9">&#x00A0;n</span><span 
class="cmtt-9">&#x00A0;1)</span>
<br class="fancyvrb" /><a 
 id="x1-22010r5"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;1</span>
<br class="fancyvrb" /><a 
 id="x1-22012r6"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;(+</span><span 
class="cmtt-9">&#x00A0;(fib</span><span 
class="cmtt-9">&#x00A0;(-</span><span 
class="cmtt-9">&#x00A0;n</span><span 
class="cmtt-9">&#x00A0;1))</span><span 
class="cmtt-9">&#x00A0;(fib</span><span 
class="cmtt-9">&#x00A0;(-</span><span 
class="cmtt-9">&#x00A0;n</span><span 
class="cmtt-9">&#x00A0;2))))))</span>
   </div>
<!--l. 279--><p class="noindent" >Lisp&#8217;s minimal syntax allows it to be naturally represented by Lisp lists. Since lists can
be inspected, altered, and created this led to what is arguably Lisp&#8217;s most distinctive
feature: macros. A macro is effectively a special function which, at compile-time,
generates code. Macros allow users to extend a programming language in ways
unforeseen by its creators&#x00A0;<span class="cite">[<a 
href="#Xbrabrand_schwartzbach__growing_languages_with_metamorphic_syntax_macros">BS00</a>]</span>. Macros have therefore been a key facilitator in
Lisp&#8217;s continued existence, as they allow the spartan base language to be seamlessly
extended: a typical Lisp implementation will implement most of its seemingly
&#8216;primitive&#8217; control structures through macros (see Section&#x00A0;<a 
href="#x1-360005.3">5.3<!--tex4ht:ref: macros --></a>). Despite many
attempts, it was not until the late 1990&#8217;s that a syntactically rich, statically typed
language gained a practical macro-like facility broadly equivalent to Lisp&#8217;s
(see&#x00A0;<span class="cite">[<a 
href="#Xsheard__using_metaml_a_staged_programming_language">She98</a>,&#x00A0;<a 
href="#Xsheard_peyton_jones__template_meta_programming_for_haskell">SJ02</a>]</span>).
<!--l. 281--><p class="indent" >   Lisp invented the concept of garbage collection&#x00A0;<span class="cite">[<a 
href="#Xjones_lins__garbage_collection_algorithms_for_automatic_dynamic_memory_management">JL99</a>]</span> where memory allocation
and deallocation is handled automatically by the Lisp interpreter or VM. Lisp was
also the first language whose implementations made significant efforts to address
performance concerns&#x00A0;<span class="cite">[<a 
href="#Xgabriel__performance_and_evaluation_of_lisp_systems">Gab86</a>]</span>; many of the resulting implementation techniques have
become standard parts of subsequent language implementations.
   <h5 class="subsubsectionHead"><a 
 id="x1-230004.1"></a>Scheme</h5>
<!--l. 286--><p class="noindent" >Lisp has spawned many dialects, the most significant of which is Scheme&#x00A0;<span class="cite">[<a 
href="#Xsussman_steele__scheme_an_interpreter_for_extended_lambda_calculus">SJ75</a>]</span>. For
the purposes of this chapter, Scheme can be thought of as a version of Lisp with a
minimalist aesthetic, particularly with regard to its libraries. While Lisp has seen
reasonable industrial usage (particularly in the 1980&#8217;s, when it was the language of
choice for artificial intelligence work), Scheme has largely been a research language,

albeit a very influential one.
<!--l. 288--><p class="indent" >   Scheme was the first language to introduce closures, allowing full lexical scoping,
simplifying many types of programming such as Graphical User Interface (GUI)
programming. It also popularised the concept of continuations, allowing arbitrary
control structures to be constructed by the user&#x00A0;<span class="cite">[<a 
href="#Xhaynes_friedman_wand__continuations_and_coroutines">HFW84</a>]</span>. Scheme also showed that
functions and continuations could be treated as first-class objects. Much of
the foundational work on safe, powerful, macros was done in Scheme (see
e.g.&#x00A0;<span class="cite">[<a 
href="#Xkohlbecker_friedman_felleisen_duba__hygienic_macro_expansion">KFFD86</a>,&#x00A0;<a 
href="#Xclinger_rees__macros_that_work">CR91</a>]</span>).
<!--l. 292--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">4.2   </span> <a 
 id="x1-240004.2"></a>Smalltalk</h4>
<!--l. 296--><p class="noindent" >Smalltalk is Lisp&#8217;s nearest rival in influence. Put simply, Smalltalk is a small, uniform
object orientated language, heavily influenced by Lisp and Simula&#x00A0;<span class="cite">[<a 
href="#Xdahl_nygaard__an_algol_based_simulation_language">DN66</a>]</span>. Compared
to later languages, Smalltalk&#8217;s syntax is small and uncomplicated (though not as
minimalistic in nature as Lisp&#8217;s); however, in most other ways, Smalltalk-80&#x00A0;<span class="cite">[<a 
href="#Xgoldberg_robson__smalltalk_80_the_language">GR89</a>]</span>
(the root of all extant Smalltalk&#8217;s) is recognisably a modern, object orientated,
imperative programming language.
<!--l. 298--><p class="indent" >   Smalltalk pioneered the idea of &#8216;everything is an object&#8217; where even primitive
values (integers etc.) appear as normal objects whose classes are part of the standard
class hierarchy. Smalltalk has extensive meta-programming abilities. Reflection allows
programs to query and alter themselves&#x00A0;<span class="cite">[<a 
href="#Xmaes__concepts_and_experiments_in_computational_reflection">Mae87</a>]</span>. A Meta-Object Protocol
(MOP)&#x00A0;<span class="cite">[<a 
href="#Xkiczales_des_rivieres_bobrow__the_art_of_the_metaobject_protocol">KdRB91</a>]</span> allows objects to change the way they behave; from the perspective
of this chapter, the most significant of these abilities is meta-classes&#x00A0;<span class="cite">[<a 
href="#Xforman_danforth__putting_metaclasses_to_work_a_new_dimension_in_object_oriented_programming">FD98</a>]</span> (see
Section&#x00A0;<a 
href="#x1-350005.3">5.3<!--tex4ht:ref: mop in action --></a>).
<!--l. 300--><p class="indent" >   In Smalltalk every object can be queried at run-time to find out its type. In
common with most object orientated languages, a Smalltalk class also implicitly
defines a type (see Section&#x00A0;<a 
href="#x1-30002.1">2.1<!--tex4ht:ref: types and class conflation --></a>), so the &#8216;type&#8217; of an object is the <span 
class="cmtt-10">Class </span>object which
created it. A meta-class is simply the type of a class. In Smalltalk the default
meta-class for a class is called <span 
class="cmtt-10">Metaclass</span>; a cycle is created in the type hierarchy so
that <span 
class="cmtt-10">Metaclass </span>is its own type. Meta-classes allow Smalltalk to present a uniform,
closed world where every object in a running system is typed by an object in the same
running system. Only a small amount of bootstrapping is needed to create this
powerful illusion (later proposals have shown how the meta-class concept can be
further simplified&#x00A0;<span class="cite">[<a 
href="#Xcointe__metaclasses_are_first_class_the_objvlisp_model">Coi87</a>]</span>).
<!--l. 304--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">4.3   </span> <a 
 id="x1-250004.3"></a>Text processing languages</h4>
<!--l. 308--><p class="noindent" >Text processing is a perennial programming task, and several languages have been
wholly or mostly designed with this in mind. This domain has been dominated by
dynamically typed languages, because the processing of unstructured data benefits
greatly from the flexibility afforded by such languages&#x00A0;<span class="cite">[<a 
href="#Xmeijer_drayton__static_typing_when_possible_dynamic_typing_when_needed_the_end_of_the_cold_war_between_programming_languages">MD04</a>]</span>.
<!--l. 310--><p class="indent" >   The first languages aimed at these tasks, most noticeably SNOBOL4&#x00A0;<span class="cite">[<a 
href="#Xgriswold_poage_polonsky__the_snobol4_programming_language">GPP71</a>]</span>,
were effectively Domain Specific Languages (DSLs) for text processing, and were not

suitable for more general tasks&#x00A0;<span class="cite">[<a 
href="#Xgriswold__a_history_of_the_snobol_programming_languages">Gri78</a>]</span>. One of SNOBOL4&#8217;s direct successor languages
was Icon&#x00A0;<span class="cite">[<a 
href="#Xgriswold96icon">GG96b</a>]</span>, which introduced a unique expression evaluation system which
dispenses with boolean logic and allows limited backtracking within an imperative
language. This allows one to express complex string matching which can naturally
evaluate multiple possibilities.
<!--l. 312--><p class="indent" >   Sed and AWK &#x00A0;<span class="cite">[<a 
href="#Xaho_kernighan_weinberger__the_awk_programming_language">AKW98</a>]</span> represent an entirely different strand of text processing
languages from SNOBOL and Icon. They can be thought of as enhanced
UNIX shell languages, with AWK extending Sed with a number of more
general programming language constructs. Perl&#x00A0;<span class="cite">[<a 
href="#Xwall00programming">WCO00</a>]</span> represents the
final evolution of this family of languages. Reflecting its rle as a tool for
ad-hoc development, it integrates a bewildering number of influences to an
AWK base, and is notable for having arguably the most sophisticated &#8211; or,
depending on ones point of view, complex &#8211; syntax of any programming
language.
<!--l. 314--><p class="indent" >   Most of the above languages are not, in the widely understood sense, general
purpose languages. Icon is the most obviously general purpose language,
although because of the many idioms it encompasses, Perl has been used in
many domains. Because of the ubiquity of Sed and AWK and, in the early
years of the web, Perl&#8217;s dominance of server side processing, these languages
have been more widely used than any other category of dynamically typed
languages.
<!--l. 318--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">4.4   </span> <a 
 id="x1-260004.4"></a>Declarative languages</h4>
<!--l. 320--><p class="noindent" >Although dynamically typed languages are often implicitly assumed to be
imperative languages, dynamic typing is equally applicable to declarative
languages which, for the purposes of this chapter, I define to mean logic and
&#8216;pure&#8217; functional languages (i.e. those without side effects). Prolog&#x00A0;<span class="cite">[<a 
href="#Xsterling94prolog">SS94</a>]</span> was
amongst the first, and remains the most widely used, logic language. Logic
languages are very unlike &#8216;normal&#8217; languages, with the user declaring relations
amongst data, and then stating a goal over this which the language engine then
attempts to solve&#8212;the order in which statements in the language are executed is
non-linear.
<!--l. 322--><p class="indent" >   Pure functional languages<span class="footnote-mark"><a 
href="aic20085.html#fn4x0"><sup class="textsuperscript">4</sup></a></span><a 
 id="x1-26001f4"></a>
have largely been confined to the research lab and have tended to be coupled with
exotic static type systems. Although Erlang&#x00A0;<span class="cite">[<a 
href="#Xvirding_wikstrom_williams_armstrong__concurrent_programming_in_erlang">VWWA96</a>]</span> started existence as a
distributed variant of Prolog, it has since evolved to become one of the few
dynamically typed pure functional languages. This perhaps reflect its industrial
origins where it was designed to implement robust, scalable, distributed systems,
particularly telephony systems&#x00A0;<span class="cite">[<a 
href="#Xarmstrong__a_history_of_erlang">Arm07</a>]</span>. Erlang is arguably the most successful pure

functional language yet with several million LoC systems. By eschewing static
types, it is able to focus on the hard issues surrounding distributed systems,
including a number of unique concepts relating to message passing and fault
tolerance.
   <h4 class="subsectionHead"><span class="titlemark">4.5   </span> <a 
 id="x1-270004.5"></a>Prototyping languages</h4>
<!--l. 328--><p class="noindent" >Object orientated languages derived from SIMULA such as Smalltalk are class-based
languages: objects are created by instantiating classes. While everything in
Smalltalk is an object, practically speaking classes are a very distinguished
type of object from the users perspective. Self&#x00A0;<span class="cite">[<a 
href="#Xungar_smith__self_the_power_of_simplicity">US87</a>]</span> aimed to distill the
object orientated paradigm down to its bare essentials: objects, methods, and
message sends. In particular Self removed classes as a fundamental construct;
new objects are created by <span 
class="cmti-10">cloning </span>another object. The notion of type in
Self, and other prototyping languages, is thus subtly different than in other
languages.
<!--l. 330--><p class="indent" >   Because of their minimalistic nature, raw prototyping languages tend to be
particularly inefficient. Self pioneered a number of important implementation
techniques&#x00A0;<span class="cite">[<a 
href="#Xchambers_ungra__customization_optimizing_compiler_technology_for_self_a_dynamically_typed_object_oriented_programming_language">CU89</a>]</span> that ultimately allowed Self to become one of the highest
performing dynamically typed languages. Much of this work has found its way into
other languages, including statically typed languages such as Java&#x00A0;<span class="cite">[<a 
href="#Xaycock__a_brief_history_of_just_in_time">Ayc03</a>]</span>.
<!--l. 334--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">4.6   </span> <a 
 id="x1-280004.6"></a>Modern &#8216;scripting&#8217; languages</h4>
<!--l. 338--><p class="noindent" >The resurgence of interest in dynamically typed languages is largely due to what were
originally dismissively called &#8216;scripting&#8217; languages&#x00A0;<span class="cite">[<a 
href="#Xousterhout__scripting_higher_level_programming_for_the_21st_century">Ous98</a>]</span>, which had their roots in
text processing languages such as Sed and AWK (see Section&#x00A0;<a 
href="#x1-250004.3">4.3<!--tex4ht:ref: text processing languages --></a>). Unlike many of the
languages described earlier in this section, these languages were not designed with
innovation as a primary goal, and instead emphasised consolidation and
popularisation. They have therefore focused on practical issues such as portability,
and shipping with extensive libraries. TCL&#x00A0;<span class="cite">[<a 
href="#Xousterhout__tcl_and_the_tk_toolkit">Ous94</a>]</span> was the first such language,
which gained reasonable popularity in large part because of its bundled GUI
toolkit. Python and Ruby&#x00A0;<span class="cite">[<a 
href="#Xthomas_hunt__programming_ruby_a_pragmatic_programmers_guide">TH00</a>]</span> &#8211; fundamentally very similar languages once
surface syntax issues are ignored &#8211; can be seen as modernised, if less internally
consistent, versions of Smalltalk. Because of their inherent flexibility, such
languages were initially often used to &#8216;glue&#8217; other systems together, but have
increasingly seen to be useful for a wide range of programming tasks, such as web
programming tasks. Lua&#x00A0;<span class="cite">[<a 
href="#Xierusalimschy__programming_in_lua">Ier06</a>]</span> is a smaller language (both conceptually, and in its
implementation) than either Python and Ruby, and has been more explicitly designed
as an embeddable programming language; it has been used widely in the
computer games industry to allow the high-level definition and extension of
games&#x00A0;<span class="cite">[<a 
href="#Xierusalimschy_figueiredo_celes__the_evolution_of_lua">IdFC07</a>]</span>.
<!--l. 340--><p class="indent" >   While this sub-category of dynamically typed languages has not greatly advanced
the state of the art, it has been the driving factor in validating dynamically typed

languages and making them a respected part of a programmers toolbox. Most
new systems written using dynamically typed languages use this category of
languages.
<!--l. 344--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">5   </span> <a 
 id="x1-290005"></a>Defining features</h3>
<!--l. 348--><p class="noindent" >In previous sections I have defined the fundamental terms surrounding types and
programming languages, and presented a brief history of dynamically typed
languages. In this section I enumerate the defining features and characteristics of
dynamically typed languages, and explain why they make such languages interesting
and useful. Some of these features and characteristics have recently found their way
into new statically typed languages, either as a core feature or as library add-ons.
However no statically typed language contains all of them, nor is that likely to occur
both for technical and cultural reasons.
<!--l. 351--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1   </span> <a 
 id="x1-300005.1"></a>Simplicity</h4>
<!--l. 353--><p class="noindent" >A defining characteristic of virtually all dynamically typed languages is conceptual
simplicity. Fundamentally dynamically typed languages are willing to trade run-time
efficiency for programmer productivity. Such simplicity makes both learning and using
dynamically typed languages simpler, in general, than statically typed languages
since there are less &#8216;corner cases&#8217; to be aware of. At its most extreme, Lisp&#8217;s
minimal syntax means that a full interpreter written in Lisp can fit on one
page. Although most dynamically typed languages include as standard a
greater degree of syntax and control structures than Lisp, this general principle
remains.
<!--l. 355--><p class="indent" >   At the risk of stating the obvious, dynamically typed languages do not contain
constructs relating to static types. This is a significant form of simplification, as
although static typing is sometimes considered to be the simple &#8216;tagging&#8217; of variables
with a given type name, static typing has a much more pervasive effect on a
language. For example: static typing requires an (often significant) extension to a
language&#8217;s grammar to allow type &#8216;tags&#8217; to be expressed and requires concept(s)
allowing static types to be related to one another (e.g. the Java concept of
interface).
<!--l. 357--><p class="indent" >   The learning curve of dynamically typed languages is considerably shallower than
for most statically typed languages. For example, in many dynamically typed
languages the classic &#8216;hello world&#8217; program is simply <span 
class="cmtt-10">print "Hello world!" </span>or a
minor syntactic variant. In Java, at the other extreme, it requires a 7 line program &#8211;
in a file whose name must exactly match the class contained within it &#8211; using a
bewildering array of unfamiliar concepts. While programming beginners obviously
struggle with the complexity that a language like Java forces on every user, it is
widely known that programming professionals find it easier to learn new dynamically
typed languages&#x00A0;<span class="cite">[<a 
href="#Xousterhout__scripting_higher_level_programming_for_the_21st_century">Ous98</a>]</span>.

<!--l. 361--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.2   </span> <a 
 id="x1-310005.2"></a>High level features</h4>
<!--l. 365--><p class="noindent" >Dynamically typed languages pioneered what are often informally known
as &#8216;high level features&#8217;&#8212;those which abstract away from low-level machine
concerns.
   <h5 class="subsubsectionHead"><a 
 id="x1-320005.2"></a>Built-in Data types</h5>
<!--l. 370--><p class="noindent" >Whereas many statically typed languages provide only very simple built-in data
types &#8211; integers and user-defined structures &#8211; dynamically typed languages
typically provide a much richer set. The two universal data types are lists
(automatically resizing arrays) and strings (arbitrary character arrays); most
dynamically typed languages also provide support for dictionaries (also known as
associative arrays or hash tables; fast key / value lookup) and sets. These
data types are typically tightly integrated into the main language, often
with their own syntax, and used consistently and frequently throughout
libraries. In contrast, most statically typed languages defer most such data
types to libraries; consequently they are rarely as consistently or frequently
used.
<!--l. 372--><p class="indent" >   Complex data structures are often naturally expressed using just built-in data
types. For example, the following Converge code shows how dictionaries of sets
representing room numbers and employees are naturally represented:
   <div class="fancyvrb" id="fancyvrb6">
<a 
 id="x1-32002r1"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;x</span><span 
class="cmtt-9">&#x00A0;:=</span><span 
class="cmtt-9">&#x00A0;Dict{10</span><span 
class="cmtt-9">&#x00A0;:</span><span 
class="cmtt-9">&#x00A0;Set{"Fred","Sue"},</span><span 
class="cmtt-9">&#x00A0;17</span><span 
class="cmtt-9">&#x00A0;:</span><span 
class="cmtt-9">&#x00A0;Set{"Barry","George","Steve"},</span><span 
class="cmtt-9">&#x00A0;18</span><span 
class="cmtt-9">&#x00A0;:</span><span 
class="cmtt-9">&#x00A0;Set{"Mark"}}</span>
<br class="fancyvrb" /><a 
 id="x1-32004r2"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;x[10].add("Andy")</span>
<br class="fancyvrb" /><a 
 id="x1-32006r3"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;x[17].del("Steve")</span>
   </div>
<!--l. 378--><p class="noindent" >After the above has been evaluated the dictionary referenced by <span 
class="cmtt-10">x </span>looks as follows:
   <div class="fancyvrb" id="fancyvrb7">
<a 
 id="x1-32008r1"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;Dict{10</span><span 
class="cmtt-9">&#x00A0;:</span><span 
class="cmtt-9">&#x00A0;Set{"Fred",</span><span 
class="cmtt-9">&#x00A0;"Andy",</span><span 
class="cmtt-9">&#x00A0;"Sue"},</span><span 
class="cmtt-9">&#x00A0;17</span><span 
class="cmtt-9">&#x00A0;:</span><span 
class="cmtt-9">&#x00A0;Set{"Barry",</span><span 
class="cmtt-9">&#x00A0;"George"},</span><span 
class="cmtt-9">&#x00A0;18</span><span 
class="cmtt-9">&#x00A0;:</span><span 
class="cmtt-9">&#x00A0;Set{"Mark"}}</span>
   </div>
<!--l. 382--><p class="noindent" >Using built-in data types not only improves programmer productivity, but also execution
speed as built-in data types are highly optimised.
   <h5 class="subsubsectionHead"><a 
 id="x1-330005.2"></a>Automatic memory management</h5>
<!--l. 389--><p class="noindent" >Manual memory management &#8211; when the programmer must manually allocate and
free memory &#8211; wastes programmer resources (consuming perhaps around 30% &#8211; 40%
of a programmer&#8217;s time&#x00A0;<span class="cite">[<a 
href="#Xrovner__on_adding_garbage_collection_and_runtime_types_to_a_strongly_typed_statically_checked_concurrent_language">Rov85</a>]</span>) and is a significant source of bugs&#x00A0;<span class="cite">[<a 
href="#Xjones_lins__garbage_collection_algorithms_for_automatic_dynamic_memory_management">JL99</a>]</span>. Lisp was
the first programming language to introduce the concept of garbage collection,
meaning that memory is automatically allocated and freed by the language run-time,

largely removing this burden from the programmer. Virtually all dynamically typed
languages (and, more recently, most statically typed languages) have followed this
lead.
<!--l. 393--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.3   </span> <a 
 id="x1-340005.3"></a>Meta-programming</h4>
<!--l. 397--><p class="noindent" >Meta-programming is the querying, manipulation, or creation of one program by
another; often a program will perform such actions upon itself. Meta-programming
can occur at either, or both of, compile-time or run-time. Dynamically typed
languages have extensive meta-programming abilities.
   <h5 class="subsubsectionHead"><a 
 id="x1-350005.3"></a>Reflection</h5>
<!--l. 402--><p class="noindent" >Formally, reflection can be split into three main aspects&#x00A0;<span class="cite">[<a 
href="#Xbracha_ungra__mirrors_design_principles_for_meta_level_facilities_of_object_oriented_programming_languages">BU04</a>,&#x00A0;<a 
href="#Xmostinckx_van_cutsem_timbermont_tanter__mirror_based_reflection_in_ambienttalk">MvCT<sup><span 
class="cmr-7">+</span></sup>08</a>]</span>:
<!--l. 404--><p class="indent" >
   <dl class="description"><dt class="description">
<span 
class="cmbx-10">Introspection:</span> </dt><dd 
class="description">the ability of a program to examine itself.
   </dd><dt class="description">
<span 
class="cmbx-10">Self-modification:</span> </dt><dd 
class="description">the ability of a program to alter its structure.
   </dd><dt class="description">
<span 
class="cmbx-10">Intercession:</span> </dt><dd 
class="description">the ability of a program to alter its behaviour.</dd></dl>
<!--l. 410--><p class="noindent" >For the purposes of this chapter, reflection is considered to be a run-time ability. For
example in Smalltalk, programs can perform deep introspection on objects at
run-time to determine their types (see Section&#x00A0;<a 
href="#x1-240004.2">4.2<!--tex4ht:ref: smalltalk --></a>). In the following Smalltalk
examples &#8216;<span 
class="cmsy-10">&#x2192;</span>&#8217; means &#8216;evaluates to&#8217;:
   <div class="tabular"> <table id="TBL-2" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-2-1g"><col 
id="TBL-2-1"></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-2-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-1-1"  
class="td11"><span 
class="cmtt-10">2 + 2 </span><span 
class="cmsy-10">&#x2192; </span><span 
class="cmti-10">4                                         </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-2-1"  
class="td11"><span 
class="cmtt-10">(2 + 2) class </span><span 
class="cmsy-10">&#x2192; </span><span 
class="cmti-10">SmallInteger                </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-3-1"  
class="td11"><span 
class="cmtt-10">(2 + 2) class class </span><span 
class="cmsy-10">&#x2192; </span><span 
class="cmti-10">SmallInteger class </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-2-4-1"  
class="td11"><span 
class="cmtt-10">(2 + 2) class class class </span><span 
class="cmsy-10">&#x2192; </span><span 
class="cmti-10">Metaclass  </span></td> </tr></table></div>
<!--l. 421--><p class="noindent" >Self-modification allows behaviour to be added, removed, or changed at run-time.
For example in Smalltalk if a variable <span 
class="cmtt-10">ie </span>references an appropriate method
(the definition of which is left to the reader), then it can be added to the
<span 
class="cmtt-10">Number </span>class, so that all numbers can easily test whether they are odd or
even:
   <div class="tabular"> <table id="TBL-3" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-3-1g"><col 
id="TBL-3-1"></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-3-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-1-1"  
class="td11"><span 
class="cmtt-10">3 isEven </span><span 
class="cmsy-10">&#x2192; </span><span 
class="cmti-10">Message not understood                                                          </span></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-2-1"  
class="td11"><span 
class="cmtt-10">Number addSelector:</span><span 
class="cmtt-10">&#x00A0;#isEven withMethod ie </span><span 
class="cmsy-10">&#x2192; </span><span 
class="cmti-10">Adds method </span><span 
class="cmitt-10">isEven </span><span 
class="cmti-10">to </span><span 
class="cmitt-10">Number </span></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-3-3-1"  
class="td11"><span 
class="cmtt-10">3 isEven </span><span 
class="cmsy-10">&#x2192; </span><span 
class="cmti-10">false</span></td> 
</tr></table></div>
<!--l. 431--><p class="noindent" >Unfettered run-time modification of a system is dangerous, since it can have subtle,
unintended consequences. However careful use of reflection allows programmers to
bend a language to their particular circumstances rather than the other way round.
Most dynamically typed languages are capable of introspection; many are capable of
self-modification; relatively few are capable of intercession (Smalltalk being one

of the few). While a few statically typed languages such as Java support
the introspective aspects of reflection, few are as consistently reflective as
Smalltalk and its descendants, and none allow the level of manipulation as shown
above.
<!--l. 435--><p class="indent" >   Some OO languages have a meta-object protocol (MOP)&#x00A0;<span class="cite">[<a 
href="#Xkiczales_des_rivieres_bobrow__the_art_of_the_metaobject_protocol">KdRB91</a>]</span> which allows
intercession, as objects can alter the way they respond to message sends. For example
in Python objects can override the <span 
class="cmtt-10">_</span><span 
class="cmtt-10">_getattribute</span><span 
class="cmtt-10">_</span><span 
class="cmtt-10">_ </span>function which receives a
message <span 
class="cmtt-10">name </span>and returns an object of its choosing. The following example code
(although too simple for production use) shows how Python objects can be made
to appear to automatically have automatic &#8216;getter&#8217; methods if they don&#8217;t
exist:
   <div class="fancyvrb" id="fancyvrb8">
<a 
 id="x1-35002r1"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;class</span><span 
class="cmtt-9">&#x00A0;C(object):</span>
<br class="fancyvrb" /><a 
 id="x1-35004r2"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;x</span><span 
class="cmtt-9">&#x00A0;=</span><span 
class="cmtt-9">&#x00A0;2</span>
<br class="fancyvrb" /><a 
 id="x1-35006r3"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;def</span><span 
class="cmtt-9">&#x00A0;__getattribute__(self,</span><span 
class="cmtt-9">&#x00A0;name):</span>
<br class="fancyvrb" /><a 
 id="x1-35008r4"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;if</span><span 
class="cmtt-9">&#x00A0;name.startswith("get_"):</span>
<br class="fancyvrb" /><a 
 id="x1-35010r5"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;v</span><span 
class="cmtt-9">&#x00A0;=</span><span 
class="cmtt-9">&#x00A0;object.__getattribute__(self,</span><span 
class="cmtt-9">&#x00A0;name[4</span><span 
class="cmtt-9">&#x00A0;:</span><span 
class="cmtt-9">&#x00A0;])</span>
<br class="fancyvrb" /><a 
 id="x1-35012r6"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;return</span><span 
class="cmtt-9">&#x00A0;lambda</span><span 
class="cmtt-9">&#x00A0;:</span><span 
class="cmtt-9">&#x00A0;v</span>
<br class="fancyvrb" /><a 
 id="x1-35014r7"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;else:</span>
<br class="fancyvrb" /><a 
 id="x1-35016r8"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;return</span><span 
class="cmtt-9">&#x00A0;object.__getattribute__(self,</span><span 
class="cmtt-9">&#x00A0;name)</span>
<br class="fancyvrb" /><a 
 id="x1-35018r9"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span>
<br class="fancyvrb" /><a 
 id="x1-35020r10"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;i</span><span 
class="cmtt-9">&#x00A0;=</span><span 
class="cmtt-9">&#x00A0;C()</span>
<br class="fancyvrb" /><a 
 id="x1-35022r11"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;print</span><span 
class="cmtt-9">&#x00A0;i.x</span>
<br class="fancyvrb" /><a 
 id="x1-35024r12"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;print</span><span 
class="cmtt-9">&#x00A0;i.get_x()</span>
   </div>
<!--l. 450--><p class="noindent" >In this example, both <span 
class="cmtt-10">i.x </span>and <span 
class="cmtt-10">i.get</span><span 
class="cmtt-10">_x() </span>evaluate to the same result. Similar tricks can
be played with the setting and querying of object slots. While delving into the MOP
can easily introduce complications such as infinite loops, it can be useful, as in this
example, to allow one object to emulate the behaviour of another, allowing otherwise
incompatible frameworks and libraries to interact. Reflection also allows much deeper
changes to a system such as allowing run-time modification of whole program
aspects&#x00A0;<span class="cite">[<a 
href="#Xdynamic_adaptation_of_application_aspects__ortin_cueva">OC04</a>]</span>.
   <h5 class="subsubsectionHead"><a 
 id="x1-360005.3"></a>Compile-time meta-programming</h5>
<!--l. 458--><p class="noindent" >Compile-time meta-programming allows the user to interact with the compiler to
allow the construction of arbitrary program fragments. Lisp&#8217;s macros are the
traditional form of compile-time meta-programming and are used extensively to
extend the minimal base language. For example the <span 
class="cmtt-10">when </span>control structure is a
specialised form of <span 
class="cmtt-10">if</span>, taking a condition and a list of expressions; if the condition
holds, <span 
class="cmtt-10">when </span>evaluates all expressions, returning the result of the final expression. In
Common Lisp&#x00A0;<span class="cite">[<a 
href="#Xsteel90clos">Ste90</a>]</span> (alongside Emacs Lisp, one of the major extant Lisp
implementations) <span 
class="cmtt-10">when </span>can be implemented as follows:
   <div class="fancyvrb" id="fancyvrb9">
<a 
 id="x1-36002r1"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;(defmacro</span><span 
class="cmtt-9">&#x00A0;when</span><span 
class="cmtt-9">&#x00A0;(cond</span><span 
class="cmtt-9">&#x00A0;&amp;rest</span><span 
class="cmtt-9">&#x00A0;body)</span>
<br class="fancyvrb" /><a 
 id="x1-36004r2"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;&#8216;(if</span><span 
class="cmtt-9">&#x00A0;~cond</span><span 
class="cmtt-9">&#x00A0;(progn</span><span 
class="cmtt-9">&#x00A0;~@body)))</span>
   </div>

<!--l. 463--><p class="noindent" >Whenever a &#8216;function call&#8217; to <span 
class="cmtt-10">when </span>is encountered during compilation, the above
macro is executed and the resultant generated code statically replaces the
&#8216;function call&#8217;. The two major features in the above are the quote <span 
class="cmtt-10">&#8216; </span>which in
essence returns the quoted expression as an Abstract Syntax Tree (AST) (i.e.
without evaluating it) and the insertion <span 
class="cmtt-10">~ </span>which inserts one Lisp AST in
another.
<!--l. 465--><p class="indent" >   Because macros in Lisp are often considered to rely on some of Lisp&#8217;s defining
features &#8211; in particular its minimal syntax which means that Lisp ASTs are
simply lists of lists &#8211; subsequent dynamically typed languages did not have
an equivalent system. In a rare occurrence, the statically typed languages
MetaML&#x00A0;<span class="cite">[<a 
href="#Xsheard__using_metaml_a_staged_programming_language">She98</a>]</span> and then Template Haskell&#x00A0;<span class="cite">[<a 
href="#Xsheard_peyton_jones__template_meta_programming_for_haskell">SJ02</a>]</span> showed how a practical
compile-time meta-programming system could be naturally integrated into a modern
syntactically rich language. Compile-time meta-programming is slightly more generic
in concept than traditional macros, as it allows users to interact with the compiler,
where such interactions may not always lead to the generation of code. Converge
(created by this chapters author) integrates a Template Haskell-like system into a
dynamically typed language, and uses it to implement a syntax extension
feature which allows syntactically distinct DSLs to be embedded into normal
programs.
   <h5 class="subsubsectionHead"><a 
 id="x1-370005.3"></a>Eval</h5>
<!--l. 473--><p class="noindent" >Colloquially referred to by its short name, &#8216;eval&#8217; refers to the ability, almost wholly
confined to dynamically typed languages, to evaluate arbitrary code expressions as
strings at run-time. In other words, code fragments can be received from, for
example, end users, evaluated and the resulting value used for arbitrary
purposes. Note that eval is very different from compile-time meta-programming,
since expressions are evaluated at run-time, not compile-time, and any value
can be returned (not just ASTs). While eval has many obvious downsides
&#8211; allowing arbitrary code to be executed at run-time has severe security
implications &#8211; when used carefully (e.g. in configuration files) it can reduce the
need for arbitrary mini-programming languages to be implemented within a
system.
   <h5 class="subsubsectionHead"><a 
 id="x1-380005.3"></a>Continuations</h5>
<!--l. 479--><p class="noindent" >Popularised in Scheme, continuations remain a relatively exotic construct, with
support only found in a handful of other languages, noticeably including Smalltalk.
At a high-level, they can be thought of as a generalised form of co-routine&#x00A0;<span class="cite">[<a 
href="#Xhaynes_friedman_wand__continuations_and_coroutines">HFW84</a>]</span>
which allows a safe way of defining &#8216;goto&#8216; points, capturing a certain part of the
current program state and allowing that part to be suspended and later resumed.
Continuations are sufficiently powerful that all other control structures can be defined
in terms of them.
<!--l. 481--><p class="indent" >   The low-level power of continuations, and the fact that they subvert normal
expectations of control flow, has meant that they have been talked about

rather more than they have been used. However they have recently shown to
be a natural match for web programming, where the back button in web
browsers causes huge problems because it is effectively an &#8216;undo&#8217;; most web
systems give unpredictable and confusing results if the back button is used
frequently. Continuations can naturally model the chain of resumption points that
represent each point in the users browsing history, as can be seen in the
Smalltalk Seaside framework&#x00A0;<span class="cite">[<a 
href="#Xducasse_lienhard_renggli__seaside_a_flexible_environment_for_building_dynamic_web_applications">DLR07</a>]</span>. This means that web systems respect
users intuition when the back button is used, but are not unduly difficult to
develop.
<!--l. 485--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.4   </span> <a 
 id="x1-390005.4"></a>Refactoring</h4>
<!--l. 487--><p class="noindent" >Refactoring is the act of applying small, behaviour-preserving transformations,
to a system&#x00A0;<span class="cite">[<a 
href="#Xfowler_beck_brant_opdyke_roberts__refactoring_improving_the_design_of_existing_code">FBB<sup><span 
class="cmr-7">+</span></sup>99</a>]</span>. The general aim of refactoring is to maintain, or
restore, the internal quality of a system after a series of changes so that further
changes to the system are practical. A key part of the refactoring definition
&#8216;behaviour-preserving&#8217;: it is vital that refactorings do not introduce new
errors into a system. In practice, two distinct types of refactorings can be
identified:
   <ol  class="enumerate1" >
   <li 
  class="enumerate" id="x1-39002x1">Small, tightly defined, and automatable refactorings. Exemplified by the
   &#8216;move method&#8217; refactoring where a method is moved from class <span 
class="cmtt-10">C </span>to <span 
class="cmtt-10">D</span>.
   </li>
   <li 
  class="enumerate" id="x1-39004x2">Larger, typically project specific, non-automatable refactorings. A typical
   example is splitting a module or class into two to separate out functionality.</li></ol>
<!--l. 495--><p class="noindent" >Statically typed languages have an inherent advantage over dynamically typed languages
in the first type of refactoring because of the extra information encoded in static
types. However static types are a burden in the second type of refactoring because
they always require the entire system to be type correct. This means that it is not
possible to make, and test, small local changes to a sub-system when such
changes temporarily violate the type system; instead the entire refactoring must
be implemented in one fell swoop which means that any resulting errors
are difficult to relate to an individual action. Counter-intuitively, perhaps,
static types inhibit large-scale refactorings, tending to ossify a program&#8217;s
structure (see Section&#x00A0;<a 
href="#x1-190003.4">3.4<!--tex4ht:ref: system scelrosis --></a>). The flexibility of dynamically typed languages on the
other hand encourages continual changes to a system&#x00A0;<span class="cite">[<a 
href="#Xnierstrasz_bergel_denker_ducasse_galli_wuyts__on_the_revival_of_dynamic_languages">NBD<sup><span 
class="cmr-7">+</span></sup>05</a>]</span>, though it is
often wise to pair it with a suitable test suite to prevent regressions (see
Section&#x00A0;<a 
href="#x1-480006.2">6.2<!--tex4ht:ref: unit tests --></a>).
<!--l. 499--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.5   </span> <a 
 id="x1-400005.5"></a>&#8216;Batteries included&#8217; libraries</h4>

<!--l. 501--><p class="noindent" >Traditionally, many statically typed languages &#8211; from Algol to Ada &#8211; have been
designed as paper standards, detailing their syntax and semantics, but typically
agnostic as to libraries. Such languages are then implemented by multiple
vendors, each of which is likely to provide different libraries. In contrast, most
dynamically typed languages &#8211; with the notable exception of the Lisp family
&#8211; have been defined by their initial implementation and its accompanying
libraries. The majority of modern dynamically typed languages (see Section&#x00A0;<a 
href="#x1-280004.6">4.6<!--tex4ht:ref: modern scripting languages --></a>)
come with a rich set of standard libraries &#8211; the so-called &#8216;batteries included&#8217;
approach<span class="footnote-mark"><a 
href="aic20086.html#fn5x0"><sup class="textsuperscript">5</sup></a></span><a 
 id="x1-40001f5"></a>&#x00A0;<span class="cite">[<a 
href="#Xolihpant__python_for_scientific_computing">Oli07</a>]</span>
&#8211; which encompass enough functionality to be suitable for a majority of
common programming tasks. Implicit in this is the assumption that if the
initial implementation is replaced, the standard library will be provided in a
backwards-compatible fashion; in comparison to paper-based standards, it is often
difficult to distinguish between the language and its libraries. Furthermore, due to the
emphasis on a rich set of standard libraries, it is relatively easy to define
new, external libraries without requiring the installation of many dependent
libraries.
<!--l. 503--><p class="indent" >   As described in Section&#x00A0;<a 
href="#x1-470006.1">6.1<!--tex4ht:ref: performance --></a>, the performance of dynamically typed languages
varies from slightly to significantly slower than statically typed languages; however,
suitable use of libraries (which are typically highly optimised) can often significantly
diminish performance issues.
   <h4 class="subsectionHead"><span class="titlemark">5.6   </span> <a 
 id="x1-410005.6"></a>Portability</h4>
<!--l. 509--><p class="noindent" >Portable software is that which runs on multiple target platforms. For the purposes of this
chapter, a platform can be considered to be a combination of hardware and operating
system<span class="footnote-mark"><a 
href="aic20087.html#fn6x0"><sup class="textsuperscript">6</sup></a></span><a 
 id="x1-41001f6"></a>.
For most non-specialised purposes, users wish their software to run on as many
platforms as practical.
<!--l. 511--><p class="indent" >   One way of achieving portability is to allow programs to deal, on an
as-needs basis, with known variations in the underlying platform; the other is to
provide abstractions which abstract away from the hardware and the operating
system&#x00A0;<span class="cite">[<a 
href="#Xspencer_collyer__ifdef_considered_harmful_or_portability_experience_with_cnews">SC92</a>]</span>. Since dynamically typed languages aim to present a higher-level view
of the world to programs (see e.g. Section&#x00A0;<a 
href="#x1-310005.2">5.2<!--tex4ht:ref: high-level features --></a>), they follow this latter philosophy.
There are many examples of such abstractions, but two in particular show the
importance of abstracting away from the hardware and the operating system. First,
&#8216;primitive types&#8217; such as integers will typically automatically change their

representation from an efficient but limited machine type to a variably sized container
as necessary, thus preventing unintended overflow errors. Second, file libraries provide
simple <span 
class="cmtt-10">open </span>and <span 
class="cmtt-10">read </span>calls (note that garbage collection typically closes files
automatically in dynamically typed languages, so explicit calls to <span 
class="cmtt-10">close </span>are
less important) which abstract away from the wide variety of file processing
calls found in different operating systems. By providing such abstractions,
dynamically typed programs are typically more portable than most statically typed
languages because there is less direct reliance on features of the underlying
platform.
   <h4 class="subsectionHead"><span class="titlemark">5.7   </span> <a 
 id="x1-420005.7"></a>Unanticipated reuse</h4>
<!--l. 517--><p class="noindent" >A powerful type of reuse is when functionality is composed from smaller units in ways
that are reasonable and valid, but not anticipated by the authors of each sub-unit.
Ousterhout shows how, by using untyped text as its medium and lazy evaluation as
its process, the UNIX shell can chain together arbitrary commands with
pipes&#x00A0;<span class="cite">[<a 
href="#Xousterhout__scripting_higher_level_programming_for_the_21st_century">Ous98</a>]</span>. For example the following command counts how many lines the word
&#8216;dynamic&#8217; occurs in <span 
class="cmtt-10">.c </span>files:
   <div class="fancyvrb" id="fancyvrb10">
<a 
 id="x1-42002r1"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;find</span><span 
class="cmtt-9">&#x00A0;.</span><span 
class="cmtt-9">&#x00A0;-name</span><span 
class="cmtt-9">&#x00A0;"*.c"</span><span 
class="cmtt-9">&#x00A0;|</span><span 
class="cmtt-9">&#x00A0;grep</span><span 
class="cmtt-9">&#x00A0;-i</span><span 
class="cmtt-9">&#x00A0;dynamic</span><span 
class="cmtt-9">&#x00A0;|</span><span 
class="cmtt-9">&#x00A0;wc</span><span 
class="cmtt-9">&#x00A0;-l</span>
   </div>
<!--l. 521--><p class="noindent" >The enabling factor in such reuse is the loose contracts placed on input and output data:
if the UNIX shell, for example, forced data passed through pipes to be statically
typed it is unlikely that such powerful chains of commands could be created as
commands would not be as easily reusable.
<!--l. 523--><p class="indent" >   Dynamically typed languages allow similar reuse to the UNIX shell, but with a
subtle twist. While most Unix shell commands demand nothing of input text (which
may be empty, all on one line etc.), and statically typed languages demand the
complete typing of all inputs, dynamically typed languages allow shades of grey
in-between. Essentially the idea is that functions should demand (and, possibly,
check) the minimum of any inputs to ensure correct functionality, thus allowing
functions to operate correctly on a wide range of seemingly unrelated input. This
philosophy, while long-standing, has recently acquired the name <span 
class="cmti-10">duck typing </span>to reflect
the intuitive notion that if an input &#8216;talks like a duck and quacks like a duck, it is a
duck&#8217;&#8212;even if other aspects of the input may not look like a duck&#x00A0;<span class="cite">[<a 
href="#Xkoenig_moo__templates_and_duck_typing">KM05</a>]</span>. Duck
typing can be seen as the run-time, dynamically typed equivalent of structural
typing (see Section&#x00A0;<a 
href="#x1-70002.3">2.3<!--tex4ht:ref: structural typing --></a>). A good example of the virtues of duck typing can be
found in Python where functions that deal with files often expect only a
simple <span 
class="cmtt-10">read </span>method in any input objects; this allows programs to make many
non-file objects (e.g. network streams) appear as files, thus reducing the
number of cases where specialised functions must be created for different
types.

<!--l. 527--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.8   </span> <a 
 id="x1-430005.8"></a>Interactivity</h4>
<!--l. 529--><p class="noindent" >Virtually all dynamically typed languages are interactive, in the sense that users can
execute commands on a running instance of the system and, if desired, perform
further interactive computations on the result. Arguably the most powerful
interactive systems are for Smalltalk, where systems are generally developed within
an interactive GUI system containing both system tools (the compiler etc.) and the
users code&#x00A0;<span class="cite">[<a 
href="#Xgoldberg_robson__smalltalk_80_the_language">GR89</a>]</span>. Most languages however provide such interactivity via a
command-line interface which allows normal expressions to be entered and
immediately evaluated. This allows the run-time system presented by the language to
be explored and understood. For example the following session shows how the
Python shell can be used to explore the type system and find out help on a
method:
   <div class="fancyvrb" id="fancyvrb11">
<a 
 id="x1-43002r1"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;&#x003E;&#x003E;&#x003E;</span><span 
class="cmtt-9">&#x00A0;True.__class__</span>
<br class="fancyvrb" /><a 
 id="x1-43004r2"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;&#x003C;type</span><span 
class="cmtt-9">&#x00A0;&#8217;bool&#8217;&#x003E;</span>
<br class="fancyvrb" /><a 
 id="x1-43006r3"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;&#x003E;&#x003E;&#x003E;</span><span 
class="cmtt-9">&#x00A0;True.__class__.__class__</span>
<br class="fancyvrb" /><a 
 id="x1-43008r4"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;&#x003C;type</span><span 
class="cmtt-9">&#x00A0;&#8217;type&#8217;&#x003E;</span>
<br class="fancyvrb" /><a 
 id="x1-43010r5"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;&#x003E;&#x003E;&#x003E;</span><span 
class="cmtt-9">&#x00A0;dir(True.__class__.__class__)</span>
<br class="fancyvrb" /><a 
 id="x1-43012r6"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;[&#8217;__base__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__bases__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__basicsize__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__call__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__class__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__cmp__&#8217;,</span>
<br class="fancyvrb" /><a 
 id="x1-43014r7"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;&#8217;__delattr__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__dict__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__dictoffset__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__doc__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__flags__&#8217;,</span>
<br class="fancyvrb" /><a 
 id="x1-43016r8"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;&#8217;__getattribute__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__hash__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__init__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__itemsize__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__module__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__mro__&#8217;,</span>
<br class="fancyvrb" /><a 
 id="x1-43018r9"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;&#8217;__name__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__new__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__reduce__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__reduce_ex__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__repr__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__setattr__&#8217;,</span>
<br class="fancyvrb" /><a 
 id="x1-43020r10"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;&#8217;__str__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__subclasses__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;__weakrefoffset__&#8217;,</span><span 
class="cmtt-9">&#x00A0;&#8217;mro&#8217;]</span>
<br class="fancyvrb" /><a 
 id="x1-43022r11"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;&#x003E;&#x003E;&#x003E;</span><span 
class="cmtt-9">&#x00A0;help(True.__class__.__class__.mro)</span>
<br class="fancyvrb" /><a 
 id="x1-43024r12"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;mro(...)</span>
<br class="fancyvrb" /><a 
 id="x1-43026r13"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;mro()</span><span 
class="cmtt-9">&#x00A0;-&#x003E;</span><span 
class="cmtt-9">&#x00A0;list</span>
<br class="fancyvrb" /><a 
 id="x1-43028r14"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;return</span><span 
class="cmtt-9">&#x00A0;a</span><span 
class="cmtt-9">&#x00A0;type&#8217;s</span><span 
class="cmtt-9">&#x00A0;method</span><span 
class="cmtt-9">&#x00A0;resolution</span><span 
class="cmtt-9">&#x00A0;order</span>
<br class="fancyvrb" /><a 
 id="x1-43030r15"></a><span 
class="cmtt-9">&#x00A0;</span><span 
class="cmtt-9">&#x00A0;&#x003E;&#x003E;&#x003E;</span>
   </div>
<!--l. 547--><p class="noindent" >By providing an interactive interface, dynamically typed languages encourage exploration
of the run-time system, and also allow small examples to be worked on without any
&#8216;compile link&#8217; overhead.
<!--l. 551--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.9   </span> <a 
 id="x1-440005.9"></a>Compile-link-run cycle</h4>
<!--l. 553--><p class="noindent" >In the majority of programming languages &#8211; with the notable exception of Smalltalk
and languages directly influenced by it such as Self (see Section&#x00A0;<a 
href="#x1-430005.8">5.8<!--tex4ht:ref: smalltalk interactivity --></a>) &#8211; programs are
stored in one or more files. In order to run a program in a statically typed
language, one must typically compile each individual file of the program, and link
them together to produce a binary, which can then be run. This process is
know as the &#8216;compile-link-run&#8217; cycle. Because statically typed languages are
relatively complex to compile and link, this is often a lengthy process&#8212;even
on modern machines, large applications can take several hours to compile
and link from scratch. This is often a limiting factor in rapid application
development&#x00A0;<span class="cite">[<a 
href="#Xtratt_wuyts__dynamically_typed_languages">TW07</a>]</span>.

<!--l. 555--><p class="indent" >   In contrast, most dynamically typed languages conflate the compile-link-run cycle,
allowing source files to be directly &#8216;run&#8217;. As compilation of individual modules is
often done on an &#8216;as needs&#8217; basis, and since the compilation and linking of
dynamically typed languages is much simpler since no static types need to be
checked, this means the user experiences a much shorter compile-link-run
cycle.
<!--l. 559--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.10   </span> <a 
 id="x1-450005.10"></a>Run-time updates</h4>
<!--l. 561--><p class="noindent" >With the increasing trend of software providing long-running services (e.g. switches,
financial applications), it is necessary to upgrade software without stopping
it&#x00A0;<span class="cite">[<a 
href="#Xhicks_nettles__dynamic_software_updating">HN05</a>]</span>. This means replacing or augmenting values in the run-time system,
typically with data and functionality in the &#8216;old&#8217; system existing side-by-side with the
&#8216;new&#8217;.
<!--l. 563--><p class="indent" >   While it is possible to perform limited run-time updates with statically typed
languages, the general requirement to retain the type safety of the running system
(without which random low-level crashes are likely), and the difficulty of migrating
data, makes this extremely challenging in such languages (see Section&#x00A0;<a 
href="#x1-200003.5">3.5<!--tex4ht:ref: run-time dynamicity --></a>).
Dynamically typed languages have two significant advantages in such situations. First
reflection allows arbitrary manipulation and emulation of data. Second there is no
absolute requirement to maintain type safety in the updated system as, at worse, any
type errors resulting from updating data or functionality will result in a
standard run-time type error (in contrast, subverting the type system of
a statically typed language is likely to lead to a low-level crash). Erlang
makes heavy use of these features to allow extensive run-time updating in a
way that allows resultant systems to keep running for very long periods of
time&#x00A0;<span class="cite">[<a 
href="#Xvirding_wikstrom_williams_armstrong__concurrent_programming_in_erlang">VWWA96</a>]</span>.
<!--l. 567--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">6   </span> <a 
 id="x1-460006"></a>Disadvantages of dynamic typing</h3>
<!--l. 569--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">6.1   </span> <a 
 id="x1-470006.1"></a>Performance</h4>
<!--l. 573--><p class="noindent" >Much has been said and written about the relative performance of various
programming languages over the years; regrettably, much has been based on
superstition, supposition, or unrepresentatively small examples. There is little doubt
that, in practice, equivalent programs in dynamically typed languages are slower than
in statically typed languages. While on certain macro benchmarks some language
implementations (typically Lisp or Smalltalk implementations) can achieve
approximate parity with statically typed languages, a general rule of thumb is
that the most finely tuned dynamically typed language implementations

are approximately two times slower than the equivalent statically typed
implementation<span class="footnote-mark"><a 
href="aic20088.html#fn7x0"><sup class="textsuperscript">7</sup></a></span><a 
 id="x1-47001f7"></a>.
<!--l. 575--><p class="indent" >   The performance gap between dynamically typed and statically typed languages
has lowered over recent years, in large part due to innovations surrounding JIT
compilation&#x00A0;<span class="cite">[<a 
href="#Xaycock__a_brief_history_of_just_in_time">Ayc03</a>]</span>&#8212;the difference in speed between dynamically typed language
implementations with and without JIT compilation is typically a factor of three to
five. Currently the performance between different dynamically typed language
implementations varies wildly, with languages such as Ruby an order of magnitude
slower than leading Lisp&#8217;s. As there are few technical reasons for such differences, and
given recent trends such as common virtual machines and the awareness of the
benefits of JIT compilation, it is likely that the performance gap between
implementations will narrow considerably.
<!--l. 577--><p class="indent" >   Arguably more important than absolute performance measured in minutes
and seconds is the performance relative to requirements: in other words,
does the program &#8216;run fast enough?&#8217; Thanks in part to the advancements of
commodity computers, for most real-world purposes, this question is often
redundant. For certain tasks, particularly very low-level tasks, or those on
low-performance computers such as some embedded systems, statically typed
languages retain an important advantage. However it is interesting to note that in
certain data-intensive and performance sensitive domains such as scientific
computing dynamically typed languages have proved to be very successful (see
e.g.&#x00A0;<span class="cite">[<a 
href="#Xcai_langtangen_moe__on_the_performance_of_the_python_programming_language_for_serial_and_parallel_scientific_computations">CLM05</a>,&#x00A0;<a 
href="#Xolihpant__python_for_scientific_computing">Oli07</a>]</span>). There are two explanations for this. First, the high-level nature
of dynamically typed languages allows programmers to focus on improving algorithms
rather than low-level coding tricks. Second, dynamically typed languages
typically come with extensive, highly optimised libraries to which the most
performance critical work is often deferred (the so-called &#8216;batteries included&#8217;
approach&#x00A0;<span class="cite">[<a 
href="#Xolihpant__python_for_scientific_computing">Oli07</a>]</span>).
   <h4 class="subsectionHead"><span class="titlemark">6.2   </span> <a 
 id="x1-480006.2"></a>Debugging</h4>
<!--l. 583--><p class="noindent" >A fundamental difference between statically and dynamically typed languages is that
the former can detect and prevent certain errors at compile-time (see Section&#x00A0;<a 
href="#x1-50002.3">2.3<!--tex4ht:ref: static typing --></a>).
Logically this implies that dynamically typed programs are inherently more
error-prone than statically typed languages. This is potentially a real problem, hence
why it is included in the &#8216;disadvantages&#8217; section. However in practice, run-time type
errors in deployed programs are exceedingly rare&#x00A0;<span class="cite">[<a 
href="#Xtratt_wuyts__dynamically_typed_languages">TW07</a>]</span>.
<!--l. 587--><p class="indent" >   There are three main reasons why run-time type errors are rarely an issue. First,
type errors represent a small, generally immediately obvious, trivially fixed class of
errors and are thus typically detected and fixed quickly during development. Second
&#8211; as shown in Section&#x00A0;<a 
href="#x1-120003">3<!--tex4ht:ref: disadvantages of static typing --></a> &#8211; static types do not capture many of the more

important and subtle errors that one might hoped would have been detected;
such errors thus occur with equal frequency in statically and dynamically
typed programs. Third, automated testing will tend to detect most type
errors. This last point is particularly interesting. Unit testing is when a test
suite is created that can, without user intervention, be used to check that a
system conforms to the tests. Unit tests are often called &#8216;regression suites&#8217;
to emphasise that they are intended to prevent errors creeping back into a
system. The first unit test suite was for Smalltalk&#x00A0;<span class="cite">[<a 
href="#Xbeck__simple_smalltalk_testing_with_patterns">Bec94</a>]</span>, but virtually
all languages now have an equivalent library or facility e.g. Java&#x00A0;<span class="cite">[<a 
href="#Xlink_froehlich__unit_testing_in_java_how_tests_drive_the_code">LF03</a>]</span>.
As this suggests, unit testing allows developers to make guarantees of their
programs that are considerably in excess of anything that static typing can
provide.
<!--l. 591--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">6.3   </span> <a 
 id="x1-490006.3"></a>Code completion</h4>
<!--l. 593--><p class="noindent" >Many modern developers make use of sophisticated Integrated Development
Environments (IDEs) to edit programs. One feature associated with such tools is code
completion. In particular when a variable of type <span 
class="cmtt-10">T </span>is used in a slot lookup, the
functions and attributes of the type are automatically displayed. This feature makes
use of static types to ensure that (modulo any use of reflection) its answers are fully
accurate. A fully equivalent feature is not possible for dynamically typed languages
since it is not possible to accurately determine the static type of an arbitrary
expression.
<!--l. 597--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">6.4   </span> <a 
 id="x1-500006.4"></a>Types as documentation</h4>
<!--l. 601--><p class="noindent" >Since most statically typed languages force users to explicitly state the types that
functions consume and return, statically typed programs have an implicit form of
documentation within them, which happens to be machine checkable&#x00A0;<span class="cite">[<a 
href="#Xbracha__pluggable_type_systems">Bra04</a>]</span>.
There is little doubt that this form of documentation is often useful and that
dynamically typed languages do not include it. However since it is possible to
informally notate the expected types of a function in comments, or associated
documentation strings processed by external tools, this is not a major disadvantage;
furthermore some dynamically typed languages include optional type systems (see
Section&#x00A0;<a 
href="#x1-530007.2">7.2<!--tex4ht:ref: optional types --></a>) that allow code to be annotated with type declarations when
desired.
<!--l. 605--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">7   </span> <a 
 id="x1-510007"></a>Variations</h3>
<!--l. 607--><p class="noindent" >In the majority of this chapter I have described a homogenised picture of dynamically
typed languages, emphasising the culturally common aspects of most languages.

Inevitably this smooths over some important differences and variations between
languages; this section details some of these.
<!--l. 610--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.1   </span> <a 
 id="x1-520007.1"></a>Non-OO and OO languages</h4>
<!--l. 612--><p class="noindent" >Dynamically typed languages come in both OO (e.g. Converge, Python) and non-OO
(e.g. Lisp) flavours. Unsurprisingly, older dynamically typed languages tend to be
non-OO, with languages of the past decade or more almost exclusively OO.
Interestingly, the transition between these two schools can be seen in languages such
as Python (and, to a lesser extent, Lua) which started as non-OO languages but
which were subsequently retro-fitted with sufficient OO features that their early
history is only rarely evident. The general principles are largely the same in both
cases, and in most of this chapter I have avoided taking an exclusively OO or non-OO
approach.
<!--l. 614--><p class="indent" >   OO does however introduce some new differentiating factors between statically
and dynamically typed languages. In particular, static typing allows OO languages to
introduce new ways of method dispatch (such as method overloading) due to
polymorphism. While meta-programming allows dynamically typed languages to
introduce analogous features, they are not tightly integrated into the language, or
frequently used. In part because of this, it is generally easier to move between
non-OO and OO programming styles in dynamically typed languages such as
Python than to attempt the same in a statically typed OO language such as
Java.
<!--l. 616--><p class="indent" >   It is notable that dynamically typed languages have played a major part in the
continued development of OO. For example, languages such as Self introduced the
notable concept of prototyping&#x00A0;<span class="cite">[<a 
href="#Xungar_smith__self_the_power_of_simplicity">US87</a>]</span>; Smalltalk has been used as the workbench for
innovations such as traits&#x00A0;<span class="cite">[<a 
href="#Xscharli_ducasse_nierstrasz_black__traits_composable_units_of_behaviour">SDNB03</a>]</span> which defines an alternative to inheritance for
composing functionality.
<!--l. 620--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.2   </span> <a 
 id="x1-530007.2"></a>Optional types</h4>
<!--l. 624--><p class="noindent" >In most of this chapter, dynamic and static typing have been talked about as if they
are mutually exclusive&#8212;and in most current languages this is true. While not
integrated into any mainstream language, there is a long history of work which aims
to utilise the benefits of both approaches&#x00A0;<span class="cite">[<a 
href="#Xmeijer_drayton__static_typing_when_possible_dynamic_typing_when_needed_the_end_of_the_cold_war_between_programming_languages">MD04</a>]</span> and blur this distinction. There are
three main ways of achieving this. First, one can add a &#8216;dynamic type&#8217; to a
statically typed language, meaning that most data is statically typed, with some
&#8216;dynamically typed&#8217; (see e.g.&#x00A0;<span class="cite">[<a 
href="#Xabadi_cardelli_pierce_plotkin__dynamic_typing_in_a_statically_typed_language">ACPP91</a>,&#x00A0;<a 
href="#Xhenglein__dynamic_typing_syntax_and_proof_theory">Hen94</a>]</span>). Second, and of greater interest to
this chapter, one can add an <span 
class="cmti-10">optional type </span>system to a dynamically typed
language.
<!--l. 626--><p class="indent" >   Intuitively, optional typing is easily defined: static types can be added at selected
points in a program, or discovered through type inference, and those types are
statically checked by a compiler. Optional typing thus means that portions a program

can be guaranteed not to have type errors. Exactly how much of a program needs to
be statically typed varies between approaches e.g. some proposal require whole
modules to be fully statically typed&#x00A0;<span class="cite">[<a 
href="#Xtobin_hochstadt_felleisen__the_design_and_implementation_of_typed_scheme">THF08</a>]</span> where others allow a free mixture of
dynamic and static typing&#x00A0;<span class="cite">[<a 
href="#Xsiek_vacharajani__gradual_typing_with_unification_based_inference">SV08</a>]</span>. Optional types have two further advantages: they
offer the possibility that extra optimisations can be used on statically typed
portions&#x00A0;<span class="cite">[<a 
href="#Xcartwright_fagan__soft_typing">CF91</a>]</span>; they also provide a machine-checkable form of documentation within
source code (see Section&#x00A0;<a 
href="#x1-500006.4">6.4<!--tex4ht:ref: types as documentation --></a>).
<!--l. 628--><p class="indent" >   Optional typing raises two particularly important questions:
   <ol  class="enumerate1" >
   <li 
  class="enumerate" id="x1-53002x1">Are  type  violations  fatal  errors  (as  they  are  in  fully  statically  typed
   languages), or merely informative warnings?
   </li>
   <li 
  class="enumerate" id="x1-53004x2">Should static typing effect the run-time semantics of the system?</li></ol>
<!--l. 636--><p class="noindent" >There is currently no agreement on either of these points. For example, as described
in Section&#x00A0;<a 
href="#x1-520007.1">7.1<!--tex4ht:ref: static typing allows polymorphism --></a> static typing in OO languages can affect method dispatch,
meaning that OO programs could perform method dispatch differently in
statically and dynamically typed portions. Because of this, one possibility
is to make optional types truly optional, in that their presence or absence
does not effect the run-time semantics of a program&#x00A0;<span class="cite">[<a 
href="#Xbracha__pluggable_type_systems">Bra04</a>]</span>. Taking this
route also raises the possibility of using different type systems within one
program.
<!--l. 638--><p class="indent" >   For the purposes of this chapter, optional typing is considered to subsume a
number of related concepts &#8211; including gradual typing, soft typing, and pluggable
typing. As this may suggest, optional typing in its various form is still relatively
immature and remains an active area of research.
<!--l. 642--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.3   </span> <a 
 id="x1-540007.3"></a>Analysis</h4>
<!--l. 644--><p class="noindent" >One approach to validating the correctness of a program is analysis. Static analysis
involves analysing the source code of a system for errors, and is capable of finding
various classes of errors, not just type errors. Static analysis is a well-established
technique in certain limited areas, such as safety critical systems, where developers
are prepared to constrain the systems they write in order to be assured of
correctness. Such a philosophy is at odds with that of dynamically typed
languages, which emphasise flexibility. Furthermore the inherent flexibility of
dynamically typed languages would lead to a huge increase in the search space.
Therefore static analysis is unlikely to be a practical approach for analysing
dynamically typed programs. Another approach to analysis is to perform
it at run-time &#8211; dynamic analysis &#8211; when virtual machines, libraries and
so on are augmented with extra checks which aim to detect many errors
at the earliest possible point, rather than waiting until a program crashes.
Although such tools are in their infancy some, such as the Dialyzer system
which performs such analysis for Erlang systems&#x00A0;<span class="cite">[<a 
href="#Xlindahl_sagonas__detecting_software_defects_in_telecom_applications_through_lightweight_static_analysis_a_war_story">LS04</a>]</span>, are in real-world
use.

<!--l. 648--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">8   </span> <a 
 id="x1-550008"></a>The future</h3>
<!--l. 650--><p class="noindent" >Definitively predicting the future of dynamically typed languages is impossible since
there is no central authority, or single technology, which defines such languages.
Nevertheless certain trends are currently evident. The increasing popularity of
dynamically typed languages mean a revived interest in performance issues; while
languages such as Self have shown that dynamically typed languages can have
efficient implementations, few current languages have adopted such techniques. As
dynamically typed languages continue to be used in the real-world, increasingly for
larger systems, users are likely to demand better performance. Experimentation in
optional typing is likely to continue, with optional type systems eventually seeing real
use in mainstream languages. The cross-fertilisation of ideas between statically and
dynamically typed languages will continue, with language features such as
compile-time meta-programming crossing both ways across the divide. It is also likely
that we will see an increase in the number of dynamically typed domain specific
languages, since such languages tend by nature to be small and &#8216;lightweight&#8217; in
feel.
<!--l. 654--><p class="noindent" >
   <h3 class="sectionHead"><span class="titlemark">9   </span> <a 
 id="x1-560009"></a>Conclusions</h3>
<!--l. 656--><p class="noindent" >In this chapter I detailed the general philosophy, history, and defining features of
dynamically typed languages. I showed that, while a broad banner, such languages
share much in common. Furthermore I have highlighted their contribution to the
development of programming languages in general and, I hope, a sense of why they
are currently enjoying such a resurgence.
<!--l. 658--><p class="indent" >   I am grateful to ric Tanter who provided insightful comments on a draft of this
chapter. All remaining errors and infelicities are my own.
<!--l. 2--><p class="noindent" >
   <h3 class="likesectionHead"><a 
 id="x1-570009"></a>References</h3>
<!--l. 2--><p class="noindent" >
         <div class="thebibliography">
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[AC96]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xtheory_of_objects"></a><span 
class="cmr-9">Mart</span><span 
class="cmr-9">n Abadi and Luca Cardelli. </span><span 
class="cmti-9">A Theory of Objects</span><span 
class="cmr-9">. Springer, 1996.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[ACPP91]</span>  <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xabadi_cardelli_pierce_plotkin__dynamic_typing_in_a_statically_typed_language"></a><span 
class="cmr-9">Mart</span><span 
class="cmr-9">n Abadi, Luca Cardelli, Benjamin Pierce, and Gordon Plotkin.</span>
         <span 
class="cmr-9">Dynamic typing in a statically typed language.   </span><span 
class="cmti-9">ACM Transactions on</span>
         <span 
class="cmti-9">Programming Languages and Systems</span><span 
class="cmr-9">, 13(2):237&#8211;268, 1991.</span>

         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[AKW98]</span>  <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xaho_kernighan_weinberger__the_awk_programming_language"></a><span 
class="cmr-9">Alfred</span><span 
class="cmr-9">&#x00A0;V. Aho, Brian</span><span 
class="cmr-9">&#x00A0;W. Kernighan, and Peter</span><span 
class="cmr-9">&#x00A0;J. Weinberger.  </span><span 
class="cmti-9">The</span>
         <span 
class="cmti-9">AWK Programming Language</span><span 
class="cmr-9">. Addison Wesley, 1998.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Arm07]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xarmstrong__a_history_of_erlang"></a><span 
class="cmr-9">Joe Armstrong. A history of Erlang. In </span><span 
class="cmti-9">Proc. History of programming</span>
         <span 
class="cmti-9">languages</span><span 
class="cmr-9">. ACM, 2007.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[AWL94]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xaiken_wimmers_lakshman__soft_typing_with_conditional_types"></a><span 
class="cmr-9">Alexander Aiken, Edward</span><span 
class="cmr-9">&#x00A0;L. Wimmers, and T.</span><span 
class="cmr-9">&#x00A0;K. Lakshman.  Soft</span>
         <span 
class="cmr-9">typing  with  conditional  types.   In  </span><span 
class="cmti-9">Proc.  Symposium  on  Principles  of</span>
         <span 
class="cmti-9">programming languages</span><span 
class="cmr-9">, pages 163&#8211;173. ACM, 1994.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Ayc03]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xaycock__a_brief_history_of_just_in_time"></a><span 
class="cmr-9">John  Aycock.   A  brief  history  of  Just-In-Time.   </span><span 
class="cmti-9">ACM  Computing</span>
         <span 
class="cmti-9">Surveys</span><span 
class="cmr-9">, 35(2):97&#8211;113, 2003.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[AZD01]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xancona_zucca_drossopoulou__overloading_and_inheritance"></a><span 
class="cmr-9">D.</span><span 
class="cmr-9">&#x00A0;Ancona,  E.</span><span 
class="cmr-9">&#x00A0;Zucca,  and  S.</span><span 
class="cmr-9">&#x00A0;Drossopoulou.      Overloading  and</span>
         <span 
class="cmr-9">inheritance.  In </span><span 
class="cmti-9">Workshop on Foundations of Object-Oriented Languages</span>
         <span 
class="cmti-9">(FOOL8)</span><span 
class="cmr-9">, 2001.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Bec94]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xbeck__simple_smalltalk_testing_with_patterns"></a><span 
class="cmr-9">Kent   Beck.      Simple   Smalltalk   testing:   With   patterns,   1994.</span>
         <span 
class="cmtt-8x-x-87">http://www.xprogramming.com/testfram.htm </span><span 
class="cmr-9">Accessed Jul 14 2008.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Bra04]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xbracha__pluggable_type_systems"></a><span 
class="cmr-9">Gilad Bracha.  Pluggable type systems.  In </span><span 
class="cmti-9">OOPSLA&#8217;04 Workshop on</span>
         <span 
class="cmti-9">Revival of Dynamic Languages</span><span 
class="cmr-9">, October 2004.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[BS00]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xbrabrand_schwartzbach__growing_languages_with_metamorphic_syntax_macros"></a><span 
class="cmr-9">Claus Brabrand and Michael Schwartzbach.  Growing languages with</span>
         <span 
class="cmr-9">metamorphic  syntax  macros.   In  </span><span 
class="cmti-9">Workshop on Partial Evaluation and</span>
         <span 
class="cmti-9">Semantics-Based Program Manipulation</span><span 
class="cmr-9">, SIGPLAN. ACM, 2000.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[BU04]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xbracha_ungra__mirrors_design_principles_for_meta_level_facilities_of_object_oriented_programming_languages"></a><span 
class="cmr-9">Gilad  Bracha  and  David  Ungar.    Mirrors:  design  principles  for</span>
         <span 
class="cmr-9">meta-level facilities of object-oriented programming languages.  In </span><span 
class="cmti-9">Proc.</span>
         <span 
class="cmti-9">OOPSLA</span><span 
class="cmr-9">, pages 331&#8211;344. ACM, 2004.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Car97]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xcardelli__type_systems"></a><span 
class="cmr-9">Luca  Cardelli.     Type  systems.     In  </span><span 
class="cmti-9">The  Computer  Science  and</span>
         <span 
class="cmti-9">Engineering Handbook</span><span 
class="cmr-9">, pages 2208&#8211;2236. 1997.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Cas95]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xcastagna__covariance_versus_contravariance_conflict_without_a_cause"></a><span 
class="cmr-9">Giuseppe  Castagna.     Covariance  versus  contravariance:  Conflict</span>
         <span 
class="cmr-9">without a cause.  In </span><span 
class="cmti-9">ACM Transactions on Programming Languages and</span>
         <span 
class="cmti-9">Systems</span><span 
class="cmr-9">, pages 431&#8211;447. May 1995.</span>

         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[CF91]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xcartwright_fagan__soft_typing"></a><span 
class="cmr-9">Robert  Cartwright  and  Mike  Fagan.   Soft  typing.   In  </span><span 
class="cmti-9">Proceedings</span>
         <span 
class="cmti-9">of the SIGPLAN &#8217;91 Conference on Programming Language Design and</span>
         <span 
class="cmti-9">Implementation</span><span 
class="cmr-9">, pages 278&#8211;292, 1991.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[CHC90]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xcook_hill_canning__inheritance_is_not_subtyping"></a><span 
class="cmr-9">William Cook, Walter Hill, and Peter Canning.   Inheritance is not</span>
         <span 
class="cmr-9">subtyping.   In  </span><span 
class="cmti-9">Seventeenth  Symposium  on  Principles  of  Programming</span>
         <span 
class="cmti-9">Languages</span><span 
class="cmr-9">, pages 125&#8211;135, 1990.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[CLM05]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xcai_langtangen_moe__on_the_performance_of_the_python_programming_language_for_serial_and_parallel_scientific_computations"></a><span 
class="cmr-9">Xing  Cai,  Hans</span><span 
class="cmr-9">&#x00A0;Petter  Langtangen,  and  Halvard  Moe.    On  the</span>
         <span 
class="cmr-9">performance of the Python programming language for serial and parallel</span>
         <span 
class="cmr-9">scientific computations. </span><span 
class="cmti-9">Scientific Programming</span><span 
class="cmr-9">, 13(1):31&#8211;56, 2005.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Coi87]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xcointe__metaclasses_are_first_class_the_objvlisp_model"></a><span 
class="cmr-9">Pierre Cointe.  Metaclasses are first class: the ObjVLisp model.  In</span>
         <span 
class="cmti-9">Object Oriented Programming Systems Languages and Applications</span><span 
class="cmr-9">, pages</span>
         <span 
class="cmr-9">156&#8211;162, October 1987.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Coo89]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xcook__a_proposal_for_making_eiffel_type_safe"></a><span 
class="cmr-9">William</span><span 
class="cmr-9">&#x00A0;R.  Cook.    A  proposal  for  making  Eiffel  type-safe.    </span><span 
class="cmti-9">The</span>
         <span 
class="cmti-9">Computer Journal</span><span 
class="cmr-9">, 32(4):305&#8211;311, 1989.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[CR91]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xclinger_rees__macros_that_work"></a><span 
class="cmr-9">William Clinger and Jonathan Rees. Macros that work. In </span><span 
class="cmti-9">19th ACM</span>
         <span 
class="cmti-9">Symposium  on  Principles  of  Programming  Languages</span><span 
class="cmr-9">,  pages  155&#8211;162.</span>
         <span 
class="cmr-9">ACM, January 1991.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[CU89]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xchambers_ungra__customization_optimizing_compiler_technology_for_self_a_dynamically_typed_object_oriented_programming_language"></a><span 
class="cmr-9">C.</span><span 
class="cmr-9">&#x00A0;Chambers  and  D.</span><span 
class="cmr-9">&#x00A0;Ungar.    Customization:  optimizing  compiler</span>
         <span 
class="cmr-9">technology for SELF, a dynamically-typed object-oriented programming</span>
         <span 
class="cmr-9">language. </span><span 
class="cmti-9">SIGPLAN Notices</span><span 
class="cmr-9">, 24(7):146&#8211;160, 1989.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[DLR07]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xducasse_lienhard_renggli__seaside_a_flexible_environment_for_building_dynamic_web_applications"></a><span 
class="cmr-9">St</span><span 
class="cmr-9">phane  Ducasse,  Adrian  Lienhard,  and  Lukas  Renggli.   Seaside:</span>
         <span 
class="cmr-9">A  flexible  environment  for  building  dynamic  web  applications.   </span><span 
class="cmti-9">IEEE</span>
         <span 
class="cmti-9">Software</span><span 
class="cmr-9">, 24(5):56&#8211;63, 2007.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[DM95]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xdemers_malenfant__reflection_in_logic_functional_and_object_oriented_programming_a_short_comparative_study"></a><span 
class="cmr-9">Fran</span><span 
class="cmr-9">ois-Nicola Demers and Jacques Malenfant.  Reflection in logic,</span>
         <span 
class="cmr-9">functional and object-oriented programming: a short comparative study.</span>
         <span 
class="cmr-9">In </span><span 
class="cmti-9">Proc. IJCAI&#8217;95 Workshop on Reflection and Metalevel Architectures</span>
         <span 
class="cmti-9">and Their Applications in AI</span><span 
class="cmr-9">, pages 29&#8211;38, August 1995.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[DN66]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xdahl_nygaard__an_algol_based_simulation_language"></a><span 
class="cmr-9">Ole-Johan  Dahl  and  Kristen  Nygaard.   An  Algol-based  simulation</span>
         <span 
class="cmr-9">language. </span><span 
class="cmti-9">Communications of the ACM</span><span 
class="cmr-9">, 9(9):671&#8211;678, 1966.</span>

         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[FBB</span><sup><span 
class="cmr-6">+</span></sup><span 
class="cmr-9">99]</span>  <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xfowler_beck_brant_opdyke_roberts__refactoring_improving_the_design_of_existing_code"></a><span 
class="cmr-9">Martin  Fowler,  Kent  Beck,  John  Brant,  William  Opdyke,  and</span>
         <span 
class="cmr-9">Don  Roberts.    </span><span 
class="cmti-9">Refactoring:  Improving  the  Design  of  Existing  Code</span><span 
class="cmr-9">.</span>
         <span 
class="cmr-9">Addison-Wesley, 1999.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[FD98]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xforman_danforth__putting_metaclasses_to_work_a_new_dimension_in_object_oriented_programming"></a><span 
class="cmr-9">Ira</span><span 
class="cmr-9">&#x00A0;R. Forman and Scott</span><span 
class="cmr-9">&#x00A0;H. Danforth. </span><span 
class="cmti-9">Putting Metaclasses to Work:</span>
         <span 
class="cmti-9">A  New  Dimension  in  Object-Oriented  Programming</span><span 
class="cmr-9">.   Addison-Wesley,</span>
         <span 
class="cmr-9">1998.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Gab86]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xgabriel__performance_and_evaluation_of_lisp_systems"></a><span 
class="cmr-9">Richard</span><span 
class="cmr-9">&#x00A0;P. Gabriel.  </span><span 
class="cmti-9">Performance and Evaluation of LISP Systems</span><span 
class="cmr-9">.</span>
         <span 
class="cmr-9">MIT Press, 1986.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[GG96a]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xgriswold_griswold__history_of_the_icon_programming_language"></a><span 
class="cmr-9">Ralph</span><span 
class="cmr-9">&#x00A0;E.  Griswold  and  Madge</span><span 
class="cmr-9">&#x00A0;T.  Griswold.   History  of  the  Icon</span>
         <span 
class="cmr-9">programming language. pages 599&#8211;624, 1996.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[GG96b]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xgriswold96icon"></a><span 
class="cmr-9">Ralph</span><span 
class="cmr-9">&#x00A0;E. Griswold and Madge</span><span 
class="cmr-9">&#x00A0;T. Griswold.  </span><span 
class="cmti-9">The Icon Programming</span>
         <span 
class="cmti-9">Language</span><span 
class="cmr-9">. Peer-to-Peer Communications, third edition, 1996.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[GJSB00]</span>  <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xgosling00java"></a><span 
class="cmr-9">James Gosling, Bill Joy, Guy Steele, and Gilad Bracha.   </span><span 
class="cmti-9">The Java</span>
         <span 
class="cmti-9">Language Specification Second Edition</span><span 
class="cmr-9">.  Addison-Wesley, Boston, Mass.,</span>
         <span 
class="cmr-9">2000.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[GPP71]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xgriswold_poage_polonsky__the_snobol4_programming_language"></a><span 
class="cmr-9">R.</span><span 
class="cmr-9">&#x00A0;E.  Griswold,  J.</span><span 
class="cmr-9">&#x00A0;F.  Poage,  and  I.</span><span 
class="cmr-9">&#x00A0;P.  Polonsky.   </span><span 
class="cmti-9">The SNOBOL4</span>
         <span 
class="cmti-9">Programming Language</span><span 
class="cmr-9">. Prentice-Hall, second edition, 1971.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[GR89]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xgoldberg_robson__smalltalk_80_the_language"></a><span 
class="cmr-9">Adele  Goldberg  and  David  Robson.   </span><span 
class="cmti-9">Smalltalk-80:  The  Language</span><span 
class="cmr-9">.</span>
         <span 
class="cmr-9">Addison-Wesley, January 1989.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Gri78]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xgriswold__a_history_of_the_snobol_programming_languages"></a><span 
class="cmr-9">Ralph</span><span 
class="cmr-9">&#x00A0;E.  Griswold.     A  history  of  the  SNOBOL  programming</span>
         <span 
class="cmr-9">languages. </span><span 
class="cmti-9">SIGPLAN Notices</span><span 
class="cmr-9">, 13(8):275&#8211;308, 1978.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Hen94]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xhenglein__dynamic_typing_syntax_and_proof_theory"></a><span 
class="cmr-9">Fritz Henglein.  Dynamic typing: syntax and proof theory.  </span><span 
class="cmti-9">Science of</span>
         <span 
class="cmti-9">Computer Programming</span><span 
class="cmr-9">, 22(3):197&#8211;230, 1994.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[HFW84]</span>  <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xhaynes_friedman_wand__continuations_and_coroutines"></a><span 
class="cmr-9">Christopher</span><span 
class="cmr-9">&#x00A0;T.  Haynes,  Daniel</span><span 
class="cmr-9">&#x00A0;P.  Friedman,  and  Mitchell  Wand.</span>
         <span 
class="cmr-9">Continuations and coroutines. In </span><span 
class="cmti-9">Proc. Symposium on LISP and functional</span>
         <span 
class="cmti-9">programming</span><span 
class="cmr-9">, pages 293&#8211;298. ACM, 1984.</span>
         </p>

         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[HN05]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xhicks_nettles__dynamic_software_updating"></a><span 
class="cmr-9">Michael  Hicks  and  Scott</span><span 
class="cmr-9">&#x00A0;M.  Nettles.   Dynamic  software  updating.</span>
         <span 
class="cmti-9">ACM Transactions on Programming Languages and Systems</span><span 
class="cmr-9">, 27(6):1049 &#8211;</span>
         <span 
class="cmr-9">1096, 2005.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[IdFC07]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xierusalimschy_figueiredo_celes__the_evolution_of_lua"></a><span 
class="cmr-9">Roberto Ierusalimschy, Luiz</span><span 
class="cmr-9">&#x00A0;Henrique de</span><span 
class="cmr-9">&#x00A0;Figueiredo, and Waldemar</span>
         <span 
class="cmr-9">Celes. The evolution of Lua. In </span><span 
class="cmti-9">Proc. History of programming languages</span><span 
class="cmr-9">.</span>
         <span 
class="cmr-9">ACM, 2007.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Ier06]</span>     <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xierusalimschy__programming_in_lua"></a><span 
class="cmr-9">Roberto Ierusalimschy. </span><span 
class="cmti-9">Programming in Lua</span><span 
class="cmr-9">. Lua.org, second edition,</span>
         <span 
class="cmr-9">2006.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[JL99]</span>     <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xjones_lins__garbage_collection_algorithms_for_automatic_dynamic_memory_management"></a><span 
class="cmr-9">Richard Jones and Rafael Lins.  </span><span 
class="cmti-9">Garbage Collection: Algorithms for</span>
         <span 
class="cmti-9">Automatic Dynamic Memory Management</span><span 
class="cmr-9">. Wiley, 1999.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Jon03]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xpeyton_jones__haskell_98_languages_and_libraries"></a><span 
class="cmr-9">Simon</span><span 
class="cmr-9">&#x00A0;Peyton Jones. </span><span 
class="cmti-9">Haskell 98 Languages and Libraries: The Revised</span>
         <span 
class="cmti-9">Report</span><span 
class="cmr-9">. Cambridge University Press, April 2003.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Kay96]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xkay__the_early_history_of_smalltalk"></a><span 
class="cmr-9">Alan</span><span 
class="cmr-9">&#x00A0;C. Kay. The early history of Smalltalk. pages 511&#8211;598, 1996.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[KdRB91]</span>  <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xkiczales_des_rivieres_bobrow__the_art_of_the_metaobject_protocol"></a><span 
class="cmr-9">Gregor Kiczales, Jim des Rivieres, and Daniel</span><span 
class="cmr-9">&#x00A0;G. Bobrow. </span><span 
class="cmti-9">The Art of</span>
         <span 
class="cmti-9">the Metaobject Protocol</span><span 
class="cmr-9">. MIT Press, 1991.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[KFFD86]</span>  <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xkohlbecker_friedman_felleisen_duba__hygienic_macro_expansion"></a><span 
class="cmr-9">Eugene  Kohlbecker,  Daniel</span><span 
class="cmr-9">&#x00A0;P.  Friedman,  Matthias  Felleisen,  and</span>
         <span 
class="cmr-9">Bruce  Duba.   Hygienic  macro  expansion.   In  </span><span 
class="cmti-9">Symposium on Lisp and</span>
         <span 
class="cmti-9">Functional Programming</span><span 
class="cmr-9">, pages 151&#8211;161. ACM, 1986.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[KG07]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xkarabuk_grant__a_common_medium_for_programming_operations_research_models"></a><span 
class="cmr-9">Suleyman  Karabuk  and  F.</span><span 
class="cmr-9">&#x00A0;Hank  Grant.   A  common  medium  for</span>
         <span 
class="cmr-9">programming operations-research models.   </span><span 
class="cmti-9">IEEE Software</span><span 
class="cmr-9">, 24(5):39&#8211;47,</span>
         <span 
class="cmr-9">2007.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[KM05]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xkoenig_moo__templates_and_duck_typing"></a><span 
class="cmr-9">Andrew Koenig and Barbara</span><span 
class="cmr-9">&#x00A0;E. Moo. Templates and duck typing. </span><span 
class="cmti-9">Dr.</span>
         <span 
class="cmti-9">Dobb&#8217;s</span><span 
class="cmr-9">, 2005.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[LB85]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xlehman_belady__program_evolution_processes_of_software_change"></a><span 
class="cmr-9">M.</span><span 
class="cmr-9">&#x00A0;M. Lehman and L.</span><span 
class="cmr-9">&#x00A0;A. Belady.  </span><span 
class="cmti-9">Program Evolution: Processes of</span>
         <span 
class="cmti-9">Software Change</span><span 
class="cmr-9">. Academic Press, 1985.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[LF03]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xlink_froehlich__unit_testing_in_java_how_tests_drive_the_code"></a><span 
class="cmr-9">Johannes Link and Peter Fr</span><span 
class="cmr-9">hlich.  </span><span 
class="cmti-9">Unit Testing in Java: How Tests</span>
         <span 
class="cmti-9">Drive the Code</span><span 
class="cmr-9">. Morgan Kaufmann, 2003.</span>

         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Lou08]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xloui__in_praise_of_scripting_real_programming_pragmatism"></a><span 
class="cmr-9">Ronald</span><span 
class="cmr-9">&#x00A0;P. Loui. In praise of scripting: Real programming pragmatism.</span>
         <span 
class="cmti-9">Computer</span><span 
class="cmr-9">, 41(7):22&#8211;26, 2008.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[LS04]</span>     <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xlindahl_sagonas__detecting_software_defects_in_telecom_applications_through_lightweight_static_analysis_a_war_story"></a><span 
class="cmr-9">Tobias Lindahl and Konstantinos Sagonas. Detecting software defects</span>
         <span 
class="cmr-9">in telecom applications through lightweight static analysis: A war story. In</span>
         <span 
class="cmr-9">Chin Wei-Ngan, editor, </span><span 
class="cmti-9">Programming Languages and Systems: Proceedings</span>
         <span 
class="cmti-9">of the Second Asian Symposium (APLAS&#8217;04)</span><span 
class="cmr-9">, volume 3302 of </span><span 
class="cmti-9">LNCS</span><span 
class="cmr-9">, pages</span>
         <span 
class="cmr-9">91&#8211;106. Springer, November 2004.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Mac93]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xmacqueen__reflections_on_standard_ml"></a><span 
class="cmr-9">David</span><span 
class="cmr-9">&#x00A0;B.  MacQueen.   Reflections  on  standard  ML.   In  </span><span 
class="cmti-9">Functional</span>
         <span 
class="cmti-9">Programming,   Concurrency,   Simulation   and   Automated   Reasoning</span><span 
class="cmr-9">,</span>
         <span 
class="cmr-9">volume 693 of </span><span 
class="cmti-9">LNCS</span><span 
class="cmr-9">, pages 32&#8211;46. Springer-Verlag, 1993.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Mae87]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xmaes__concepts_and_experiments_in_computational_reflection"></a><span 
class="cmr-9">Pattie Maes.  Concepts and experiments in computational reflection.</span>
         <span 
class="cmr-9">In </span><span 
class="cmti-9">Proc. OOPSLA</span><span 
class="cmr-9">, pages 147&#8211;155, New York, NY, USA, 1987. ACM.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Mat90]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xmatthews__static_and_dynamic_type_checking"></a><span 
class="cmr-9">David C.</span><span 
class="cmr-9">&#x00A0;J. Matthews.  Static and dynamic type checking.  </span><span 
class="cmti-9">Advances</span>
         <span 
class="cmti-9">in database programming languages</span><span 
class="cmr-9">, pages 67&#8211;73, 1990.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[McC60]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xmccarthy__recursive_functions_of_symbolic_expressions_and_their_computation_by_machine_part_i"></a><span 
class="cmr-9">John  McCarthy.   Recursive  functions  of  symbolic  expressions  and</span>
         <span 
class="cmr-9">their computation by machine (part I).   </span><span 
class="cmti-9">Communications of the ACM</span><span 
class="cmr-9">,</span>
         <span 
class="cmr-9">3(4):184&#8211;195, 1960.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[McC78]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xmccarthy__history_of_lisp"></a><span 
class="cmr-9">John McCarthy. History of LISP. In </span><span 
class="cmti-9">History of programming languages</span><span 
class="cmr-9">,</span>
         <span 
class="cmr-9">pages 173&#8211;185. ACM, 1978.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[MD04]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xmeijer_drayton__static_typing_when_possible_dynamic_typing_when_needed_the_end_of_the_cold_war_between_programming_languages"></a><span 
class="cmr-9">Erik Meijer and Peter Drayton. Static typing where possible, dynamic</span>
         <span 
class="cmr-9">typing  when  needed:  The  end  of  the  cold  war  between  programming</span>
         <span 
class="cmr-9">languages.  In </span><span 
class="cmti-9">OOPSLA&#8217;04 Workshop on Revival of Dynamic Languages</span><span 
class="cmr-9">,</span>
         <span 
class="cmr-9">October 2004.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Mei07]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xmeijer__confessions_of_a_used_programming_language_salesman"></a><span 
class="cmr-9">Erik Meijer.  Confessions of a used programming language salesman.</span>
         <span 
class="cmti-9">SIGPLAN Notices</span><span 
class="cmr-9">, 42(10):677&#8211;694, 2007.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Mey92]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xmeyer__eiffel_the_language"></a><span 
class="cmr-9">Bertrand Meyer.  </span><span 
class="cmti-9">Eiffel: The Language</span><span 
class="cmr-9">.  Prentice Hall International,</span>
         <span 
class="cmr-9">1992.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[MMMP90]</span> <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xmadsen_magnusson_molier_pedersen__strong_typing_of_object_oriented_languages_revisited"></a><span 
class="cmr-9">Ole</span><span 
class="cmr-9">&#x00A0;Lehrmann     Madsen,     Boris     Magnusson,     and     Birger</span>

         <span 
class="cmr-9">Mlier-Pedersen. Strong typing of object-oriented languages revisited. In</span>
         <span 
class="cmti-9">Proc. OOPSLA</span><span 
class="cmr-9">, pages 140&#8211;150. ACM, 1990.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[MR05]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xmitchell_runciman__unfailing_haskell_a_static_checker_for_pattern_matching"></a><span 
class="cmr-9">Neil Mitchell and Colin Runciman. Unfailing Haskell: A static checker</span>
         <span 
class="cmr-9">for  pattern  matching.    In  </span><span 
class="cmti-9">Proc.  Symposium  on  Trends  in  Functional</span>
         <span 
class="cmti-9">Programming</span><span 
class="cmr-9">, pages 313&#8211;328, 2005.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[MvCT</span><sup><span 
class="cmr-6">+</span></sup><span 
class="cmr-9">08]</span> <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xmostinckx_van_cutsem_timbermont_tanter__mirror_based_reflection_in_ambienttalk"></a><span 
class="cmr-9">Stijn Mostinckx, Tom van Cutsem, Stijn Timbermont, Elisa</span><span 
class="cmr-9">&#x00A0;Gonzalez</span>
         <span 
class="cmr-9">Boix, </span><span 
class="cmr-9">ric Tanter, and Wolfgang de</span><span 
class="cmr-9">&#x00A0;Meuter.  Mirror-based reflection in</span>
         <span 
class="cmr-9">AmbientTalk. </span><span 
class="cmti-9">Software&#8212;Practice and Experience</span><span 
class="cmr-9">, 2008. To appear.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[NBD</span><sup><span 
class="cmr-6">+</span></sup><span 
class="cmr-9">05]</span>  <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xnierstrasz_bergel_denker_ducasse_galli_wuyts__on_the_revival_of_dynamic_languages"></a><span 
class="cmr-9">Oscar   Nierstrasz,   Alexandre   Bergel,   Marcus   Denker,   St</span><span 
class="cmr-9">phane</span>
         <span 
class="cmr-9">Ducasse,  Markus  G</span><span 
class="cmr-9">lli,  and  Roel  Wuyts.   On  the  revival  of  dynamic</span>
         <span 
class="cmr-9">languages.  In </span><span 
class="cmti-9">Proc. Software Composition 2005</span><span 
class="cmr-9">, volume 3628 of </span><span 
class="cmti-9">LNCS</span><span 
class="cmr-9">,</span>
         <span 
class="cmr-9">pages 1&#8211;13, 2005.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Nor92]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xnorvig__paradigms_of_artificial_intelligence_programming_case_studies_in_common_lisp"></a><span 
class="cmr-9">Peter Norvig. </span><span 
class="cmti-9">Paradigms of Artificial Intelligence Programming: Case</span>
         <span 
class="cmti-9">Studies in Common Lisp</span><span 
class="cmr-9">. Morgan Kaufmann, 1992.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[OC04]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xdynamic_adaptation_of_application_aspects__ortin_cueva"></a><span 
class="cmr-9">Francisco  Ortin  and  Juan</span><span 
class="cmr-9">&#x00A0;Manuel  Cueva.   Dynamic  adaptation  of</span>
         <span 
class="cmr-9">application aspects.  </span><span 
class="cmti-9">Journal of Systems and Software</span><span 
class="cmr-9">, 71:229&#8211;243, May</span>
         <span 
class="cmr-9">2004.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Oli07]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xolihpant__python_for_scientific_computing"></a><span 
class="cmr-9">T.E. Oliphant. Python for scientific computing. </span><span 
class="cmti-9">Computing in Science</span>
         <span 
class="cmti-9">and Engineering</span><span 
class="cmr-9">, 9(3):10&#8211;20, May 2007.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Ous94]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xousterhout__tcl_and_the_tk_toolkit"></a><span 
class="cmr-9">John Ousterhout. </span><span 
class="cmti-9">Tcl and the Tk Toolkit</span><span 
class="cmr-9">. Addison-Wesley, 1994.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Ous98]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xousterhout__scripting_higher_level_programming_for_the_21st_century"></a><span 
class="cmr-9">John</span><span 
class="cmr-9">&#x00A0;K. Ousterhout. Scripting: Higher-level programming for the 21st</span>
         <span 
class="cmr-9">century. </span><span 
class="cmti-9">Computer</span><span 
class="cmr-9">, 31(3):23&#8211;30, 1998.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Pau07]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xpaulson__developers_shift_to_dynamic_programming_languages"></a><span 
class="cmr-9">Linda</span><span 
class="cmr-9">&#x00A0;Dailey  Paulson.   Developers  shift  to  dynamic  programming</span>
         <span 
class="cmr-9">languages. </span><span 
class="cmti-9">Computer</span><span 
class="cmr-9">, 40(2):12&#8211;15, 2007.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Pie02]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xpierce__types_and_programming_languages"></a><span 
class="cmr-9">Benjamin</span><span 
class="cmr-9">&#x00A0;C. Pierce. </span><span 
class="cmti-9">Types and Programming Languages</span><span 
class="cmr-9">. MIT Press,</span>
         <span 
class="cmr-9">2002.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Rov85]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xrovner__on_adding_garbage_collection_and_runtime_types_to_a_strongly_typed_statically_checked_concurrent_language"></a><span 
class="cmr-9">Paul Rovner.  On adding garbage collection and runtime types to a</span>
         <span 
class="cmr-9">strongly-typed, statically-checked, concurrent language. Technical Report</span>
         <span 
class="cmr-9">CSL-84-7, Xerox Parc, 1985.</span>

         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[SC92]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xspencer_collyer__ifdef_considered_harmful_or_portability_experience_with_cnews"></a><span 
class="cmr-9">Henry  Spencer  and  Geoff  Collyer.    #ifdef  considered  harmful,  or</span>
         <span 
class="cmr-9">portability experience with CNews. In </span><span 
class="cmti-9">Proc.</span><span 
class="cmti-9">&#x00A0;of the Summer 1992 USENIX</span>
         <span 
class="cmti-9">Conference</span><span 
class="cmr-9">, pages 185&#8211;198, San Antionio, Texas, 1992.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[SDNB03]</span>  <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xscharli_ducasse_nierstrasz_black__traits_composable_units_of_behaviour"></a><span 
class="cmr-9">Nathanael   Sch</span><span 
class="cmr-9">rli,   St</span><span 
class="cmr-9">phane   Ducasse,   Oscar   Nierstrasz,   and</span>
         <span 
class="cmr-9">Andrew</span><span 
class="cmr-9">&#x00A0;P.  Black.   Traits:  Composable  units  of  behaviour?   In  </span><span 
class="cmti-9">Proc.</span>
         <span 
class="cmti-9">ECOOP</span><span 
class="cmr-9">, volume 2743 of </span><span 
class="cmti-9">LNCS</span><span 
class="cmr-9">, pages 248&#8211;274, July 2003.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[SG96]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xsteele_gabriel__the_evolution_of_lisp"></a><span 
class="cmr-9">Guy</span><span 
class="cmr-9">&#x00A0;L. Steele and Richard</span><span 
class="cmr-9">&#x00A0;P. Gabriel.  The evolution of Lisp.  pages</span>
         <span 
class="cmr-9">233&#8211;330, 1996.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[SG97]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xspinellis_guruprasad__lightweight_languages_as_software_engineering_tools"></a><span 
class="cmr-9">Diomidis  Spinellis  and  V.</span><span 
class="cmr-9">&#x00A0;Guruprasad.    Lightweight  languages  as</span>
         <span 
class="cmr-9">software engineering tools.  In </span><span 
class="cmti-9">USENIX Conference on Domain-Specific</span>
         <span 
class="cmti-9">Languages</span><span 
class="cmr-9">,   pages   67&#8211;76,   Berkeley,   CA,   October   1997.   USENIX</span>
         <span 
class="cmr-9">Association.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[She98]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xsheard__using_metaml_a_staged_programming_language"></a><span 
class="cmr-9">Tim  Sheard.    Using  MetaML:  A  staged  programming  language.</span>
         <span 
class="cmti-9">Advanced Functional Programming</span><span 
class="cmr-9">, pages 207&#8211;239, September 1998.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[SJ75]</span>     <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xsussman_steele__scheme_an_interpreter_for_extended_lambda_calculus"></a><span 
class="cmr-9">Gerald</span><span 
class="cmr-9">&#x00A0;Jay Sussman and Guy Lewis</span><span 
class="cmr-9">&#x00A0;Steele Jr. Scheme: An interpreter</span>
         <span 
class="cmr-9">for extended lambda calculus. Technical Report AI Lab Memo AIM-349,</span>
         <span 
class="cmr-9">MIT AI Lab, December 1975.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[SJ02]</span>     <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xsheard_peyton_jones__template_meta_programming_for_haskell"></a><span 
class="cmr-9">Tim Sheard and Simon</span><span 
class="cmr-9">&#x00A0;Peyton Jones.  Template meta-programming</span>
         <span 
class="cmr-9">for Haskell. In </span><span 
class="cmti-9">Proceedings of the Haskell workshop 2002</span><span 
class="cmr-9">. ACM, 2002.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[SS94]</span>     <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xsterling94prolog"></a><span 
class="cmr-9">Leon Sterling and Ehud Shapiro. </span><span 
class="cmti-9">The Art of Prolog</span><span 
class="cmr-9">. MIT Press, second</span>
         <span 
class="cmr-9">edition, March 1994.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[SSJ98]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xshields_sheard_peyton_jones__dynamic_typing_as_staged_type_inference"></a><span 
class="cmr-9">Mark  Shields,  Tim  Sheard,  and  Simon</span><span 
class="cmr-9">&#x00A0;Peyton  Jones.    Dynamic</span>
         <span 
class="cmr-9">typing as staged type inference.   In </span><span 
class="cmti-9">Proc. Symposium on Principles of</span>
         <span 
class="cmti-9">Programming Languages</span><span 
class="cmr-9">, pages 289&#8211;302, January 1998.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Ste90]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xsteel90clos"></a><span 
class="cmr-9">Guy</span><span 
class="cmr-9">&#x00A0;L. Steele, Jr.  </span><span 
class="cmti-9">Common Lisp the Language</span><span 
class="cmr-9">.  Digital Press, 2nd</span>
         <span 
class="cmr-9">edition, 1990.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[SV08]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xsiek_vacharajani__gradual_typing_with_unification_based_inference"></a><span 
class="cmr-9">Jeremy</span><span 
class="cmr-9">&#x00A0;G.  Siek  and  Manish  Vacharajani.    Gradual  typing  with</span>
         <span 
class="cmr-9">unification-based inference. In </span><span 
class="cmti-9">Dynamic Languages Symposium</span><span 
class="cmr-9">, 2008.</span>

         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[TH00]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xthomas_hunt__programming_ruby_a_pragmatic_programmers_guide"></a><span 
class="cmr-9">David Thomas and Andrew Hunt.  </span><span 
class="cmti-9">Programming Ruby: A Pragmatic</span>
         <span 
class="cmti-9">Programmer&#8217;s Guide</span><span 
class="cmr-9">. Addison-Wesley, 2000.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[THF08]</span>   <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xtobin_hochstadt_felleisen__the_design_and_implementation_of_typed_scheme"></a><span 
class="cmr-9">Sam  Tobin-Hochstadt  and  Matthias  Felleisen.     The  design  and</span>
         <span 
class="cmr-9">implementation of typed Scheme. </span><span 
class="cmti-9">SIGPLAN Notices</span><span 
class="cmr-9">, 43(1):395&#8211;406, 2008.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[Tra07]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xtratt__converge_manual"></a><span 
class="cmr-9">Laurence   Tratt.        </span><span 
class="cmti-9">Converge   Reference   Manual</span><span 
class="cmr-9">,   July   2007.</span>
         <span 
class="cmtt-8x-x-87">http://www.convergepl.org/documentation/ </span><span 
class="cmr-9">Accessed June 3 2008.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[TW07]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xtratt_wuyts__dynamically_typed_languages"></a><span 
class="cmr-9">Laurence Tratt and Roel Wuyts. Dynamically typed languages. </span><span 
class="cmti-9">IEEE</span>
         <span 
class="cmti-9">Software</span><span 
class="cmr-9">, 24(5):28&#8211;30, 2007.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[US87]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xungar_smith__self_the_power_of_simplicity"></a><span 
class="cmr-9">David Ungar and Randall</span><span 
class="cmr-9">&#x00A0;B. Smith. Self: The power of simplicity. In</span>
         <span 
class="cmti-9">Proc. OOPSLA</span><span 
class="cmr-9">, pages 227&#8211;241, October 1987.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[vR03]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xpython2.3languagereference"></a><span 
class="cmr-9">Guido   van   Rossum.       Python   2.3   reference   manual,   2003.</span>
         <span 
class="cmtt-8x-x-87">http://www.python.org/doc/2.3/ref/ref.html </span><span 
class="cmr-9">Accessed June 3 2008.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[VWWA96]</span> <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xvirding_wikstrom_williams_armstrong__concurrent_programming_in_erlang"></a><span 
class="cmr-9">Robert Virding, Claes Wikstrom, Mike Williams, and Joe Armstrong.</span>
         <span 
class="cmti-9">Concurrent Programming in Erlang</span><span 
class="cmr-9">. Prentice Hall, 1996.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[WCO00]</span>  <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xwall00programming"></a><span 
class="cmr-9">Larry Wall, Tom Christiansen, and Jon Orwant.  </span><span 
class="cmti-9">Programming Perl</span><span 
class="cmr-9">.</span>
         <span 
class="cmr-9">O&#8217;Reilly, third edition, 2000.</span>
         </p>
         <p class="bibitem" ><span class="biblabel">
<span 
class="cmr-9">[XP98]</span>    <span class="bibsp"><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span><span 
class="cmr-9">&#x00A0;</span></span></span><a 
 id="Xxi_pfenning__eliminating_array_bound_checking_through_dependent_types"></a><span 
class="cmr-9">Hongwei Xi and Frank Pfenning.  Eliminating array bound checking</span>
         <span 
class="cmr-9">through dependent types. In </span><span 
class="cmti-9">Proc. Conference on Programming Language</span>
         <span 
class="cmti-9">Design and Implementation</span><span 
class="cmr-9">, pages 249&#8211;257, 1998.</span>
</p>
         </div>
    
</div>
<hr />

<Table id="footer">
<tr>
<td align = "left"><a href = "/laurie/">Home</a> > <a href="../../">Publications</a></td>
<TD Align = "Right"> Laurence Tratt <A HRef = "mailto:laurie@tratt.net">laurie@tratt.net</A></TD>
</tr>
</Table>

</Body>
</HTML>
