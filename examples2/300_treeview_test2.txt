{***************************************************************
 * Project  : System Graphic Function Overview
 * App Name : 300_treeview_animation tester, loc's = 875 
 * Purpose  : Demonstrates outline in a tree
 * Date     : 09/12/2012  -  17:07
 * History  : convert outline VCL to maXbox Nov 2011
 *          : system save demo for mX3.9.2, not finished yet!!
            : animates a sprite cursor, if XP then ProcessMessagesOFF;
 ****************************************************************}

Program Treeview3_tester;

{@BOOL WINAPI MessageBeep(
  __in  UINT uType  );}
//TThreadFunction = function(P: Pointer): Longint; stdcall;
//Procedure ExecuteThread(afunc: TThreadFunction; var thrOK: boolean);


function MessageBoxTimeOut(hWnd: HWND; lpText: PChar; lpCaption: PChar; uType: UINT;
                wLanguageId: WORD; dwMilliseconds: DWORD): Integer;
             external 'MessageBoxTimeoutA@user32.dll stdcall';
  
procedure CloseClick(Sender: TObject; var action: TCloseAction); forward;
  
Const
  BACKMAP = 'examples\images\bmp47.bmp';
  //BACKMAP = 'examples\images\bmp33.bmp';
  BITMAP1 = 'examples\images\empty.bmp';
  BITMAP2 = 'examples\images\empty.bmp';
  //BITMAP1 = 'examples\images\bmp21.bmp';  //try another combinations
  //BITMAP2 = 'examples\images\bmp29.bmp';
  //BITMAP2 = 'examples\images\bmp33.bmp';
  SAVEPATH = 'examples\treeview_300.txt';
  AExponent = 4;
  
type
  TByteArr = array of byte;
  
var
  except_state, execute_state: string;  
  mytimestamp: TDateTime;
  osType: TIdWin32Type;
  bfrm: TForm;
  FMask, FPic, FStorage: TBitMap;
  FNewRect: TRect; 
  FOldRect: tRect; //make foldrect local!
  FirstTime: boolean;
  tv1: TOutline;
  mt: ttoolwindow;
  mtd: ttooldockform;
  distX, distY, endX, endY, beginX, beginY, x,y, step, pct: float;
  
  

procedure getMaxBoxIni;
var Ini: TIniFile;   
begin
  Ini:= TIniFile.Create(ExePath+'maxboxdef.ini');
  try
    except_state:= Ini.ReadString('Form', 'EXCEPTIONLOG','');
    execute_state:= Ini.ReadString('Form', 'EXECUTESHELL','');
  finally
    writeln('inifile sysdata test: '+(except_state)+ ' '+(execute_state))
    ini.Free;
  end;
end;


procedure FormDrawBitmap(const fname: String; const x,y: Integer; acanvas: TCanvas);
var aBmp: TBitmap;
begin
  if not FileExists(Fname) then begin
    ShowMessage('The big bitmap ' + Fname + ' was not found!');
    Exit;
  end;
  aBmp:= TBitmap.Create;
  try
    aBmp.LoadFromFile(Fname);
    //aCanvas.Draw(x,y, aBmp);
    aCanvas.StretchDraw(Rect(0,0,bfrm.width, bfrm.height), aBmp);
  finally
    aBmp.Free;
  end;
end; 

procedure BitmapFormCreate(Sender: TObject);
begin
  FMask:= TBitMap.Create;
  FMask.LoadFromFile(exepath+BITMAP2);
  //FMask.LoadFromFile(exepath+'examples\citymax.bmp');
  FPic:= TBitMap.Create;
  FPic.LoadFromFile(exepath+BITMAP1);
  FStorage:= TBitMap.Create;
  FStorage.Width:= FPic.Width;
  FStorage.Height:= FPic.Height;
  Screen.Cursor:= crCross;//loadCursor(hinstance,'Pan_All'); //crCross;
end;  

function getBitMapObject2(mappath: string): TBitmap;
begin
  result:= TBitmap.Create;
  try 
    result.LoadFromFile(mappath);
  finally
    //result.Free;
  end;  
end;  


//********************************Event Handler*****************************//
procedure BtnAddClick(Sender: TObject);
  var
   sText : shortstring;
   idx: integer;
begin
      {If nothing is selected}
   if(tv1.SelectedItem < 0) then begin
         {Does a root node already exist? if( tv_eg1.Items.Count = 0 )}
    //with tv1[tv1.SelectedItem] do
      //if HasItems then Expand;
      if(tv1.Items[1].text = '') then begin
            {Add the root node}
         with tv1 do begin
            idx:= Add(0,'Root');
            Selecteditem:= items[idx];
            //debugln('tv_eg1.Selected=',DbgS(tv_eg1.Selected));
         end;
      end else begin
            {There is a root, so user must first select a node}
         //MessageBeep(  -1  );
         ShowMessage(  'Select a parent node'  );
         Exit;
      end;
   end
   else begin
         {Get a name for the new node}
      sText:= 'New xnode';
      InputQuery('New Node',  'Caption ?', sText  );
         {Add the node as a child of the selected node}
     //with tv1.items[tv1.SelectedItem] do
      //if HasItems then Expand;
     with tv1[tv1.SelectedItem] do
      if HasItems then Expand;
      with tv1 do begin
      idx:= selecteditem  //itemindex
         AddChild(idx,sText);
         FullExpand;
      end;
   end;
end;

procedure TForm1_Button1Click(Sender: TObject);
var panel1: TPanel;
begin
 with Panel1 do begin
   BevelInner:= bvLowered;
   BevelOuter:= bvRaised;
   if BevelWidth = 0 then
     BevelWidth := 2
   else
   BevelWidth := 0;
  end;
end;

procedure RemoveClick(Sender: TObject);
var idx: integer;
begin
  {Make sure somthing is selected, before trying to delete it}
   if(tv1.SelectedItem < 0) then begin
      //MessageBeep(  -1  );
      ShowMessage('Nothing selected'  );
      Exit;
   end;
      {Dont allow user to delete the root node}
   if(tv1.SelectedItem = 1) then begin
      //MessageBeep(  -1  );
      ShowMessage('Cant delete the root node!');
      Exit;
   end;
      {Delete the node}
     with tv1 do begin
       idx:= selecteditem  //itemindex
       Delete(idx);
       FullExpand;
     end; 
   //tv1.SelectedItem.Delete;
end;

procedure CloseClick(Sender: TObject; var action: TCloseAction);
begin
  FMask.Free;
  FPic.Free;
  FStorage.Free;
  action:= caFree;
  Screen.Cursor:= crDefault;
  writeln('Outline Form being closed');
end;

procedure CloseButtonClick(Sender: TObject);
begin
  bfrm.Close; //calls close click
end;

procedure ClickTestButton(Sender: TObject);
begin
  //tv1.SaveToFile(SAVEPATH);
  //SaveCanvas2(bfrm.Canvas, Exepath+SAVEPATH);
  //if sender
  writeln(objectToStr(sender)+' has been hit at: '+Exepath+SAVEPATH);
end;

procedure ClickTestButton2(Sender: TObject);
begin
  //tv1.SaveToFile(SAVEPATH);
  //SaveCanvas2(bfrm.Canvas, Exepath+SAVEPATH);
  writeln('Outline has been hit at: '+Exepath+SAVEPATH);
end;

procedure DblClickButton(Sender: TObject);
begin
  tv1.SaveToFile(SAVEPATH);
  //SaveCanvas2(bfrm.Canvas, Exepath+SAVEPATH);
  writeln('Outline being stored at: '+Exepath+SAVEPATH);
  bfrm.canvas.draw(300,200, getbitmapObject2(Exepath+'\examples\citymax.bmp'));
  
end;

procedure drawE(); 
{
  fill(0, 2);
  rect(0, 0, width, height);
  pct += step;
  if (pct < 1.0) {
    x = beginX + (pct * distX);
    y = beginY + (pow(pct, exponent) * distY);
  }
  //fill(255);  //ellipse(x, y, 20, 20);
var i: integer;  
begin
  for i:= 1 to 100 do begin
  pct:= pct+ step;
  if (pct < 1.0) then begin
    x:= beginX + (pct * distX);
    y:= beginY + (power(pct, AExponent) * distY);
  end;
  //  bfrm.repaint;
  //bfrm.canvas.draw(round(x),round(y), fpic);
  bfrm.canvas.draw(round(x)-20,round(y-20),
           getbitmap(Exepath+'\examples\images\yellow1.bmp'));
    // BitBlt(FStorage.Canvas.Handle,0,0, FPic.Width, FPic.Height,
              // bfrm.Canvas.Handle, round(x), round(y), SRCCOPY);
  delay(10);
  end;
end;  



procedure FormMouseDown(sender: TObject; Button: TMouseButton; 
                                Shift: TShiftState; vX, vY: Integer);
begin
   BitBlt(FStorage.Canvas.Handle,0,0, FPic.Width, FPic.Height,
               bfrm.Canvas.Handle, FNewRect.Left, FNewRect.Top,  SRCCOPY);
  pct:= 0.0;
  beginX:= x;
  beginY:= y;
  endX:= vX;     //mouseX
  endY:= vY;
  distX:= endX - beginX;
  distY:= endY - beginY;
  
  bfrm.repaint;
  FormDrawBitmap(Exepath+BACKMAP,10,10, bfrm.canvas);
  drawE;
             
end;

procedure FormMouseMove(Sender: TObject; Shift: TShiftState; X,Y: Integer);
//const FirstTime: boolean = True;
//var FOldRect: TRect;     //makes a blur and zoom effect
begin
  //firsttime:= true;   //move tester
  { 1) Restore Form1: copy storage onto Form1 at its old location }
  //FOldRect:= Rect(280, 200, X , Y);
  if FirstTime then FirstTime:= False
    else BitBlt(bfrm.Canvas.Handle, FOldRect.Left, FOldRect.Top, FPic.Width,FPic.Height,
              FStorage.Canvas.Handle,0,0,SRCCOPY);
  { save old location }
  FNewRect:= Rect(X, Y, X + FPic.Width, Y + FPic.Height);
  FOldRect:= FNewRect;
  
  { 2) Save copy of Form1: copy a rectangle from Form1 to storage at new location. }
  BitBlt(FStorage.Canvas.Handle,0,0, FPic.Width, FPic.Height,
         bfrm.Canvas.Handle, FNewRect.Left, FNewRect.Top,  SRCCOPY);
  { 3) copy the image to Form1 using SRCINVERT }
  BitBlt(bfrm.Canvas.Handle, FNewRect.Left, FNewRect.Top, FPic.Width, FPic.Height,
         FPic.Canvas.Handle,0,0, SRCINVERT);
  { 4) copy the mask to Form1 using SRCAND }
  BitBlt(bfrm.Canvas.Handle, FNewRect.Left, FNewRect.Top, FPic.Width, FPic.Height,
         FMask.Canvas.Handle,0,0, SRCAND);
  { 5) copy the image to Form1 again using SRCINVERT }
  BitBlt(bfrm.Canvas.Handle, FNewRect.Left, FNewRect.Top, FPic.Width, FPic.Height,
         FPic.Canvas.Handle,0,0, SRCINVERT);
end;

procedure setup(); 
{
  size(640, 360);
  noStroke();
  distX = endX - beginX;
  distY = endY - beginY;
}
begin
  beginX:= 20.0;  // Initial x-coordinate
  beginY:= 10.0;  // Initial y-coordinate
  endX:= 570.0;   // Final x-coordinate
  endY:= 320.0;   // Final y-coordinate
  x:= 0.0;        // Current x-coordinate
  y:= 0.0;        // Current y-coordinate
  step:= 0.01;    // Size of each step along the path
  pct:= 0.0;      // Percentage traveled (0.0 to 1.0)
  distX:= endX - beginX;
  distY:= endY - beginY;
end;



//********************************Form Builder*****************************//
procedure InitBitmapForm;
var
  RootNode: TTreeNode;
  idx: integer; 
   myc: TCollection;   
   //images: TCustomImagelist;
 
begin
 Setup;
 bfrm:= TForm.create(self);
  //mt.free;  in on close
 with bfrm do begin
   //FormStyle := fsStayOnTop;
   Position:= poScreenCenter;
   caption:='Outline TreeView Demo - DblClick to Save Outline';
   //color:= clsilver;
   width:= 750;
   height:= 670;
   //canvas.Pen.mode:= pmNotXor;
   onMouseMove:= @FormMouseMove;
   onMouseDown:= @FormMouseDown;
   onDblClick:= @DblClickButton;
   onclick:= @clicktestbutton;
   onClose:=  @CloseClick;
   //canvas.brush.bitmap.loadfromfile(Exepath+backmap);
   Show;
   //canvas.draw(300,200, getbitmapObject2(Exepath+'\examples\citymax.bmp'));
 
   //Show;
 end;
 tv1:= TOutline.Create(bfrm);
 with tv1 do begin
    Parent:= bfrm;
    //multiselect
    //scrollbars
    top:= 5; left:= 5;
    width:= 170; height:= 130;
    //SetBounds(0,0,196, 427);
    //Align:= alLeft;
    //HideSelection = False
    //Indent = 19
    //ParentCtl3D = False
    //ReadOnly = True //TabOrder = 0                              
      //tv1.Items[0].text:= 'NIL';
      {tv1.add(0,'ROOT');     //idx=1 !
      tv1.addChild(1,'Node1');
      tv1.addChild(1,'Node2');
      tv1.addChild(1,'Node3');
      idx:= tv1.add(1,'SECOND');
      //writeln(inttostr(idx))
      tv1.addChild(idx,'Node21');
      tv1.addChild(idx,'Node22'); }
      Loadfromfile(ExePath+SAVEPATH);
      FullExpand;
     //tv1.Items.AddChild(RootNode,'Node2');
     //tv1.Items.AddChild(RootNode,'Node3');
     //Expanded:=true;
     onclick:= @clicktestbutton;
     //tag;
     //onmousedown;
     //onmousemove;
  end; 

  with TTreeView.Create(bfrm) do begin
   parent:= bfrm;
   Loadfromfile(ExePath+SAVEPATH);
  setbounds(5,150,160, 160);
   writeln(inttostr(width));
   FullExpand;
   //Items[2].addchild('','');
   //color
    onclick:= @clicktestbutton;
    //images.getBitmap(0,getBitmap2(Exepath+BITMAP2));
   //onclick
   //images
  end; 
  
 (* with TStatusPanel.create(self) do begin
  //parent
    width:= 200;
    alignment:= alleft;
  end;*)
 
 with TBitBtn.create(bfrm) do begin
   parent:= bfrm;
   setbounds(550,530,150,55)
   font.size:= 12;
   glyph.LoadFromResourceName(HINSTANCE,'CL_MPSTOP');
   mXButton(05,05,width, height,12,12,handle);
   caption:= '&Close App';
   onClick:= @closeButtonClick;
 end;
 with TBitBtn.Create(bfrm) do begin
   Parent:= bfrm;
   setbounds(230,530,150, 55);
   caption:= 'A&dd Node';
   font.size:= 12;
   glyph.LoadFromResourceName(getHINSTANCE,'CL_MPNEXT');
   mXButton(05,05,width, height,12,12,handle);
   onClick:= @BtnAddClick;
 end;
 with TBitBtn.Create(bfrm) do begin
   Parent:= bfrm;
   setbounds(390,530,150, 55);
   caption:= '&Delete Node';
   font.size:= 12;
   glyph.LoadFromResourceName(getHINSTANCE,'CL_MPPREV');
   mXButton(05,05,width, height,12,12,handle);
   onClick:= @RemoveClick;
 end;
 FirstTime:= true;
 
  (*with TStatusPanel.create(self) do begin
  //parent
    width:= 200;
    text:= 'status panel';
    alignment:= alleft;
  end;*)
  
  with TStatusBar.create(bfrm) do begin
    parent:= bfrm;
    simplepanel:= true;
    color:= clyellow;
    //align:= alleft;
    showhint:= true;
    hint:= 'this is box';
    //simpletext.font.size:= 12;
    simpletext:= 'this is status bar';
    //visible:= true;
    //width:= 200;
    //alignment:= alleft;
    //onclick:= 
  end;
  with TDateTimePicker.Create(bfrm) do begin
    parent:= bfrm;
    //color
    date;
    //time:= now;
    setbounds(5,540,150, 50);
    //calalignment:= albottom;
    onclick:= @clicktestbutton;
    //calcolors:= 
  end;
   with TMonthCalendar.Create(bfrm) do begin
    parent:= bfrm;
    //color
    date;
    //time:= now;
      setbounds(5,330,150, 50);
    //maxdate
    //calalignment:= albottom;
    onclick:= @clicktestbutton;
    //calcolors:= 
  end;
  with TCoolBar.create(bfrm) do begin
    //parent:= bfrm;
    vertical:= false;
    //onclick
    //Flipchildren(true);
    Free;
  end;
  
  //getbitmap
  //images:= TCustomImagelist.create(self);
  
  with TRichEdit.Create(bfrm) do begin
    parent:= bfrm;
    clear;
    setbounds(190,150,250,160);
    //findtext
    wordwrap:= true;
    color:= clteal;
    font.size:= 12;
    //Loadfromfile(ExePath+SAVEPATH);
    //PlainText
    scrollbars:= true;
    Lines.Add('This is {b super} real');
    Lines.LoadfromFile(ExePath+SAVEPATH);
    with SelAttributes do begin
      Color:= clGreen;
      Height:= 10;
      Style:= [fsBold]; // b
    end;
    //print
    //onclick
    //SetBounds
    ///align
    wanttabs:= true;
    onclick:= @clicktestbutton;
      //ondblclick
    //free;
  end;
end; 

procedure PrintList(Value: TStringList);
var
  I, Line, Pagenum: Integer;
begin
  //let's print
  //if Assigned(FOnBeginPrint) then
    //FOnBeginPrint(Self);
  line := 0;
  Printer.BeginDoc;
  Pagenum := 1;
  for I := 0 to Value.Count - 1 do begin
    //if Assigned(FOnProgress) then
      //FOnProgress(Self, I + 1, Value.Count);
    Line := Line + Printer.Canvas.TextHeight(Value[I]);
    if Line + Printer.Canvas.TextHeight(Value[I]) > Printer.PageHeight then begin
      Line := Printer.Canvas.TextHeight(Value[I]);
      Printer.NewPage;
      Inc(PageNum);
      //if Assigned(FOnNextPage) then
        //FOnNextPage(Self, PageNum);
    end;
    Printer.Canvas.TextOut(0, Line, Value[I]);
  end;
  Printer.EndDoc;
  //if Assigned(FOnFinishedPrint) then
    //FOnFinishedPrint(Self);
end;

function TDSAMessageForm_GetFormText: String;
var
  DividerLine, ButtonCaptions: string;
  I: Integer;
begin
  DividerLine:= StringOfChar('-', 27) + CrLf;
  for I:= 0 to maxform1.ComponentCount - 1 do
    if maxform1.Components[I] is TButton then
      ButtonCaptions:= ButtonCaptions + TButton(maxform1.Components[I]).Caption +
        StringOfChar(' ', 3);
  ButtonCaptions:= StringReplace(ButtonCaptions,'&','', [rfReplaceAll]);
  I:= maxform1.ComponentCount - 1;
  while (I > -1) and not (maxform1.Components[I] is TLabel) do
    Dec(I);
  Result := Format('%s%s%s%s%s%s%s%s%s%s', [DividerLine, maxform1.Caption, CrLf,
    DividerLine, TLabel(maxform1.Components[I]).Caption, CrLf, DividerLine, ButtonCaptions,
    CrLf, DividerLine]);
end;


  
  function maxcalcfunc(a: extended): extended;
  begin
    result:= cotan(a);
  end;  
  
  
function TimeStampInterval(StartStamp, EndStamp: TDateTime): integer;
var
  days: Integer;
  hour, min, s, ms: Word;
begin
  days := Trunc(EndStamp - StartStamp); // whole days
  DecodeTime(EndStamp - StartStamp, hour, min, s, ms);
  result := (((days * 24 + hour) * 60 + min) * 60 + s) * 1000 + ms;
end;

 
 var    myus: TUserfunction;
        aobj: TObject;
        //mylog: TFoLog;
        bitstyle: TBitmapstyle;
   UserSpaceAvail, TotalSpaceAvail, DiskSize: Comp; {disk size}

begin   //main of animationbox
   //InifileRead;
   ProcessMessagesON;
   getMaxBoxIni;
   writeln('Thread ID :'+intToStr(CurrentThreadID))
   writeln('Process ID :'+intToStr(CurrentProcessID))
   writeln('machine name is: '+getHostName)
   writeln('user name is: '+getUserName)
   osType:= Win32Type;
   writeln('OS Type is: '+intToStr(ord(osType)));
   mytimestamp:= GetFileCreationTime(exepath+'maxbox3.exe')
   writeln(DateTimeToStr(mytimestamp)+' for maXbox3 file')
   //SearchAndOpenDoc(ExtractFilePath(ParamStr(0))+'docs\maxbox_starter16.pdf')
   //ExecuteCommand('cmd','/k dir *.*')
   BitmapFormCreate(self);
   InitBitmapForm;
   FormDrawBitmap(Exepath+BACKMAP,10,10, bfrm.canvas);
   
   //bfrm.canvas.brush.bitmap.loadfromfile(Exepath+backmap);
   
   //bfrm.canvas.draw(300,200, getbitmapObject(Exepath+backmap));
   
    //Form1.Canvas.Brush.Bitmap := Bitmap;
    //Form1.Canvas.FillRect(Rect(0,0,100,100));
   //abmap:= getbitmapObject(Exepath+backmap);
   //GrayscaleBitmap(abmap);
   //bfrm.canvas.brush.bitmap:= abmap;

   bfrm.canvas.brush.bitmap:= getbitmapObject(Exepath+backmap);
   bfrm.Canvas.FillRect(Rect(400,300,100,100));
 
   //bfrm.canvas.top:= 200;
   //bfrm.canvas.brush.bitmap.width:= 300;
   //FormDrawBitmap(BITMAP2,540,10, bfrm.canvas);
   CurrencyFormat;
   //VarComplexToPolar
   //CheckSynchronize
    if isMultiThread then writeln('multi');
    //maXbox
    myus:= @maxcalcfunc;
    
    with TJvMathParser.create do begin
      //registeruserfunction('maxcalcfunc', myus);
      execute('4+6')
    end; 
    
    with TObject.Create do begin
      //cleanupinstance;
      //classname
    end;
    //TObject.instancesize
    with TPersistent.Create do begin
      //cleanupinstance;
      //classname
      writeln(getnamepath);
    end;
  
    with TComport.Create(self) do begin
      //cleanupinstance;
      //classname
      open;
      writeln('com handle '+inttostr(handle));
      codepage;
      buffer;
      writeln('of com port '+getnamepath);
      if connected then writeln(' com connect');
      close;
      Free;
    end;
  
    aobj:= TObject.Create;
    freeandnil2(aobj);
    //RIRegister_StGenLog_Routines
    //Function HexifyBlock( var Buffer, BufferSize : Integer) : string');
    //HexifyBlock( var Buffer, BufferSize : Integer) : string');
    //maxform1.CB1SCList.color:= clred;
    maxform1.mxNavigator.color:= clyellow;
    
    //JvFormLog
    with TJvLogFile.Create(self) do begin
      add('first','second','third');
     //parent:= bfrm;
     //showlog('maxbox');
     free;
    end;
    bitstyle:= bsCentered;
    //printimage(getbitmapObject(Exepath+backmap),bscentered); 
    writeln(inttostr(vk_back))
    writeln(inttostr(vk_F1))
    //formatmasktext
    //MaskGetMaskSave
    GetEnvironmentInfo;
    //FindFilesDlg(StartIn: string; SpecialFolder: TJvSpecialFolder; UseFolder: Boolean): Boolean;
    //FindFilesDlg(Exepath, sfPrograms, true);
    //getrandomstring
    //copyfile
    //CreateTempFile
    
    
    {DeleteVolumeLabel}
//function DeleteVolumeLabel(Drive : AnsiChar) : Cardinal;
{-Deletes an existing volume label on Drive. Returns 0 for success,
  or OS error code.}
   //DeleteVolumeLabel(Drive : AnsiChar) : Cardinal;

{EnumerateDirectories}
//procedure EnumerateDirectories(const StartDir : AnsiString; FL : TStrings; {!!.02}
  //                             SubDirs : Boolean;
    //                           IncludeItem : TIncludeItemFunc);
{-Retrieves the complete path name of directories on requested file
  system path.}
  //EnumerateDirectories
  
  writeln(DriveDelim) 

{EnumerateFiles}
//procedure EnumerateFiles(const StartDir : AnsiString; FL : TStrings;   {!!.02}
  //                       SubDirs : Boolean;
    //                     IncludeItem : TIncludeItemFunc);
{-Retrieves the complete path name of files in a requested file system path.}

  //EnumerateFiles
{FileHandlesLeft}
 //FileHandlesLeft(MaxHandles : Cardinal) : Cardinal;
{-Return the number of available file handles.}

{FileMatchesMask}
   //FileMatchesMask(const FileName, FileMask : AnsiString ) : Boolean;
{-see if FileName matches FileMask}

{FileTimeToStDateTime}
  //FileTimeToStDateTime(FileTime : LongInt) : TStDateTimeRec;
{-Converts a DOS date-time value to TStDate and TStTime values.}

{FindNthSlash}
  //FindNthSlash( const Path : AnsiString; n : Integer ) : Integer;
{ return the position of the character just before the nth slash }
  writeln('FindNthSlash '+inttostr(FindNthSlash(Exepath, 9)));

{FlushOsBuffers}
   //FlushOsBuffers(Handle : Integer) : Boolean;
{-Flush the OS buffers for the specified file handle.}

{GetCurrentUser}
  //GetCurrentUser : AnsiString;
{-Obtains current logged in username}

{GetDiskClass}
 //GetDiskClass(Drive : AnsiChar) : DiskClass;
{-Return the disk class for the specified drive.}

{GetDiskInfo}
  //GetDiskInfo(Drive : AnsiChar; var ClustersAvailable, TotalClusters,
    //                 BytesPerSector, SectorsPerCluster : Cardinal) : Boolean;
{-Return technical information about the specified drive.}

{GetDiskSpace}
 //GetDiskSpace(Drive : AnsiChar;
   //               var UserSpaceAvail  : Comp;           {space available to user}
     //             var TotalSpaceAvail : Comp;           {total space available}
       //           var DiskSize        : Comp) : Boolean;{disk size}
{-Return space information about the drive.}

 if GetDiskSpace('C',UserSpaceAvail,TotalSpaceAvail,DiskSize) then
     printF('UserSpaceAvail: %d TotalSpaceAvail: %d DiskSize: %d',
               [UserSpaceAvail div 1024,TotalSpaceAvail div 1024,DiskSize div 1024]);
{

{GetFileCreateDate}
 //GetFileCreateDate(const FileName : AnsiString) :
  //TDateTime;
{-Obtains file system time of file creation.}

{GetFileLastAccess}
 //StGetFileLastAccess(const FileName : AnsiString) :
  //TDateTime;
{-Obtains file system time of last file access.}

{GetFileLastModify}
 //GetFileLastModify(const FileName : AnsiString) :
  //TDateTime;
{-Obtains file system time of last file modification.}

{GetHomeFolder}
 //GetHomeFolder(aForceSlash : Boolean) : AnsiString;
{-Obtains the "Home Folder" for the current user}

{$IFNDEF CBuilder}
{GetLongPath}
 //GetLongPath(const APath : AnsiString) : AnsiString;
{-Returns the long filename version of a provided path.}
{$ENDIF}

{GetMachineName}
  //GetMachineName : AnsiString;
{-Returns the "Machine Name" for the current computer }
  //gethostname
{GetMediaID}
  //GetMediaID(Drive : AnsiChar; var MediaIDRec : MediaIDType) : Cardinal;
{-Get the media information (Volume Label, Serial Number) for the specified drive}

{GetParentFolder}
 //GetParentFolder(const APath : AnsiString; aForceSlash : Boolean) : AnsiString;
{-return the parent directory for the provided directory }

{GetShortPath}
 //GetShortPath(const APath : AnsiString) : AnsiString;
{-Returns the short filename version of a provided path.}

{GetSystemFolder}
 //GetSystemFolder(aForceSlash : Boolean) : AnsiString;
{-Returns the path to the Windows "System" folder".)

{GetTempFolder}
 //GetTempFolder(aForceSlash : boolean) : AnsiString;
{-Returns the path to the system temporary folder.}

{GetWindowsFolder}
 //StGetWindowsFolder(aForceSlash : boolean) : AnsiString;
{-Returns the path to the main "Windows" folder.}

{GetWorkingFolder}
 //GetWorkingFolder(aForceSlash : boolean) : AnsiString;
{-Returns the current working directory.}

{GlobalDateTimeToLocal}
 //GlobalDateTimeToLocal(const UTC: TStDateTimeRec; MinOffset: Integer): TStDateTimeRec; {!!.02}
{-adjusts a global date/time (UTC) to the local date/time}

{IsDirectory}
 //StIsDirectory(const DirName : AnsiString) : Boolean;
{-Return True if DirName is a directory.}

{IsDirectoryEmpty}
 //IsDirectoryEmpty(const S : AnsiString) : Integer;
{-checks if there are any entries in the directory}

{IsDriveReady}
 //IsDriveReady(Drive : AnsiChar) : Boolean;
{-determine if requested drive is accessible }

{IsFile}
 //IsFile(const FileName : AnsiString) : Boolean;
{-Determines if the provided path specifies a file.}

{IsFileArchive}
 //IsFileArchive(const S : AnsiString) : Integer;
{-checks if file's archive attribute is set}

{IsFileHidden}
 //IsFileHidden(const S : AnsiString) : Integer;
{-checks if file's hidden attribute is set}

{IsFileReadOnly}
  //IsFileReadOnly(const S : AnsiString) : Integer;
{-checks if file's readonly attribute is set}

{IsFileSystem}
 //IsFileSystem(const S : AnsiString) : Integer;
{-checks if file's system attribute is set}

{LocalDateTimeToGlobal}
 //LocalDateTimeToGlobal(const DT1: TStDateTimeRec; MinOffset: Integer): TStDateTimeRec; {!!.02}
{-adjusts a local date/time to the global (UTC) date/time}

{ReadVolumeLabel}
 //ReadVolumeLabel(var VolName : AnsiString; Drive : AnsiChar) : Cardinal;
{-Get the volume label for the specified drive.}

{SameFile}
 //SameFile(const FilePath1, FilePath2 : AnsiString; var ErrorCode : Integer) : Boolean;
{-Return True if FilePath1 and FilePath2 refer to the same physical file.}

{SetMediaID} {!!!! does not work on NT/2000 !!!!}
 //SetMediaID(Drive : AnsiChar; var MediaIDRec : MediaIDType) : Cardinal;
{-Set the media ID record for the specified drive.}

{SplitPath}
 //SplitPath(const APath : AnsiString; Parts : TStrings);
{-Splits the provided path into its component sub-paths}

{StDateTimeToFileTime}
 //StDateTimeToFileTime(const FileTime : TStDateTimeRec) : LongInt;  {!!.02}
{-Converts an TStDate and TStTime to a DOS date-time value.}

{StDateTimeToUnixTime}
 //StDateTimeToUnixTime(const DT1 : TStDateTimeRec) : Longint;   {!!.02}
{-converts a TStDateTimeRec to a time in Unix base (1970)}

{UnixTimeToStDateTime}
 //UnixTimeToStDateTime(UnixTime : Longint) : TStDateTimeRec;
{-converts a time in Unix base (1970) to a TStDateTimeRec}

{ValidDrive}
 //ValidDrive(Drive : AnsiChar) : Boolean;
{-Determine if the drive is a valid drive.}

{WriteVolumeLabel}
 //WriteVolumeLabel(const VolName : AnsiString; Drive : AnsiChar) : Cardinal;
{-Sets the volume label for the specified drive.}

End.   

------------------------------------------------
Windows crashed again. I am the Blue Screen of Death. No one hears your screams.
Three things are certain: Death, taxes, and lost data. Guess which has occurred.
There is no place like 127.0.0.1 

http://en.wikipedia.org/wiki/Sneakers_%281992_film%29

with WebOutline.Outline.Items do
  begin
    {The following example code for adding nodes came from the Delphi 7 Help
     for TTreeView. Apologies for lack of imagination.}

    Clear; { remove any existing nodes }
    MyTreeNode1:= Add(nil,ExtendFakeData('RootTreeNode0'));{ Add a root node }
    { Add a child node to the node just added }
    AddChild(MyTreeNode1,ExtendFakeData('ChildNode0'));

    {Add another root node}
    MyTreeNode2 := Add(MyTreeNode1, ExtendFakeData('RootTreeNode1'));
    {add a child }
    AddChild(MyTreeNode2,ExtendFakeData('ChildNode1'));

    {Reuse MyTreeNode2}
    { and add a child node to it}
    MyTreeNode2 := WebOutline.Outline.Items[3];
    AddChild(MyTreeNode2,ExtendFakeData('ChildNode1a'));

    {Add a sibling}
    Add(MyTreeNode2,ExtendFakeData('ChildNode1b'));

    {add another root node}
    Add(MyTreeNode1, ExtendFakeData('RootTreeNode2'));
  end;
end;

procedure RotateBitmap(var htmpBitmapDC: TBitmap; var lWidth : Longint;
                            var lHeight : Longint; lRadians : real; origmap: TBitmap);
var
         I,J : Longint;               // loop counter
         //htmpBitmapDC : Longint;    // DC of the new bitmap
         lSine,lCosine : extended;          // sine,cosine used in rotation
         X1,X2,X3,Y1,Y2,Y3 : Longint;     // used in calculating new bitmap dimensions
         lMinX,lMaxX,lMinY,lMaxY: Longint;  
         lNewWidth,lNewHeight : Longint;  // width of new bitmap
         lSrcX,lSrcY  : Longint;   // x,y pixel coord we are blitting from the source image
         myrect: TRect;
begin
   // create a compatible DC from the one just brought
   // compute the sine/cosinse of the radians used to // rotate this image
    //tbmpDC:= tbmp.handle;
   lSine := Sin(lRadians);
   lCosine := Cos(lRadians);
   // compute the size of the new bitmap being created
   X1 := Round(-lHeight * lSine);
   Y1 := Round(lHeight * lCosine);
   X2 := Round(lWidth * lCosine - lHeight * lSine);
   Y2 := Round(lHeight * lCosine + lWidth * lSine);
   X3 := Round(lWidth * lCosine);
   Y3 := Round(lWidth * lSine);
   // figure out the max/min size of the new bitmap
   lMinX := Min(0, Min(X1, Min(X2, X3)));
   lMinY := Min(0, Min(Y1, Min(Y2, Y3)));
   lMaxX := Max(X1, Max(X2, X3));
   lMaxY := Max(Y1, Max(Y2, Y3));
   // set the new bitmap width/height
   lNewWidth:= lMaxX - lMinX;
   lNewHeight:= lMaxY - lMinY;
   // create a new bitmap based upon the new width/height of the // rotated bitmap
   //hNewBitmap := CreateCompatibleBitmap(hBitmapDC, lNewWidth, lNewHeight);
   htmpBitmapDC.height:= lNewHeight;
   htmpBitmapDC.width:= lNewWidth;
   //myRect:= Rect(0,0,lwidth,lheight); 
   //bfrm.Canvas.BrushCopy(MyRect, Image1.Picture.Bitmap, MyRect, clred);
   For I:= 0 To lNewWidth do begin
     For J:= 0 To lNewHeight do begin
       lSrcX:= Round((J + lMinX) * lCosine + (I + lMinY) * lSine);
       lSrcY:= Round((I + lMinY) * lCosine - (J + lMinX) * lSine);
       If (lSrcX >= 0) And (lSrcX <= lWidth) And
          (lSrcY >= 0) And (lSrcY <= lHeight) Then begin
         BitBlt(htmpBitmapDC.canvas.handle,J,I,lnewheight,lnewwidth,origmap.canvas.handle,
                                 lSrcX,lSrcY, SRCCOPY);
        end;
     end;
  end;
  //Image1.Refresh; 
  lWidth:= htmpBitmapDC.width;
  lHeight:= htmpBitmapDC.height;
End;
      
procedure TForm1_RotateTest2(Sender: TObject);
var
 lRadians: real;
 tbmpDC, H,W, Degrees: longint;
 mybitmap: TBitmap;
 MyRect: TRect;
begin
  mybitmap:= TBitmap.create;
  mybitmap.loadfromfile(exepath+'examples\citymax.bmp')
  image1.width:= mybitmap.width;
  image1.height:= mybitmap.height;
  //Image1.Picture.BitMap.PixelFormat:= pf24bit; 
  Image1.Picture.BitMap:= mybitmap;
  //mybitmap.Free;
  Degrees:= 45;
  lRadians:= PI * Degrees / 180;
  W:= Image1.Picture.Width;
  H:= Image1.Picture.Height;
  //W:= Image1.Width;
  //H:= Image1.Height;
  mybitmap:= TBitmap.create;
  RotateBitmap(mybitmap, W, H, lRadians, Image1.Picture.Bitmap);
  myRect:= Rect(0,0,W,H); 
  //bfrm.Canvas.CopyRect(MyOther,mybitmap.Canvas,MyRect);
  Image1.Width:= W;
  Image1.Height:= H;
  Image1.Picture.Bitmap.Width:= W;
  Image1.Picture.Bitmap.Height:= H;
  //Image1.Picture.bitmap:= mybitmap;
  BitBlt(Image1.Picture.Bitmap.Canvas.Handle,0,0,W,H,mybitmap.canvas.handle,0,0,SRCCopy);
  //bfrm.Canvas.BrushCopy(MyRect, Image1.Picture.Bitmap, MyRect, clRed);
  //for j:= 1 to image1.height do
    //image1.Picture.Bitmap.Canvas.pixels[j,j]:= clred; //test line
  mybitmap.Free;
  Image1.Refresh; 
end;



procedure CurrencyFormat;
var fSettings: TFormatSettings;
begin
  GetLocaleFormatSettings(LOCALE_SYSTEM_DEFAULT, fSettings);
  writeln(fsettings.timeAMString);
  writeln(fsettings.longDateFormat);
  writeln(fsettings.shortDateFormat);
    //writeln(currtostrF
  writeln('currtostrFS 1234.56 formats with setting as = '+
             CurrToStrFS(1234.5678989, ffCurrency, 4, fSettings));
             writeln(FloatToStrF(1234.5678989, ffCurrency, 6, 6));
  writeln('currtostrFS and back as = '+
             CurrToStrFS(strToCurr('1234.5678989'), ffCurrency, 4, fSettings));
end; 

procedure maxcalc_demo;
begin
  printF('this is %.6f',[maXcalc('ln(2)+fact(388)+2!')]); 
  printF('this is %.6f',[maXcalc('(4!)^(3!)')]); 
  printF('this is %.6f',[maXcalc('4!+4!')]); 
  printF('this is %.6f',[maXcalc('log(22)')]); 
  printF('this is logN %.6f',[maXcalc('2%256')]);
  writeln('ln(e): '+floattostr(maXcalc('ln(e)')))
  writeln(floattostr(maXcalc('e+10^6')))
  printF('addition theorem %.18f ',[maXcalc('sin(2.5/2)')])
  printF('addition theorem %.18f ',[maXcalc('sqrt(1/2*(1-cos(2.5)))')])
  printF('addition theorem2 %22.18f ',[maXcalc('cos(2.5/2)')])
  printF('addition theorem2 %22.18f ',[maXcalc('sqrt(1/2*(1+cos(2.5)))')])
  maXcalcF('2%256+2^10');
end; 

50000  = 0.693137180659968
100000 = 0.693142180584982
500000 = 0.693146180561005
10^6   = 0.693146680560255
5*10^6 = 0.693147080560068
50*10^6= 0.693147170560399    //Runtime: 0:28:22.422
ln(2)  = 0.693147180559945

(* zeta:= 0;
     for i:= 1 to 50000 do 
       if i mod 2 = 0 then
         zeta:= zeta - 1/i else
         zeta:= zeta + 1/i;
       writeln('harmonic alternate to ln(2): '+floattostr(zeta))  
       writeln(floattostr(maxcalc('ln(2)')))
       writeln(floattostr(ln2))    *)
   

type
  //PThreadSortArray = ^TThreadSortArray;
  //TThreadSortArray = array[0..MaxInt div SizeOf(Integer) - 1] of Integer;
  TSortArray =  array[1..ARRSIZE] of Integer;


  TSortThread = class(TThread)
  strict private
    FBox: TPaintBox;
    //FSortArray: PThreadSortArray;
    FSortArray: TSortArray;
    FSize: Integer;
    FA, FB, FI, FJ: Integer;
    Fbolthslowmotion: boolean;
    procedure DoVisualSwap;
    procedure Setbolthslowmotion(const Value: boolean);
  protected
    procedure Execute; override;
    procedure VisualSwap(A, B, I, J: Integer);
    procedure Sort(var A: array of Integer); virtual; abstract;
  public
    constructor Create(Box: TPaintBox; var SortArray: TSortArray);
    property  bolTHslowmotion: boolean read Fbolthslowmotion write Setbolthslowmotion;

  end;


procedure SIRegister_TThreadSortForm(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TForm', 'TThreadSortForm') do
  with CL.AddClassN(CL.FindClass('TForm'),'TThreadSortForm') do
  begin
    RegisterProperty('BubbleSortBox', 'TPaintBox', iptrw);
    RegisterProperty('SelectionSortBox', 'TPaintBox', iptrw);
    RegisterProperty('QuickSortBox', 'TPaintBox', iptrw);
    RegisterProperty('Bevel1', 'TBevel', iptrw);
    RegisterProperty('Bevel2', 'TBevel', iptrw);
    RegisterProperty('Bevel3', 'TBevel', iptrw);
    RegisterProperty('StartBtn', 'TButton', iptrw);
    RegisterProperty('Label1', 'TLabel', iptrw);
    RegisterProperty('Label2', 'TLabel', iptrw);
    RegisterProperty('Label3', 'TLabel', iptrw);
    RegisterProperty('BitBtn1slowmotion', 'TBitBtn', iptrw);
    RegisterMethod('Procedure StartBtnClick( Sender : TObject)');
    RegisterMethod('Procedure BubbleSortBoxPaint( Sender : TObject)');
    RegisterMethod('Procedure SelectionSortBoxPaint( Sender : TObject)');
    RegisterMethod('Procedure QuickSortBoxPaint( Sender : TObject)');
    RegisterMethod('Procedure FormCreate( Sender : TObject)');
    RegisterMethod('Procedure FormDestroy( Sender : TObject)');
    RegisterMethod('Procedure FormKeyPress( Sender: TObject; var Key: Char)');
    RegisterMethod('Procedure BitBtn1slowmotionClick( Sender : TObject)');
    RegisterMethod('Procedure ThreadDone( Sender : TObject)');
    RegisterProperty('mouse', 'boolean', iptrw);
  end;
end;




***********************************Thread Class *****************************
  TThread = class
  private
{$IFDEF MSWINDOWS}
    FHandle: THandle;
    FThreadID: THandle;
{$ENDIF}
{$IFDEF LINUX}
    // ** FThreadID is not THandle in Linux **
    FThreadID: Cardinal;
    FCreateSuspendedSem: TSemaphore;
    FInitialSuspendDone: Boolean;
{$ENDIF}
    FCreateSuspended: Boolean;
    FTerminated: Boolean;
    FSuspended: Boolean;
    FFreeOnTerminate: Boolean;
    FFinished: Boolean;
    FReturnValue: Integer;
    FOnTerminate: TNotifyEvent;
    FSynchronize: TSynchronizeRecord;
    FFatalException: TObject;
    procedure CallOnTerminate;
    class procedure Synchronize(ASyncRec: PSynchronizeRecord; QueueEvent: Boolean = False); overload;
{$IFDEF MSWINDOWS}
    function GetPriority: TThreadPriority;
    procedure SetPriority(Value: TThreadPriority);
{$ENDIF}
{$IFDEF LINUX}
    // ** Priority is an Integer value in Linux
    function GetPriority: Integer;
    procedure SetPriority(Value: Integer);
    function GetPolicy: Integer;
    procedure SetPolicy(Value: Integer);
{$ENDIF}
    procedure SetSuspended(Value: Boolean);
  protected
    procedure CheckThreadError(ErrCode: Integer); overload;
    procedure CheckThreadError(Success: Boolean); overload;
    procedure DoTerminate; virtual;
    procedure Execute; virtual; abstract;
    procedure Queue(AMethod: TThreadMethod); overload;
    procedure Synchronize(AMethod: TThreadMethod); overload;
    property ReturnValue: Integer read FReturnValue write FReturnValue;
    property Terminated: Boolean read FTerminated;
  public
    constructor Create(CreateSuspended: Boolean);
    destructor Destroy; override;
    procedure AfterConstruction; override;
    procedure Resume;
    procedure Suspend;
    procedure Terminate;
    function WaitFor: LongWord;
    class procedure Queue(AThread: TThread; AMethod: TThreadMethod); overload;
    class procedure RemoveQueuedEvents(AThread: TThread; AMethod: TThreadMethod);
    class procedure StaticQueue(AThread: TThread; AMethod: TThreadMethod);
    class procedure Synchronize(AThread: TThread; AMethod: TThreadMethod); overload;
    class procedure StaticSynchronize(AThread: TThread; AMethod: TThreadMethod);
    property FatalException: TObject read FFatalException;
    property FreeOnTerminate: Boolean read FFreeOnTerminate write FFreeOnTerminate;
{$IFDEF MSWINDOWS}
    property Handle: THandle read FHandle;
    property Priority: TThreadPriority read GetPriority write SetPriority;
{$ENDIF}
{$IFDEF LINUX}
    // ** Priority is an Integer **
    property Priority: Integer read GetPriority write SetPriority;
    property Policy: Integer read GetPolicy write SetPolicy;
{$ENDIF}
    property Suspended: Boolean read FSuspended write SetSuspended;
{$IFDEF MSWINDOWS}
    property ThreadID: THandle read FThreadID;
{$ENDIF}
{$IFDEF LINUX}
    // ** ThreadId is Cardinal **
    property ThreadID: Cardinal read FThreadID;
{$ENDIF}
    property OnTerminate: TNotifyEvent read FOnTerminate write FOnTerminate;
  end;
  
  
8 Tipps für die richtige Business-Software-Auswahl!

Die Auswahl einer Business Software lässt verschiedene Lösungswege zu, selten gibt es ein klares “Falsch”. Einige abenteuerliche Ansätze die geradewegs und unbeirrbar zu den bekannten Projektschwierigkeiten führen, sollte man aber vermeiden. Unsere 8 Tipps für die Auswahl der Business-Software-Lösung helfen Ihnen, die richtige Lösung sowie den passenden Software-Partner zu finden:

    Ganzes Angebot!
    Gehen Sie von der ganzen Angebotspalette aus und entscheiden Sie sich nicht zu schnell für einen Anbieter.
    Prozesse!
    Analysieren Sie zuerst die Prozesse und definieren Sie dann die funktionale Abdeckung der Anforderungen.
    Zukunft!
    Versuchen Sie auch die Anpassungen des Systems an zukünftige Bedürfnisse abzuschätzen.
    Potenzial des Partners!
    Beurteilen Sie das Potenzial des Systemlieferanten.
    Referenzen!
    Besuchen Sie Referenzkunden mit ähnlichen Anforderungen. Verlassen Sie sich nicht einfach auf Aussagen von Kollegen und Partnern.
    Drum prüfe wer sich bindet?
    Hinter der evaluierten Lösung stehen immer auch Menschen mit denen Sie in den nächsten zehn Jahren zu tun haben. Beziehen Sie daher Aspekte wie «Sympathie und Chemie» in die Überlegungen ein.
    Ressourcen!
    Nehmen Sie sich Zeit! Die Einführung eines ERP-Systems braucht Zeit und das Management muss voll und ganz hinter dem Projekt stehen und die nötigen Ressourcen dazu freigeben.
    Schulung, Schulung, Schulung!
    Und ganz wichtig: Unterschätzen Sie nicht die Anwender-Schulung. Sie ist wichtig und braucht Zeit!

 
http://www.hitekdev.com/delphi/BITMAPANIMATION.html

void draw() 
{
  fill(0, 2);
  rect(0, 0, width, height);
  pct += step;
  if (pct < 1.0) {
    x = beginX + (pct * distX);
    y = beginY + (pow(pct, exponent) * distY);
  }
  fill(255);
  ellipse(x, y, 20, 20);
}