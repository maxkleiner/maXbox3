{****************************************************************
 *
 * Project  : EKON18 System Information Series
 * App Name:  136_sysinformation_dll, #locs=502
 * Purpose  : Demonstrates of 3 imported functions from Windows API
 * History  : system demo for mX3 beta, container == component(class) + service(intf)
 * http://www.softwareschule.ch/download/patternposter.pdf
 ****************************************************************}
program SysDLLTestFrame;

const kernelX = 'kernel32.dll';

function  MyMessageBeep(para: integer): byte;
     external 'MessageBeep@user32.dll stdcall';  

function MyGetTickCount: Longint;
  external 'GetTickCount@kernel32.dll stdcall';
 
procedure MySleep(Milliseconds: Cardinal);
  //external 'Sleep@'+kernelX+' stdcall';
  external 'Sleep@kernel32.dll stdcall';

function PlayMetaFile(DC: HDC; MF: HMETAFILE): BOOL; 
                                    //stdcall;
  external 'PlayMetaFile@gdi32.dll stdcall';

//function mygetColorDialog: Longint;
  //external 'GetColorDialog@colorproject1.dll stdcall';

 
var
  mytimestamp: TDateTime;
  E: Extended;
  songpath, command1, command2: string;

function OctToDec(OctStr: string): string;
var
  DecNum: single;
  i: byte;
  aError: Boolean;
  charset: set of char;
begin
  DecNum:=0;
  aError:=False;
  charset:= ['1','2','3','4','5','6','7']
  for i:=Length(OctStr) downto 1 do begin
    if OctStr[i] in charset then begin
      aError:= True;
      ShowMessage('This is not octal number');
      Break;
    end;
    DecNum:= DecNum+StrToInt(OctStr[i])*Power(8, Length(OctStr)-i);
  end;
  if not aError then
    Result:= FloatToStr(DecNum)
  else Result:='';
end;

function TColorDialogDLL: integer;
begin
  with TColorDialog.create(self) do begin
     try
       execute
       result:= color;
     finally
       free
     end
  end;       
end;

procedure ColorPattern;
var col: Tcolor;
begin
  with TForm.create(self) do try
    with TColorDialog.create(self) do 
    try
      execute
      col:= color;
    finally
      free
    end;
    color:= col; 
    showModal
  finally
    free;
  end;
end;   

procedure ColorPattern2;
var frm: TForm;
begin
  frm:= TForm.create(self)
  with TColorDialog.create(frm) do try
    execute
    frm.color:= color;
    frm.showModal
  finally
    frm.Release;
  end;
end;   


 

procedure PNGTester;
var png: TLinearBitmap; //TPNGLoader; //TLinearBitmap; //TPortableNetworkGraphic;
    fimage: Timage;
    afrm: Tform;
begin
  png:= TLinearBitmap.Create; //TPNGLoader.Create;
  try
  // RegisterMethod('Procedure LoadFromFile( const FileName, FileType : string; Bitmap : TLinearBitmap)');
    //png.LoadFromFile(Exepath+'golgraph16.png');
    if not fileExists(Exepath+'golgraph37.png') then
      if DownloadFile('http://www.softwareschule.ch/images/golgraph37.png',
                                Exepath+'golgraph37.png') then 
      ShowMessage('We had to Download of golgraph37.png succesful!');
      Sleep(500);
    png.LoadFromFile(Exepath+'golgraph37.png');
  
    fimage:= TImage.create(self);
    afrm:= TForm.create(self)
    with afrm do begin
      setbounds(0,0,545,550);
      fimage.parent:= afrm;
      //fimage.picture.loadfromfile(Exepath+'golgraph42.png');
      //fimage.picture.loadfromfile(Exepath+'\examples\citymax.bmp');
      png.Assignto(fimage.picture.bitmap);
      writeln(inttostr(png.width)) 
      fimage.AutoSize:= True;
      show;
      //canvas.brush.bitmap:= NIL;
      //png.Assignto(canvas.brush.bitmap);
      //Canvas.StretchDraw(Bounds(50,500,50,50),png);
    end;  
  finally
    png.Free;
    //fimage.Free;
  end;
end;


Procedure DateTimeExample;
Var
  S, S1 : String;
begin
  {Time, Date, and Now are all basically interchangable.}
  {They all return a DateTime value.}
  S1:=DateToStr(Now2);
  Case DayOfWeek(Date) of
     1: S:='Sunday';
     2: S:='Monday';
     3: S:='Tuesday';
     4: S:='Wednesday';
     5: S:='Thursday';
     6: S:='Friday';
     7: S:='Saturday';
  Else S:='Noneday';
  End; {Case}
  writeln(S+' '+S1+' '+TimeToStr(Time));
end;

procedure SIRegister_JclTD32Test;
//var adw: TDataRecord4; DWordArray;
var QueryDb1: TQuery;
  fStatusMin: byte;
begin
 //Borland32BitSymbolFileSignatureForDelphi','LongWord').SetUInt( $39304246);
 //Borland32BitSymbolFileSignatureForBCB','LongWord').SetUInt( $41304246);
  //PJclTD32FileSignature', '^TJclTD32FileSignature // will not work');
  //TJclTD32FileSignature', 'record Signature : DWORD; Offset : DWOR'
   //+'D; end');
 //SUBSECTION_TYPE_MODULE','LongWord').SetUInt( $120);
 {SUBSECTION_TYPE_TYPES','LongWord').SetUInt( $121);
 SUBSECTION_TYPE_SYMBOLS','LongWord').SetUInt( $124);
 SUBSECTION_TYPE_ALIGN_SYMBOLS','LongWord').SetUInt( $125);
 SUBSECTION_TYPE_SOURCE_MODULE','LongWord').SetUInt( $127);
 SUBSECTION_TYPE_GLOBAL_SYMBOLS','LongWord').SetUInt( $129);
 SUBSECTION_TYPE_GLOBAL_TYPES','LongWord').SetUInt( $12B);
 SUBSECTION_TYPE_NAMES','LongWord').SetUInt( $130);
  PDirectoryEntry', '^TDirectoryEntry // will not work'); }
  //TDirectoryEntry', 'record SubsectionType : Word; ModuleIndex : W'
   //+'ord; Offset : DWORD; Size : DWORD; end');
  //PDirectoryHeader', '^TDirectoryHeader // will not work');
  //PSegmentInfo', '^TSegmentInfo // will not work');
  //TSegmentInfo','record Segment: Word;Flags:Word; Offset:DWORD; Size: DWORD; end');
  //PSegmentInfoArray', '^TSegmentInfoArray // will not work');
  //PModuleInfo', '^TModuleInfo // will not work');
  //PLineMappingEntry', '^TLineMappingEntry // will not work');
  {TOffsetPair', 'record StartOffset : DWORD; EndOffset : DWORD; end');
  POffsetPairArray', '^TOffsetPairArray // will not work');
  PSourceFileEntry', '^TSourceFileEntry // will not work');
  PSourceModuleInfo', '^TSourceModuleInfo // will not work');
  PGlobalTypeInfo', '^TGlobalTypeInfo // will not work');}
 {SYMBOL_TYPE_COMPILE','LongWord').SetUInt( $0001);
 SYMBOL_TYPE_REGISTER','LongWord').SetUInt( $0002);
 SYMBOL_TYPE_CONST','LongWord').SetUInt( $0003);
 SYMBOL_TYPE_UDT','LongWord').SetUInt( $0004);
 SYMBOL_TYPE_SSEARCH','LongWord').SetUInt( $0005);
 SYMBOL_TYPE_END','LongWord').SetUInt( $0006);
 SYMBOL_TYPE_SKIP','LongWord').SetUInt( $0007);
 SYMBOL_TYPE_CVRESERVE','LongWord').SetUInt( $0008);
 SYMBOL_TYPE_OBJNAME','LongWord').SetUInt( $0009);
 SYMBOL_TYPE_BPREL16','LongWord').SetUInt( $0100);
 SYMBOL_TYPE_LDATA16','LongWord').SetUInt( $0101);
 SYMBOL_TYPE_GDATA16','LongWord').SetUInt( $0102);
 SYMBOL_TYPE_PUB16','LongWord').SetUInt( $0103);
 SYMBOL_TYPE_LPROC16','LongWord').SetUInt( $0104);
 SYMBOL_TYPE_GPROC16','LongWord').SetUInt( $0105);
 SYMBOL_TYPE_THUNK16','LongWord').SetUInt( $0106);
 SYMBOL_TYPE_BLOCK16','LongWord').SetUInt( $0107);
 SYMBOL_TYPE_WITH16','LongWord').SetUInt( $0108);
 SYMBOL_TYPE_LABEL16','LongWord').SetUInt( $0109);
 SYMBOL_TYPE_CEXMODEL16','LongWord').SetUInt( $010A);
 SYMBOL_TYPE_VFTPATH16','LongWord').SetUInt( $010B);
 SYMBOL_TYPE_BPREL32','LongWord').SetUInt( $0200);
 SYMBOL_TYPE_LDATA32','LongWord').SetUInt( $0201);
 SYMBOL_TYPE_GDATA32','LongWord').SetUInt( $0202);
 SYMBOL_TYPE_PUB32','LongWord').SetUInt( $0203);
 SYMBOL_TYPE_LPROC32','LongWord').SetUInt( $0204);
 SYMBOL_TYPE_GPROC32','LongWord').SetUInt( $0205);
 SYMBOL_TYPE_THUNK32','LongWord').SetUInt( $0206);
 SYMBOL_TYPE_BLOCK32','LongWord').SetUInt( $0207);
 SYMBOL_TYPE_WITH32','LongWord').SetUInt( $0208);
 SYMBOL_TYPE_LABEL32','LongWord').SetUInt( $0209);
 SYMBOL_TYPE_CEXMODEL32','LongWord').SetUInt( $020A);}
 //SYMBOL_TYPE_VFTPATH32','LongWord').SetUInt( $020B);
  //TSymbolProcInfo', 'record pParent : DWORD; pEnd : DWORD; pNext :'
   //+' DWORD; Size : DWORD; DebugStart : DWORD; DebugEnd : DWORD; Offset : DWORD'
   //+'; Segment : Word; ProcType : DWORD; NearFar : Byte; Reserved : Byte; NameI'
   //+'ndex : DWORD; end');
  //PSymbolInfo', '^TSymbolInfo // will not work');
  //TSymbolInfo', 'record Size : Word; SymbolType : Word; end');
  //PSymbolInfos', '^TSymbolInfos // will not work');
  {SIRegister_TJclModuleInfo(CL);
  SIRegister_TJclLineInfo(CL);
  SIRegister_TJclSourceModuleInfo(CL);
  SIRegister_TJclSymbolInfo(CL);
  SIRegister_TJclProcSymbolInfo(CL);
  CL.AddClassN(CL.FindClass('TOBJECT'),'TJclLocalProcSymbolInfo');
  CL.AddClassN(CL.FindClass('TOBJECT'),'TJclGlobalProcSymbolInfo');
  SIRegister_TJclTD32InfoParser(CL);
  SIRegister_TJclTD32InfoScanner(CL);
  SIRegister_TJclPeBorTD32Image(CL);}
  
  with QueryDb1 do begin
                         Close;
                         Sql.Clear;
    Sql.Add(format('Select min(Status) from AufATB where AuftragsNr=%d',[it]));
                         Open;
                         fStatusMin:=QueryDB1.Fields[0].AsInteger;
                         Close;
                    end;

end;

function GetTableName(const AField: TField): string;
begin
  if AField.Origin <> '' then
  begin
    Result := AField.Origin;
    Delete(Result, Pos('.', Result) + 1, Length(Result));
  end
  else
    Result := '';
end;

function GetFieldName(const AField: TField): string;
begin
  if AField.Origin <> '' then
  begin
    Result := AField.Origin;
    Delete(Result, 1, Pos('.', Result));
    if Result = '' then
      Result := AField.FieldName;
  end
  else
    Result := AField.FieldName;
end;



procedure TestDebug0(Sender: TObject);
var
i : integer;
t : tdatetime;
 a : string;
 b : integer;
begin
   t := now();
   a:= 'A';
   for i:=0 to 240000 do begin
   try
     b:= strtoint(a);
   except
   end;
  end;
   writeln('Debug test runtime: '+TimeToStr(Now()-t));
end;


procedure TestDebug1(Sender: TObject);
var
i : integer;
t : tdatetime;
 a : string;
 b : integer;
begin
   t := now();
   a:= 'A';
   for i:=0 to 240000 do begin
   if a <> 'A' then begin
   try
     b:= strtoint(a);
   except
   end;
   end else
    b:= 0;
  end;
   writeln('Debug test runtime: '+TimeToStr(Now()-t));
end;

procedure TestDebug2(Sender: TObject);
var
i : integer;
t : tdatetime;
 a : string;
 b : integer;
begin
   t := now();
   a:= 'A';
   for i:=0 to 240000 do begin
   try
     b:= strtointdef(a,0);
   except
   end;
  end;
   writeln('Debug test runtime: '+TimeToStr(Now()-t));
end;

procedure Messageloop(messart: word);
var amsg: tmsg;
    winh: hwnd;
    param1: word;
    param2: longint;
    //7winclass: TWndClass;
    acust: TCustomMemoryStream;
begin
  while getmessage(amsg,0,0,0) do begin
    translatemessage(amsg)
    dispatchmessage(amsg)
  end;  
  showwindow(winh, cmdshow)  
  updatewindow(winh)
  case messart of 
    wm_destroy: begin
                postQuitMessage(0);
                Exit;
                end;
  end;
  //w_createwindow
  defwindowproc(winh, messart, param1, param2)               
end;

  //TODO: check C:\maXbook\scholz\cruzer_micro_RemovableDisk\SASJeurink\Datev
  //transfer the App to a LED Matrix!
  

begin
  writeln(Format('Pi starts off as %.15f', [E]));
  dateTimeExample;
  writeln('machine name is: '+getHostName)
  writeln('user name is: '+getUserName)
  mytimestamp:= GetFileCreationTime(exepath+'maxbox3.exe')
  writeln(datetimetoStr(mytimestamp)+' Creation Date of maXbox3')
  writeln('oct to dec '+(OcttoDec('888')))
  writeln('tick count from func ' +IntToStr(GetTickCount));
  writeln('tick count from api   ' +IntToStr(MyGetTickCount));
  
  {for it:= 2 to 10 do begin
    MyMessageBeep(it*10);
    MySleep(1000);
  end;}  
  
  //QuickSort
  //HeapSort
  //QuickSelect
  //ForceInBox
  //RoundPoint
  //ColorTransform
  //TMatrix3x3
  //TCustomMemoryStream
  
  
  //this
  //Heavy Testing - most pitfalls : Case Sensitiv! , static linking linux, and in case of win64 dll
  
  //ExecuteShell('cmd','/c rundll32.exe shell32.dll Control_RunDLL')
  //ExecuteShell('cmd','/c rundll32.exe income.dll _SayHello2')
  //RunDll32.exe msrating.dll,RatingSetupUI
  //ExecuteShell('cmd','/c rundll32.exe msrating.dll RatingSetupUI')
  //also Applet!
  //ExecuteShell('cmd','/c rundll32.exe shell32.dll Control_RunDLL wscui.cpl')
  //ExecuteShell('cmd','/c tasklist /m /fi "imagename eq rundll32.exe"');
  
  
  {songpath:= Exepath+'examples\';
  command1:= 'play "'+songpath+'maxbox.wav"';
  command2:= 'play "'+songpath+'moon.wav"';
  SendMCICommand('open waveaudio shareable');
  SendMCICommand(command1);
  SendMCICommand(command2);
  SendMCICommand(command1);
  SendMCICommand('close waveaudio'); }
  
  //writeln(inttostr(TColorDialogDLL));
   {it:= TColorDialogDLL;
   with TForm.create(self) do begin
     try
     color:= it;
     showmodal
     finally
     free;
   end; 
   end;} 
    //pNGTester;
    //ColorPattern;
    //ColorPattern2;
    //TestDebug0(self)
    TestDebug1(self)
    TestDebug2(self)
    
    //CreateWindowStation
    //CreateWindowEx
    //IsWindow
    //IsChild
    // ShowWindow
      //AnimateWindow
      //ShowWindowAsync(23,1)
      //FlashWindow
      //UpdateLayeredWindow
      //TFlashWInfo
        //FlashWindowEx
        //ShowOwnedPopups
          //OpenIcon
         // CloseWindow
           //MoveWindow
          //  SetWindowPos
          //BeginDeferWindowPos
            //GetWindowPlacement
            //DeferWindowPos
         //   IsWindowVisible
              //AnyPopup
              //  BringWindowToTop
      //          IsZoomed
      //DefDlgProc GetDialogBaseUnits GetDlgCtrlID
        //CallMsgFilter     
        //UOpenClipboard   
        //GetClipboardViewer//GetClipboardSequenceNumber
       //OemToChar / EmptyClipboard //ChangeClipboardChain        
        //GetOpenClipboardWindow   
       //mouse_event //keybd_event //CharToOem
         //OemKeyScan//OemToChar  
        //GetKeyboardState //GetKBCodePage//GetActiveWindow// SetFocus 
     //TInput //tagHARDWAREINPUT     
      //GetLastInputInfo//SendInput
      //ReleaseCapture //MsgWaitForMultipleObjects //GetInputState
      //GetWindow // GetSystemMetrics
     //LockWindowUpdate //ValidateRgn RedrawWindow //GetWindowDC //WindowFromDC //UpdateWindow
    //GetNextWindow // GetTopWindow //GetWindowTask //ScrollWindow
     //GetSysColor //FindWindow //GetWindowThreadProcessId //SetScrollPos //ScrollDC
     //IsValidCodePage
     //TSerialKeys //GetGuiResources
     //ChangeDisplaySettings
     //ERROR_IO_DEVICE 
     //LoadBitmap//TGUIThreadInfo
     //GetGUIThreadInfo
     //GetWindowModuleFileName
      //GetCommandLine //GetAncestor
     // RealChildWindowFromPoint // GetComboBoxInfo
    //GetFileInformationByHandle //LoadResource //copyimage LoadImage
    //loadbitmap SetEnvironmentVariable //GetStdHandle
    //SetProcessShutdownParameters
    //GetEnvironmentVariable //OutputDebugString //FindResourceEx //GetProcessVersion
    //CreatePipe SetSystemTimeAdjustment  //FormatMessage 
    //TransmitCommChar //SetupComm //lstrcmp
    //SetProcessWorkingSetSize //GetProcessWorkingSetSize SetProcessAffinityMask //GetProcessTimes
   // GetThreadContext //TContext //SetLastError //CreateIoCompletionPort //GetExitCodeProcess
  //SetErrorMode //DebugBreak SuspendThread
  //StringToFontStyles
  //FontStylesToString(Styles: TFontStyles): string;
 //FontToString(Font: TFont): string;
 //StringToFont(const Str: string; Font: TFont);
 //RectToStr(Rect: TRect): string;
 //StrToRect(const Str: string; const Def: TRect): TRect;
 // renamwe PointToStr(P: TPoint): string;
 //&//  rename StrToPoint(const Str: string; const Def: TPoint): TPoint;

 //DefProfileName: string;
 //DefLocalProfileName: string;
    
end.

to make it more reponsive to the initialization
these are real closures they capture state and pass the code block
how long things take   
here is essentially whats going on
counter is a shared ressource
synchronize is a form of serialization
critical section is a general blocking mechanism
waitfor does not timeout
what does the task do - its up to you!
just take a pebble and cast it to the see

*******************************************************
There is no place like 127.0.0.1 
ref:
http://windows7tips.com/rundll32-vista-windows-7.html

alias name of a dll: 


 PlayMetaFile(DC: HDC; MF: HMETAFILE): BOOL; stdcall;
function PaintRgn(DC: HDC; RGN: HRGN): BOOL; stdcall;
function PolyPolygon(DC: HDC; var Points; var nPoints; p4: Integer):
  BOOL; stdcall;
function PtInRegion(RGN: HRGN; p2, p3: Integer): BOOL; stdcall;

Then, in the implementation portion, instead of providing each function's code, the unit refers to the external definition in a DLL:

const 
  gdi32 = 'gdi32.dll';
   
function PlayMetaFile; external gdi32 name 'PlayMetaFile';
function PaintRgn; external gdi32 name 'PaintRgn';
function PolyPolygon; external gdi32 name 'PolyPolygon';
function PtInRegion; external gdi32 name 'PtInRegion';

//$(LazarusDir)\lcl;$(LazarusDir)\lcl\interfaces\$(LCLWidgetType)

	Note 	
    {
Windows.PAS makes heavy use of the {$EXTERNALSYM identifier} directive. This directive} 
has little to do with Delphi itself; it applies to C++Builder. The symbol prevents the corresponding Delphi symbol from appearing in the C++ translated header file. This action helps keep the Delphi and C++ identifiers in synch, so that code can be shared between the two languages.


User Accounts
RunDll32.exe shell32.dll,Control_RunDLL nusrmgr.cpl

Unplug/Eject Hardware
RunDll32.exe shell32.dll,Control_RunDLL hotplug.dll

Windows Security Center
RunDll32.exe shell32.dll,Control_RunDLL wscui.cpl


A DLL uses the PE executable format, and it's not too tricky to read that information out of the file.

See this MSDN article on the PE File Format for an overview. You need to read the MS-DOS header, then read the IMAGE_NT_HEADERS structure. This contains the IMAGE_FILE_HEADER structure which contains the info you need in the Machine member which contains one of the following values

    IMAGE_FILE_MACHINE_I386 (0x014c)
    IMAGE_FILE_MACHINE_IA64 (0x0200)
    IMAGE_FILE_MACHINE_AMD64 (0x8664)

This information should be at a fixed offset in the file, but I'd still recommend traversing the file and checking the signature of the MS-DOS header and the IMAGE_NT_HEADERS to be sure you cope with any future changes. 
http://stackoverflow.com/questions/495244/how-can-i-test-a-windows-dll-to-determine-if-it-is-32bit-or-64bit

The structure of a script is as follows (keywords are shown in ALLCAPS bold): 

PROGRAM

CONST 

<Constant declarations> 
TYPE 

<Type declarations> 
VAR 

<Variable declarations> 
BEGIN 

<Executable statements> 
END. 
 

Note that: 
The main code must be within the begin and end. keywords. 
All statements in the script use the semicolon ";" as terminator. Only the last statement (END.) uses a dot as terminator. 


function BinToOct(BinStr: string): string;
var
  i: Integer;
  OctPart: single;
  LastPart, OctStr: string;
  Error: Boolean;
begin
  Error:=False;
  OctStr:='';
  case Length(BinStr) mod 3 of
    1: BinStr:='00'+BinStr;
    2: BinStr:='0'+BinStr;
  end;

  while Length(BinStr)>0 do
  begin
    LastPart:=Copy(BinStr, Length(BinStr)-2, 3);
    Delete(BinStr, Length(BinStr)-2, 3);
    OctPart:=0;
    for i:=1 to 3 do
      if not ((LastPart[i] ='1') or (LastPart[i] ='0')) then begin
        ShowMessage('This is not binary number');
        Error:=True;
        Break;
      end
      else
        OctPart:=OctPart+StrToInt(LastPart[i])*Power(2, 3-i);
    OctStr:=OctStr+FloatToStr(OctPart);
  end;
  Result:='';
  if Error<>True then begin
    for i:=1 to Length(OctStr) do
      Result:=Result+OctStr[Length(OctStr)-i+1];
    while (Result[1]='0') and (Length(Result)>1) do
      Delete(Result, 1, 1);
  end;
end;

http://www.techsupportalert.com/content/how-windows7-vista64-support-32bit-applications.htm

 WOW64 emulates 32-bit Windows

Under Windows 64-bit, 32-bit applications run on top of an emulation of a 32-bit operating system that is called Windows 32-bit on Windows 64-bit, or WOW64 for short.  WOW64 intercepts all operating system calls made by a 32-bit application.

For each operating system call made, WOW64 generates native 64-bit system calls, converting 32-bit data structures into 64-bit aligned structures. The appropriate native 64-bit system call is passed to the operating system kernel, and any output data from the 64-bit system call is converted into a format appropriate for the calling application before being passed back.

Like 32-bit applications, WOW64 runs in user mode so any errors that occur in translating an operating system call will only occur at that level. The 64-bit operating system kernel cannot be affected.

Since WOW64 runs in user mode, all 32-bit application code must also run in user mode. This explains why 32-bit kernel mode device drivers and applications that rely on them, will not work under Windows 64-bit.

The WOW64 emulator consists of the following DLLs, the only 64-bit DLLS that can be loaded into a 32-bit process:

Wow64.dll – the core emulation infrastructure and the links to the Ntoskrnl.exe entry-point functions.
Wow64Win.dll – the links to the Win32k.sys entry-point functions.
Wow64Cpu.dll – switches the processor from 32-bit to 64-bit mode.
Ntdll.dll – 64-bit version.

Wow64.dll loads the 32-bit version (x86) of Ntdll.dll and all necessary 32-bit DLLs which are mostly unmodified 32-bit binaries..However, some of these DLLs have been modified to behave differently on WOW64 than they do on 32-bit Windows. This is usually because they share memory with 64-bit system components.

 procedure SendMCICommand(Cmd: string);
var
  RetVal: Integer;
  ErrMsg: array[0..254] of char;
begin
  RetVal := mciSendString(PChar(Cmd), nil, 0, 0);
  if RetVal <> 0 then
  begin
    {get message for returned value}
    mciGetErrorString(RetVal, ErrMsg, 255);
    MessageDlg(StrPas(ErrMsg), mtError, [mbOK], 0);
  end;
end;


http://en.wikipedia.org/wiki/Four-dimensional_space

On 64-bit versions of Windows, two rundll32.exe programs exist:

    64-bit: C:\Windows\System32\rundll32.exe
    32-bit: C:\Windows\SysWOW64\rundll32.exe

If you are trying to do this from a 32-bit program, you might need to use C:\Windows\Sysnative or temporarily turn off WoW64 file system redirection. See the Microsoft documentation.

It is not possible to load a 32bit version DLL with 64bit version of Lazarus compiler so we had to recompile it.
The 64 bit version of Lazarus/FPC would by default produce 64 bit binaries.
To create a new DLL project (if you started Lazarus for the first time) click on Project -> new project -> Library. Give it a big name and save it into an empty folder. The project will initially consist of only two files. An .lpi file containing all compiler settings and and .lpr file containing source code, these two files are all you need, additional units are saved as individual .pas files. 

Process-, Design- and Architectural Patterns at an Overview


http://www.slideshare.net/maxkleiner1/dll-design-with-building-blocks
http://www.slideshare.net/maxkleiner1/a-3d-printing-solutionekon
https://bitbucket.org/max_kleiner/maxbox3/downloads

<iframe src="http://www.slideshare.net/maxkleiner1/slideshelf" width="615px" height="470px" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:none;" allowfullscreen webkitallowfullscreen mozallowfullscreen></iframe>

MAX KLEINER:
PASCAL SCRIPTING IN
LAZARUS EN FREE PASCAL


TIJDENS DEZE SESSIE RICHTEN WE ALLE AANDACHT OP PASCAL SCRIPT.  EEN SCRIPTING ENGINE MAAKT HET MOGELIJK (EN VOOR UW CLIENTS) OM EEN
APPLICATIE OP MAAT TE MAKEN EN AAN TE PASSEN AAN UW BEHOEFTE ZONDER DAT HER-COMPILATIE NODIG IS. ALS EXTRA, KUNT U UW
APPS UPDATEN DOOR GEWOON DE NIEUWE SCRIPT UIT TE VOEREN   EN DAT SCRIPT KAN ZELFS WORDEN GECOMPILEERD NAAR BYTE CODE OF HET RUNT ALLEEN.DE ONDERDELEN:
• COMPONENTEN INTEGRATIE IN LAZARUS
• HOE WERKT PASCAL SCRIPT?
• INZICHT GEVEN IN WAT DE COMPILER EN    RUNTIMER DOEN
• REAL WORLD EXAMPLESBOUW EEN SCRIPT IN UW APPLICATIE OM MEER"GEBRUIKSVRIENDELIJK TE ZIJN VOOR ANDERE TALEN" EN MINDER IDE OF
PLATFORM AFHANKELIJK  (INTERPRETER).

Willemsplein 18
6811 KB Arnhem
Netherlands
Phone 	+31263529830
GPS coordinates 	N 051° 59.012, E 05° 54.229 

mX 3.9.9.110

writeln
example  [APP=C:\windows\system32\calc.exe]

add //w_createwindow 

check  for rs32 in windows.pas

unit JvFtpGrabber;
unit uPSI_JvIni;

function GetTableName(const AField: TField): string;
function GetFieldName(const AField: TField): string;



arnheim centrsl 22197404
