{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red255\green0\blue0;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title Untitled}}
\deflang1033\pard\plain\f0\fs20 \cf0 PROGRAM\cf1  \cf0 DataGrid_2;
\par 
\par \cf2\i ///////////////////////////////////////////////////////////////////////////
\par //  #sign:Administrator: PC08: 14/02/2014 10:53:10 AM 
\par //  Purpose: how to call a dll function, still on progress  
\par //  #path>ples\\E:\\maxbox3\\mXGit39988\\maxbox3\\examples\\                    
\par //  Lines of Code #locs:701
\par ///////////////////////////////////////////////////////////////////////////
\par 
\par \i0\cf0 Const\cf1  \cf0 TEXTOUT\cf1  \cf0 =\cf1  \cf3 'hi world of dll func in opcode '\cf0 ;
\par 
\par \cf2\i //############################################################################
\par // Archimedes DLL Architect
\par //############################################################################
\par //TODO: Button with stop event, change color and save bitmap as png
\par \i0\cf1   \cf2\i //TODO: transfer the App to a dll stub function!
\par \i0\cf1   \cf2\i //\{ TODO : the following line looks like a bug... \}
\par \i0\cf1   
\par   \cf0 package\cf1  \cf0 =\cf1  \cf3 'com.example.hellousb'\cf0 ;
\par 
\par \{import\cf1  \cf0 java.util.concurrent.ArrayBlockingQueue;
\par import\cf1  \cf0 java.util.concurrent.atomic.AtomicBoolean;
\par 
\par import\cf1  \cf0 android.app.Activity;
\par import\cf1  \cf0 android.content.BroadcastReceiver;
\par import\cf1  \cf0 android.content.Context;
\par import\cf1  \cf0 android.content.Intent;
\par import\cf1  \cf0 android.content.IntentFilter;
\par import\cf1  \cf0 android.graphics.Color;
\par import\cf1  \cf0 android.hardware.usb.UsbConstants;
\par import\cf1  \cf0 android.hardware.usb.UsbDevice;
\par import\cf1  \cf0 android.hardware.usb.UsbDeviceConnection;
\par import\cf1  \cf0 android.hardware.usb.UsbEndpoint;
\par import\cf1  \cf0 android.hardware.usb.UsbInterface;
\par import\cf1  \cf0 android.hardware.usb.UsbManager;
\par import\cf1  \cf0 android.os.Bundle;
\par import\cf1  \cf0 android.util.Log;
\par import\cf1  \cf0 android.view.Menu;
\par import\cf1  \cf0 android.view.WindowManager;
\par import\cf1  \cf0 android.widget.SeekBar;
\par import\cf1  \cf0 android.widget.SeekBar.OnSeekBarChangeListener;\}
\par 
\par 
\par type
\par \cf1  \cf0 TAppData\cf1  \cf0 =\cf1  \cf0 record
\par \cf1    \cf0 Name:\cf1  \cf0 shortstring;
\par \cf1    \cf0 Size:\cf1  \cf0 longint;
\par \cf1    \cf0 Release:\cf1  \cf0 shortstring;
\par \cf1    \cf0 descript:\cf1  \cf0 shortstring;
\par \cf1  \cf0 end;
\par 
\par 
\par \{type\cf1   
\par   \cf0 PROCESS_MEMORY_COUNTERS\cf1  \cf0 =\cf1  \cf0 record
\par \cf1     \cf0 cb\cf1  \cf0 :\cf1  \cf0 DWORD;
\par \cf1     \cf0 PageFaultCount\cf1  \cf0 :\cf1  \cf0 DWORD;
\par \cf1     \cf0 PeakWorkingSetSize\cf1  \cf0 :\cf1  \cf0 DWORD;
\par \cf1     \cf0 WorkingSetSize\cf1  \cf0 :\cf1  \cf0 DWORD;\cf1  \cf2\i //Task managers MemUsage number
\par \i0\cf1     \cf0 QuotaPeakPagedPoolUsage\cf1  \cf0 :\cf1  \cf0 DWORD;
\par \cf1     \cf0 QuotaPagedPoolUsage\cf1  \cf0 :\cf1  \cf0 DWORD;
\par \cf1     \cf0 QuotaPeakNonPagedPoolUsage\cf1  \cf0 :\cf1  \cf0 DWORD;
\par \cf1     \cf0 QuotaNonPagedPoolUsage\cf1  \cf0 :\cf1  \cf0 DWORD;
\par \cf1     \cf0 PagefileUsage\cf1  \cf0 :\cf1  \cf0 DWORD;\cf1  \cf2\i //TaskMan's VM Size number
\par \i0\cf1     \cf0 PeakPagefileUsage\cf1  \cf0 :\cf1  \cf0 DWORD;
\par \cf1   \cf0 end;
\par \cf1   \cf0 TProcessMemoryCounters\cf1  \cf0 =\cf1  \cf0 PROCESS_MEMORY_COUNTERS;\}
\par \cf1   
\par   \cf0 \{\cf1  \cf0 _OSVERSIONINFOA\cf1  \cf0 =\cf1  \cf0 record
\par \cf1     \cf0 dwOSVersionInfoSize:\cf1  \cf0 DWORD;
\par \cf1     \cf0 dwMajorVersion:\cf1  \cf0 DWORD;
\par \cf1     \cf0 dwMinorVersion:\cf1  \cf0 DWORD;
\par \cf1     \cf0 dwBuildNumber:\cf1  \cf0 DWORD;
\par \cf1     \cf0 dwPlatformId:\cf1  \cf0 DWORD;
\par \cf1     \cf0 szCSDVersion:\cf1  \cf0 array[\cf4 0\cf0 ..\cf4 127\cf0 ]\cf1  \cf0 of\cf1  \cf0 AnsiChar;\cf1  \cf0 \{\cf1  \cf0 Maintenance\cf1  \cf0 AnsiString\cf1  \cf0\b for\b0\cf1  \cf0 PSS\cf1  \cf0 usage\cf1  \cf0 \}
\par \cf1   \cf0 \{end;
\par \cf1  \cf2\i //TIntegerList
\par \i0\cf1  \cf2\i //var aos: TOSVersionInfo;
\par 
\par //  function  \{**************************************************\}
\par \i0\cf0 function\cf1  \cf0 GetProcessMemoryInfo(Process:\cf1  \cf0 THandle;\cf1  \cf0 var\cf1  \cf0 MemoryCounters:\cf1  \cf0 TProcessMemoryCounters;
\par \cf1                                     \cf0 cb:\cf1  \cf0 DWORD):\cf1  \cf0 BOOL;\cf1  \cf2\i //stdcall;; 
\par \i0\cf1      \cf0 External\cf1  \cf3 'GetProcessMemoryInfo@psapi.dll stdcall'\cf0 ;
\par \cf1      
\par  \cf0 Function\cf1  \cf0 OpenProcess2(dwDesiredAccess:\cf1  \cf0 DWORD;\cf1  \cf0 bInheritHandle:BOOL;\cf1  \cf0 dwProcessId:\cf1  \cf0 DWORD):THandle;
\par \cf1      \cf0 External\cf1   \cf3 'OpenProcess@kernel32.dll stdcall'\cf0 ;
\par 
\par 
\par \{TYPE\cf1  \cf0 <Type\cf1  \cf0 declarations>\}\cf1  
\par   \cf0 var\cf1  \cf0 FWait,\cf1  \cf0\b switch\b0 :\cf1  \cf0 Boolean;
\par \cf1       \cf0 FValueA,\cf1  \cf0 FValueB:\cf1  \cf0 Float;
\par \cf1       \cf2\i //asd: TDoubleArray;
\par \i0\cf1     \cf0 aGrid:\cf1  \cf0 TStringGrid;
\par \cf1     \cf0 app:\cf1  \cf0 TAppData;
\par \cf1     \cf0 f:\cf1  \cf0 Text;\cf1  \cf0 \{file\cf1  \cf0 of\}\cf1  \cf2\i //TAppData;
\par \i0\cf1     \cf0 FaDatfile:\cf1  \cf0 String;
\par \cf1     \cf0 Fmodified:\cf1  \cf0 Boolean;
\par \cf1     \cf0 myrec:\cf1  \cf0 TSearchrec;
\par \cf1     \cf2\i //file: dwstestbin
\par \i0\cf1   
\par      
\par \cf2\i //<FUNCTION>
\par //<PROCEDURE> 
\par 
\par 
\par \i0\cf0 function\cf1  \cf0 RemoveSpaces2(\b const\b0\cf1  \cf0 str\cf1  \cf0 :\cf1  \cf0 String)\cf1  \cf0 :\cf1  \cf0 String;
\par var
\par \cf1    \cf0 c\cf1  \cf0 :\cf1  \cf0 Char;
\par \cf1    \cf0 i,\cf1  \cf0 p,\cf1  \cf0 n\cf1  \cf0 :\cf1  \cf0 Integer;
\par begin
\par \cf1    \cf0 n:=Length(str);
\par \cf1    \cf0 SetLength(Result,\cf1  \cf0 n);
\par \cf1    \cf0 p:=\cf4 1\cf0 ;
\par \cf1    \cf0\b for\b0\cf1  \cf0 i:=\cf4 1\cf1  \cf0 to\cf1  \cf0 n\cf1  \cf0\b do\b0\cf1  \cf0 begin
\par \cf1       \cf0 c:=str[i];
\par \cf1       \cf0\b if\b0\cf1  \cf0 c<>\cf3 ' '\cf1  \cf0 then\cf1  \cf0 begin
\par \cf1          \cf0 Result[p]:=c;
\par \cf1          \cf0 Inc(p);
\par \cf1       \cf0 end;
\par \cf1    \cf0 end;
\par \cf1    \cf0 SetLength(Result,\cf1  \cf0 p-\cf4 1\cf0 );
\par end;
\par 
\par 
\par procedure\cf1  \cf0 TBuildAppGrid_fillGrid;
\par var
\par \cf1   \cf0 crow:\cf1  \cf0 Integer;
\par \cf1   \cf2\i //UTF8FileHeader: integer;
\par \i0\cf1   \cf2\i //ad: UTF8FileHeader
\par \i0\cf1   \cf0 mss:\cf1  \cf0 TCopyFileFlag;\cf1  \cf2\i //, TFileIterator, TFileSearcher;
\par \i0\cf1   \cf2\i //atr: TCommandModule //ICommandServer 
\par \i0\cf1   \cf2\i //aert: VK_MOUSEWHEELUP
\par \i0\cf1   \cf2\i //asrtz: TVirtualKeyCode
\par \i0\cf1   \cf0 gbgh:\cf1  \cf0 TDataFileCapability;
\par \cf1   \cf2\i //myintproc: TDelphiColor //TProcInt;
\par \i0\cf1   
\par \cf0 begin
\par 
\par \cf1   \cf0 crow\cf1  \cf0 :=\cf1  \cf4 1\cf0 ;
\par \cf1   \cf0 with\cf1  \cf0 aGrid\cf1  \cf0\b do\b0\cf1  \cf0 begin
\par \cf1     \cf0 Cells[\cf4 0\cf0 ,\cf4 0\cf0 ]:=\cf1  \cf3 'Application Name'\cf0 ;
\par \cf1     \cf0 ColWidths[\cf4 0\cf0 ]:=\cf1  \cf4 120\cf0 ;
\par \cf1     \cf0 Cells[\cf4 1\cf0 ,\cf4 0\cf0 ]:=\cf1  \cf3 'App Size'\cf0 ;
\par \cf1     \cf0 ColWidths[\cf4 1\cf0 ]:=\cf1  \cf4 60\cf0 ;
\par \cf1     \cf0 Cells[\cf4 2\cf0 ,\cf4 0\cf0 ]:=\cf1  \cf3 'Release Date'\cf0 ;
\par \cf1     \cf0 ColWidths[\cf4 2\cf0 ]:=\cf1  \cf4 90\cf0 ;
\par \cf1     \cf0 Cells[\cf4 3\cf0 ,\cf4 0\cf0 ]:=\cf1  \cf3 'Description'\cf0 ;
\par \cf1     \cf0 ColWidths[\cf4 3\cf0 ]:=\cf1  \cf4 140\cf0 ;
\par \cf1     \cf0\b if\b0\cf1  \cf0 FaDatFile\cf1  \cf0 <>\cf1  \cf3 ''\cf1  \cf0 then\cf1  \cf0 begin
\par \cf1       \cf2\i //AssignFileRead(f,FaDatFile);
\par \i0\cf1       \cf2\i //AssignFile(f,FaDatFile);
\par \i0\cf1       \cf2\i //findfirst
\par \i0\cf1       \cf2\i //findfirstutf8
\par \i0\cf1       \cf2\i //findfirst2
\par \i0\cf1       \cf2\i //ReadFileToString
\par \i0\cf1         \cf2\i //keypressed
\par \i0\cf1         \cf2\i //findnext2
\par \i0\cf1         \cf2\i //findclose
\par \i0\cf1        \cf2\i // Reset2(f);
\par \i0\cf1        \cf2\i //reset2
\par \i0\cf1       \cf0\b try
\par \b0\cf1         \cf2\i //while not Eof(F) do begin
\par \i0\cf1           \cf2\i //Read (F, app);
\par \i0\cf1           \cf0 Cells[\cf4 0\cf0 ,crow]:=\cf1  \cf0 app.Name;
\par \cf1           \cf0 Cells[\cf4 1\cf0 ,crow]:=\cf1  \cf0 intToStr(app.size);
\par \cf1           \cf0 Cells[\cf4 2\cf0 ,crow]:=\cf1  \cf0 app.Release;
\par \cf1           \cf0 Cells[\cf4 3\cf0 ,crow]:=\cf1  \cf0 app.descript;
\par \cf1           \cf0 Inc(cRow);
\par \cf1           \cf0 RowCount:=\cf1  \cf0 crow\cf1  \cf0 +\cf4 1\cf0 ;\cf1   \cf2\i //new entry
\par \i0\cf1         \cf2\i //end;
\par \i0\cf1       \cf0\b finally
\par \b0\cf1         \cf2\i //CloseFile(f);
\par \i0\cf1       \cf0 end;
\par \cf1     \cf0 end;\cf2\i // if FileExists...
\par \i0\cf1   \cf0 end;\cf1  \cf2\i //with
\par \i0\cf0 end;
\par 
\par 
\par var\cf1   \cf0 nYear,
\par \cf1   \cf0 nMonth,
\par \cf1   \cf0 nDay,
\par \cf1   \cf0 fcounter:\cf1  \cf0 word;
\par \cf1   \cf0 dflistView:\cf1  \cf0 TListBox;
\par \cf1   
\par \cf0 procedure\cf1  \cf0 \{constructor\}\cf1  \cf0 TChangeFinder_Create_prepList_and_Date(alistView:\cf1  \cf0 TListBox);
\par begin
\par \cf1   \cf2\i //GetDate(Year, Month, Day, DayofWeek);
\par \i0\cf1   \cf2\i //now date is to slow
\par \i0\cf1   \cf2\i //inherited Create;
\par \i0\cf1   \cf0 dflistView:=\cf1  \cf0 alistView;
\par \cf1   \cf0 decodedate(date,\cf1  \cf0 nyear,\cf1  \cf0 nmonth,\cf1  \cf0 nday);
\par \cf1     \cf0 dflistView.items.insert(\cf4 0\cf0 ,\cf1  \cf0 format(\cf3 '%-120s %10s -%5s'\cf0 ,
\par \cf1        \cf0 [\cf3 'Filename:'\cf0 ,\cf1  \cf3 'Size:'\cf0 ,\cf1  \cf3 'Time:'\cf0 ]));
\par \cf1      \cf0 fcounter:=\cf1  \cf4 1\cf0 ;
\par \cf1   \cf0 with\cf1  \cf0 alistView.Items\cf1  \cf0\b do\b0\cf1  \cf0 begin
\par \cf1     \cf0 BeginUpdate;
\par \cf1     \cf0 Clear;
\par \cf1     \cf0 EndUpdate;
\par \cf1   \cf0 end;
\par end;
\par \cf1   
\par       \cf2\i //faDirectory = $00000010;
\par \i0\cf1       \cf2\i //faAnyFile   = $0000003F;   
\par 
\par 
\par \i0\cf0 PROCEDURE\cf1  \cf0 TChangeFinder_ShowFiles(Showpath:\cf1  \cf0 STRING;\cf1  \cf0 sr:\cf1  \cf0 TSearchRec);
\par VAR
\par \cf1   \cf0 arcdisp:\cf1  \cf0 shortSTRING;
\par \cf1   \cf0 DateRec:\cf1  \cf0 TDateTime;
\par \cf1   \cf0 lenStr,
\par \cf1   \cf0 insertStr,
\par \cf1   \cf0 fname,
\par \cf1   \cf0 fext,\cf1  \cf0 outPutStr:\cf1  \cf0\b string\b0 ;
\par \cf1   \cf0 len\cf1       \cf0 :\cf1  \cf0 BYTE;
\par \cf1   \cf0 AYear,\cf1  \cf0 AMonth,\cf1  \cf0 ADay:\cf1  \cf0 Word;
\par \cf1   \cf0 aHour,\cf1  \cf0 aMin,\cf1  \cf0 aSec,\cf1  \cf0 aMsec:\cf1  \cf0 word;
\par 
\par BEGIN
\par \cf1   \cf2\i //IF sr.Attr IN [$8..$F] \{, $28..$2F]\} THEN BEGIN
\par \i0\cf1     \cf0 IF\cf1  \cf0 Pos(\cf3 '.'\cf0 ,\cf1  \cf0 sr.Name)\cf1  \cf0 >\cf1  \cf4 0\cf1  \cf0 THEN
\par \cf1       \cf0 Delete(sr.Name,\cf1  \cf0 Pos(\cf3 '.'\cf0 ,\cf1  \cf0 sr.Name),\cf1  \cf4 1\cf0 );
\par \cf1   \cf2\i //END;
\par \i0\cf1   \cf0 IF\cf1  \cf0 (Pos(\cf3 '.'\cf0 ,\cf1  \cf0 sr.Name)\cf1  \cf0 >\cf1  \cf4 0\cf0 )\cf1  \cf0 AND\cf1  \cf0 (Length(sr.Name)\cf1  \cf0 >\cf1  \cf4 0\cf0 )\cf1  \cf0 THEN\cf1  \cf0 begin
\par \cf1     \cf0 fname:=\cf1  \cf0 Copy(sr.Name,\cf1  \cf4 1\cf0 ,\cf1  \cf0 Pos(\cf3 '.'\cf0 ,\cf1  \cf0 sr.Name)\cf1  \cf0 -\cf1  \cf4 1\cf0 );
\par \cf1     \cf0 fext:=\cf1  \cf0 sr.Name;
\par \cf1     \cf0 Delete(fext,\cf1  \cf4 1\cf0 ,\cf1  \cf0 Pos(\cf3 '.'\cf0 ,\cf1  \cf0 fext));
\par \cf1   \cf0 END\cf1  \cf0 ELSE\cf1  \cf0 BEGIN
\par \cf1     \cf0 fname:=\cf1  \cf0 sr.Name;
\par \cf1     \cf0 fext:=\cf1  \cf3 '  '\cf0 ;
\par \cf1   \cf0 END;
\par \cf1   \cf0 arcdisp:=\cf1  \cf3 '    '\cf0 ;
\par \cf2\i //&&\{$WARN SYMBOL_PLATFORM OFF\}
\par \i0\cf1   \cf0 IF\cf1  \cf0 sr.Attr\cf1  \cf0 AND\cf1  \cf0 faArchive\cf1   \cf0 =\cf1  \cf0 faArchive\cf1   \cf0 THEN\cf1  \cf0 arcdisp[\cf4 1\cf0 ]\cf1  \cf0 :=\cf1  \cf3 'A'\cf0 ;
\par \cf1   \cf0 IF\cf1  \cf0 sr.Attr\cf1  \cf0 AND\cf1  \cf0 faReadOnly\cf1  \cf0 =\cf1  \cf0 faReadOnly\cf1  \cf0 THEN\cf1  \cf0 arcdisp[\cf4 2\cf0 ]\cf1  \cf0 :=\cf1  \cf3 'R'\cf0 ;
\par \cf1   \cf0 IF\cf1  \cf0 sr.Attr\cf1  \cf0 AND\cf1  \cf0 faHidden\cf1    \cf0 =\cf1  \cf0 faHidden\cf1    \cf0 THEN\cf1  \cf0 arcdisp[\cf4 3\cf0 ]\cf1  \cf0 :=\cf1  \cf3 'H'\cf0 ;
\par \cf1   \cf0 IF\cf1  \cf0 sr.Attr\cf1  \cf0 AND\cf1  \cf0 faSysFile\cf1   \cf0 =\cf1  \cf0 faSysFile\cf1   \cf0 THEN\cf1  \cf0 arcdisp[\cf4 4\cf0 ]\cf1  \cf0 :=\cf1  \cf3 'S'\cf0 ;
\par \cf2\i //\{$WARN SYMBOL_PLATFORM ON\}
\par \i0\cf1   \cf2\i //8..15, 40..47
\par \i0\cf1   \cf2\i //IF NOT (sr.Attr IN [$8..$F, $28..$2F]) THEN BEGIN
\par \i0\cf1     \cf2\i //Str(sr.Size, lenStr);
\par \i0\cf1     \cf0 IF\cf1  \cf0 Length(lenStr)\cf1  \cf0 >\cf1  \cf4 3\cf1  \cf0 THEN\cf1  \cf0 BEGIN
\par \cf1       \cf0 insertStr:=\cf1  \cf3 '.'\cf0 ;
\par \cf1       \cf0 len:=\cf1  \cf0 Length(lenStr)\cf1  \cf0 -\cf1  \cf4 2\cf0 ;
\par \cf1       \cf0 Insert(insertStr,\cf1  \cf0 lenStr,\cf1  \cf0 len);
\par \cf1       \cf0 IF\cf1  \cf0 Length(lenStr)\cf1  \cf0 >\cf1  \cf4 7\cf1  \cf0 THEN\cf1  \cf0 BEGIN
\par \cf1         \cf0 len:=\cf1  \cf0 Length(lenStr)\cf1  \cf0 -\cf1  \cf4 6\cf0 ;
\par \cf1         \cf0 Insert(insertStr,\cf1  \cf0 lenStr,\cf1  \cf0 len);
\par \cf1       \cf0 END;
\par \cf1     \cf0 END;
\par \cf1   \cf2\i //END;
\par \i0\cf1   \cf2\i //IF NOT (sr.Attr IN [$8..$F, $28..$2F]) THEN BEGIN
\par \i0\cf1    \cf2\i //check the system now date
\par \i0\cf1     \cf0 dateRec:=\cf1  \cf0 FileDatetoDateTime(sr.Time);
\par \cf1     \cf0 DecodeDate(dateRec,\cf1  \cf0 AYear,\cf1  \cf0 AMonth,\cf1  \cf0 ADay);
\par \cf1     \cf0 DecodeTime(dateRec,\cf1  \cf0 aHour,\cf1  \cf0 aMin,\cf1  \cf0 aSec,\cf1  \cf0 aMsec);\cf1  \cf2\i //new 1.8
\par \i0\cf1     \cf2\i //daterec:= now;  //testroutine
\par \i0\cf1     \cf0 IF\cf1  \cf0 (ADay\cf1  \cf0 =\cf1  \cf0 nDay)\cf1  \cf0 AND\cf1  \cf0 (AYear\cf1  \cf0 =\cf1  \cf0 nYear)\cf1  \cf0 AND\cf1  \cf0 (AMonth\cf1  \cf0 =\cf1  \cf0 nMonth)\cf1  \cf0 THEN\cf1  \cf0 BEGIN
\par \cf1         \cf0 IF\cf1  \cf0 Showpath[Length(Showpath)]\cf1  \cf0 =\cf1  \cf3 '\\' THEN
\par \cf1         \cf0 Delete(Showpath,\cf1  \cf0 Length(Showpath),\cf1  \cf4 1\cf0 );
\par \cf1         \cf0 outPutStr:=\cf1  \cf0 Showpath\cf1  \cf0 +\cf1  \cf3 '\\' + fname + '\cf0 .\cf3 ' + fext;
\par \cf1         \cf2\i //dflistview.Columns:= 3;
\par \i0\cf1         \cf2\i //dflistView.TabWith:= 50;
\par \i0\cf1         \cf2\i //dflistView.Items.add(outPutStr +^I+ lenStr);  // ^I is the Tab char
\par \i0\cf1         \cf0 dflistView.Items.Insert(\cf4 0\cf0 ,\cf1  \cf0 format(\cf3 '%-80s %10s -%5s'\cf0 ,
\par \cf1            \cf0 [outPutStr,\cf1  \cf0 lenStr,\cf1  \cf0 inttoStr(aHour)+\cf3 ':'\cf0 +inttoStr(aMin)]));
\par \cf1      \cf0 END;
\par \cf1   \cf2\i //END;
\par \i0\cf0 END;
\par 
\par 
\par PROCEDURE\cf1  \cf0 TChangeFinder_SearchDirectories(path:\cf1  \cf0\b string\b0 ;\cf1  \cf0\b const\b0\cf1  \cf0 fname:\cf1  \cf0 STRING);
\par VAR
\par \cf1   \cf0 sRecord\cf1  \cf0 :\cf1  \cf0 TSearchRec;
\par \cf1   \cf0 Showpath:\cf1  \cf0 STRING;
\par \cf1   \cf2\i //myf: TChangeFinder; 
\par \i0\cf1   \cf2\i //amod: TmodCommand;
\par \i0\cf0 BEGIN
\par \cf1   \cf0 (*\cf1  \cf0 Suche\cf1  \cf0 nach\cf1  \cf0 Dateien:\cf1  \cf0 *)
\par \cf1   \cf0 IF\cf1  \cf0 Length(path)\cf1  \cf0 >\cf1  \cf4 0\cf1  \cf0 THEN
\par \cf1     \cf0 IF\cf1  \cf0 path[Length(path)]\cf1  \cf0 <>\cf1  \cf3 '\\' THEN
\par \cf1       \cf0 path\cf1  \cf0 :=\cf1  \cf0 path\cf1  \cf0 +\cf1  \cf3 '\\';
\par \cf1   \cf0 SRecord.Name:=\cf1  \cf3 ''\cf0 ;
\par \cf1   \cf0\b if\b0\cf1  \cf0 FindFirst2(path+fname,\cf1  \cf0 faAnyfile\cf1  \cf0 MOD\cf1  \cf0 faDirectory,\cf1  \cf0 SRecord)\cf1  \cf0 =\cf1  \cf4 0\cf1  \cf0 then\cf1  \cf0 begin
\par \cf1     \cf0 Showpath:=\cf1  \cf3 '        .   '\cf0 ;
\par \cf1     \cf0 IF\cf1  \cf0 SRecord.Name\cf1  \cf0 <>\cf1  \cf3 ''\cf1  \cf0 THEN\cf1  \cf0 BEGIN
\par \cf1       \cf0 IF\cf1  \cf0 Length(path)\cf1   \cf0 >\cf1  \cf4 3\cf1  \cf0 THEN
\par \cf1       \cf0 Showpath:=\cf1  \cf0 Copy(path,\cf1  \cf4 1\cf0 ,\cf1  \cf0 Length(path)\cf1  \cf0 -\cf1  \cf4 1\cf0 )
\par \cf1      \cf0 ELSE\cf1  \cf0 Showpath:=\cf1  \cf0 path;
\par \cf1     \cf0 END;
\par \cf1    \cf0\b try
\par \b0\cf1     \cf0 repeat
\par \cf1      \cf2\i //0..14, 32..46
\par \i0\cf1       \cf2\i //IF SRecord.Attr IN [$0..$E, $20..$2E] THEN
\par \i0\cf1       \cf2\i //IF (SRecord.Attr <=$E) or (SRecord.Attr >=$20) or (SRecord.Attr <=$2E) then
\par \i0\cf1       \cf2\i //IN [$0..$E, $20..$2E] THEN
\par \i0\cf1       
\par       \cf2\i //FindFirst(StartDir+FileMask, faAnyFile-faDirectory) = 0;
\par \i0\cf1       \cf0 IF\cf1  \cf0 (SRecord.Attr\cf1  \cf0 =\cf1  \cf0 faAnyFile-faDirectory)\cf1  \cf0 then
\par \cf1           \cf0 TChangeFinder_ShowFiles(Showpath,SRecord);
\par \cf1     \cf0 until\cf1  \cf0 FindNext2(sRecord)\cf1  \cf0 <>\cf1  \cf4 0\cf0 ;
\par \cf1    \cf0\b finally
\par \b0\cf1       \cf0 WFindClose(sRecord.findhandle);
\par \cf1    \cf0 end;
\par \cf1   \cf0 end;
\par \cf1   \cf0 (*\cf1  \cf0 Suche\cf1  \cf0 nach\cf1  \cf0 Verzeichnissen:\cf1  \cf0 *)
\par \cf1   \cf2\i // hidden dir available with fahidden
\par \i0\cf1   \cf0\b if\b0\cf1  \cf0 FindFirst2(path\cf1  \cf0 +\cf1  \cf3 '*.*'\cf0 ,\cf1  \cf0 faDirectory\cf1  \cf0 or\cf1  \cf0 faHidden,\cf1  \cf0 SRecord)\cf1  \cf0 =\cf1  \cf4 0\cf1  \cf0 then\cf1  \cf0 begin
\par \cf1     \cf0\b try
\par \b0\cf1     \cf0 repeat
\par \cf1         \cf0 IF\cf1  \cf0 (SRecord.Attr\cf1  \cf0 AND\cf1  \cf0 faDirectory\cf1  \cf0 <>\cf1  \cf4 0\cf0 )\cf1  \cf0 AND
\par \cf1        \cf0 (SRecord.Name[\cf4 1\cf0 ]\cf1  \cf0 <>\cf1  \cf3 '.'\cf0 )\cf1  \cf0 THEN
\par \cf1       \cf2\i //recursion to get subdirectories
\par \i0\cf1       \cf0 TChangeFinder_SearchDirectories(path\cf1  \cf0 +\cf1  \cf0 SRecord.Name,\cf1  \cf0 fname);
\par \cf1       \cf0 writeln(path\cf1  \cf0 +\cf1  \cf0 SRecord.Name)
\par \cf1     \cf0 until\cf1  \cf0 FindNext2(sRecord)\cf1  \cf0 <>\cf1  \cf4 0\cf0 ;
\par \cf1     \cf0\b finally
\par \b0\cf1       \cf0 WFindClose(sRecord.findhandle);
\par \cf1     \cf0 end;
\par \cf1   \cf0 end;
\par end;
\par 
\par 
\par 
\par 
\par \{**************************************************\}
\par \cf2\i //function GetProcessMemoryInfo; external 'psapi.dll';
\par \i0\cf0 \{****************************************************\}
\par 
\par function\cf1  \cf0 ProcessMemoryUsage(ProcessID\cf1  \cf0 :\cf1  \cf0 DWORD):\cf1  \cf0 DWORD;
\par var\cf1  \cf0 ProcessHandle\cf1  \cf0 :\cf1  \cf0 THandle;
\par \cf1     \cf0 MemCounters\cf1    \cf0 :\cf1  \cf0 TProcessMemoryCounters;
\par begin
\par \cf1   \cf0 Result:=\cf1  \cf4 0\cf0 ;
\par \cf1   \cf0 ProcessHandle:=\cf1  \cf0 OpenProcess2(PROCESS_QUERY_INFORMATION\cf1  \cf0 or\cf1  \cf0 PROCESS_VM_READ,
\par \cf1                                \cf0\b false\b0 ,\cf1  \cf0 ProcessID);
\par \cf1   \cf0\b try
\par \b0\cf1     \cf0\b if\b0\cf1  \cf0 GetProcessMemoryInfo(ProcessHandle,
\par \cf1                             \cf0 MemCounters,\cf1  \cf0\b sizeof\b0 (MemCounters))
\par \cf1     \cf0 then\cf1  \cf0 Result:=\cf1  \cf0 MemCounters.WorkingSetSize;
\par \cf1   \cf0\b finally
\par \b0\cf1     \cf0 CloseHandle(ProcessHandle);
\par \cf1   \cf0 end;
\par end;
\par 
\par function\cf1  \cf0 ProcessPageUsage(ProcessID\cf1  \cf0 :\cf1  \cf0 DWORD):\cf1  \cf0 DWORD;
\par var\cf1  \cf0 ProcessHandle\cf1  \cf0 :\cf1  \cf0 THandle;
\par \cf1     \cf0 MemCounters\cf1    \cf0 :\cf1  \cf0 TProcessMemoryCounters;
\par begin
\par \cf1   \cf0 Result:=\cf1  \cf4 0\cf0 ;
\par \cf1   \cf0 ProcessHandle:=\cf1  \cf0 OpenProcess2(PROCESS_QUERY_INFORMATION\cf1  \cf0 or\cf1  \cf0 PROCESS_VM_READ,
\par \cf1                                \cf0\b false\b0 ,\cf1  \cf0 ProcessID);
\par \cf1   \cf0\b try
\par \b0\cf1     \cf0\b if\b0\cf1  \cf0 GetProcessMemoryInfo(ProcessHandle,
\par \cf1                             \cf0 MemCounters,\cf1  \cf0\b sizeof\b0 (MemCounters))
\par \cf1     \cf0 then\cf1  \cf0 Result:=\cf1  \cf0 MemCounters.PagefileUsage;
\par \cf1   \cf0\b finally
\par \b0\cf1     \cf0 CloseHandle(ProcessHandle);
\par \cf1   \cf0 end;
\par end;
\par 
\par function\cf1  \cf0 ProcessAllRec(ProcessID\cf1  \cf0 :\cf1  \cf0 DWORD):\cf1  \cf0 TProcessMemoryCounters;
\par var\cf1  \cf0 ProcessHandle\cf1  \cf0 :\cf1  \cf0 THandle;
\par \cf1     \cf0 MemCounters\cf1    \cf0 :\cf1  \cf0 TProcessMemoryCounters;
\par begin
\par \cf1   \cf2\i //Result:= NULL;
\par \i0\cf1   \cf0 ProcessHandle:=\cf1  \cf0 OpenProcess2(PROCESS_QUERY_INFORMATION\cf1  \cf0 or\cf1  \cf0 PROCESS_VM_READ,
\par \cf1                                \cf0\b false\b0 ,\cf1  \cf0 ProcessID);
\par \cf1   \cf0\b try
\par \b0\cf1     \cf0\b if\b0\cf1  \cf0 GetProcessMemoryInfo(ProcessHandle,
\par \cf1                             \cf0 MemCounters,\cf1  \cf0\b sizeof\b0 (MemCounters))
\par \cf1     \cf0 then\cf1  \cf0 Result:=\cf1  \cf0 MemCounters;
\par \cf1   \cf0\b finally
\par \b0\cf1     \cf0 CloseHandle(ProcessHandle);
\par \cf1   \cf0 end;
\par end;
\par 
\par Procedure\cf1  \cf0 OVCInternationalDemoClass;
\par begin
\par \cf1  \cf0 with\cf1  \cf0 TOvcIntlSup.Create\cf1  \cf0\b do\b0\cf1  \cf0 begin
\par \cf1     \cf2\i //Function InternationalDate( ForceCentury : Boolean) : string');
\par \i0\cf1     \cf0 writeln(\cf3 'InternationalDate: '\cf0 +InternationalDate(\b true\b0 ));
\par \cf1     \cf2\i //Function InternationalDatePChar( Dest : PChar; ForceCentury : Boolean) : PChar');
\par \i0\cf1     \cf0 writeln(\cf3 'InternationalLongDate: '\cf0 +InternationalLongDate(\b false\b0 ,\b false\b0 ));
\par \cf1     \cf2\i //Function InternationalTime( ShowSeconds : Boolean) : string');
\par \i0\cf1     \cf0 writeln(\cf3 'InternationalTime: '\cf0 +InternationalTime(\b false\b0 ));
\par \cf1     \cf2\i //Function InternationalTimePChar( Dest : PChar; ShowSeconds : Boolean) : PChar');
\par \i0\cf1     \cf2\i //Function MonthStringToMonth( const S : string; Width : Byte) : Byte');
\par \i0\cf1     \cf0 writeln(Country)
\par \cf1     \cf0 Free;
\par \cf1   \cf0 end;
\par \cf1   \cf2\i //TerminateProcess( hProcess : THandle; uExitCode : UINT) : BOOL');
\par \i0\cf1   \cf2\i //GetExitCodeProcess( hProcess : THandle; var lpExitCode : DWORD) : BOOL');
\par \i0\cf1  \cf2\i //FatalExit( ExitCode : Integer)');
\par \i0\cf1  \cf2\i //ExecuteAndWait(cmdLine : String; visibility : Word;
\par \i0\cf1    \cf2\i //                     timeout : Cardinal = MaxInt;
\par \i0\cf1      \cf2\i //                   killAppOnTimeOut : Boolean = True) : Integer;
\par \i0\cf1   \cf2\i //GetTemporaryFilesPath : String;
\par \i0\cf1  \cf2\i //GetTemporaryFileName : String;
\par \i0\cf1  \cf2\i //Zero
\par \i0\cf1  \cf2\i //TPanelStyle
\par \i0\cf1    \cf2\i //TFontLook
\par \i0\cf1  \cf2\i //FindFileInPaths(const fileName, paths : String) : String;
\par \i0\cf1      \cf2\i //MakeForm
\par \i0\cf1  \cf2\i //PathsToString(const paths : TStrings) : String;
\par \i0\cf1  \cf2\i //StringToPaths(const pathsString : String; paths : TStrings);
\par \i0\cf1  \cf2\i //MacroExpandPath(const aPath : String) : String;
\par \i0\cf1  \cf2\i //TOnGetItemEvent
\par \i0\cf1    \cf2\i //TCacheRecord
\par \i0\cf1    \cf2\i //tMessagefunc
\par \i0\cf1    \cf2\i //EFilerException(CL: TPSPascalCompiler);
\par \i0\cf1    
\par   \cf2\i // TGridPanel
\par //EInvalidFileSignature(CL: TPSPascalCompiler);
\par //TTextWriter(CL: TPSPascalCompiler);
\par //TTextReader(CL: TPSPascalCompiler);
\par //TBinaryWriter(CL: TPSPascalCompiler);
\par //TBinaryReader(CL: TPSPascalCompiler);
\par //TPersistentObjectList(CL: TPSPascalCompiler);
\par //TPersistentObject(CL: TPSPascalCompiler);
\par //IPersistentObject(CL: TPSPascalCompiler);
\par //TVirtualWriter(CL: TPSPascalCompiler);
\par //TVirtualReader(CL: TPSPascalCompiler);
\par //PersistentClasses(CL: TPSPascalCompiler);
\par \i0\cf1           \cf2\i //TMouseActivateEvent'
\par \i0\cf1           \cf2\i //TMouse
\par \i0\cf1  \cf2\i //TStringsAdapter         
\par \i0\cf1    \cf2\i //TActiveForm
\par \i0\cf1           
\par         \cf2\i //TControlState', 
\par \i0\cf1         \cf2\i //TControlStyle
\par \i0\cf1  \cf2\i //CM_BASE
\par \i0\cf1  \cf2\i //mrNone
\par \i0\cf1    \cf2\i //TCMActivate
\par \i0\cf1  \cf2\i //StripAllFromResult
\par \i0\cf1  \cf2\i //IsDragObject( Sender : TObject) : Boolean');
\par \i0\cf1   \cf2\i //IsVCLControl( Handle : HWnd) : Boolean');
\par \i0\cf1   \cf2\i //FindControl( Handle : HWnd) : TWinControl');
\par \i0\cf1   \cf0 \{FindVCLWindow(\cf1  \cf0\b const\b0\cf1  \cf0 Pos\cf1  \cf0 :\cf1  \cf0 TPoint)\cf1  \cf0 :\cf1  \cf0 TWinControl\cf3 ');
\par \cf1   \cf0 FindDragTarget(\cf1  \cf0\b const\b0\cf1  \cf0 Pos\cf1  \cf0 :\cf1  \cf0 TPoint;\cf1  \cf0 AllowDisabled\cf1  \cf0 :\cf1  \cf0 Boolean)\cf1  \cf0 :\cf1  \cf0 TControl\cf3 ');
\par \cf1   \cf0 GetCaptureControl\cf1  \cf0 :\cf1  \cf0 TControl\cf3 ');   \}
\par \cf1  \cf0 \{SetCaptureControl(\cf1  \cf0 Control\cf1  \cf0 :\cf1  \cf0 TControl)\cf3 ');
\par \cf1  \cf0 CL.AddDelphiFunction(\cf3 'Procedure CancelDrag'\cf0 );
\par \cf1   \cf0 CursorToString(\cf1  \cf0 Cursor\cf1  \cf0 :\cf1  \cf0 TCursor)\cf1  \cf0 :\cf1  \cf0\b string\b0\cf3 ');
\par \cf1   \cf0 StringToCursor(\cf1  \cf0\b const\b0\cf1  \cf0 S\cf1  \cf0 :\cf1  \cf0\b string\b0 )\cf1  \cf0 :\cf1  \cf0 TCursor\cf3 ');
\par \cf1  \cf0 CL.AddDelphiFunction(\cf3 'Procedure GetCursorValues( Proc : TGetStrProc)'\cf0 );
\par \cf1   \cf0 CursorToIdent(\cf1  \cf0 Cursor\cf1  \cf0 :\cf1  \cf0 Longint;\cf1  \cf0 var\cf1  \cf0 Ident\cf1  \cf0 :\cf1  \cf0\b string\b0 )\cf1  \cf0 :\cf1  \cf0 Boolean\cf3 ');
\par \cf1   \cf0 IdentToCursor(\cf1  \cf0\b const\b0\cf1  \cf0 Ident\cf1  \cf0 :\cf1  \cf0\b string\b0 ;\cf1  \cf0 var\cf1  \cf0 Cursor\cf1  \cf0 :\cf1  \cf0 Longint)\cf1  \cf0 :\cf1  \cf0 Boolean\cf3 ');
\par \cf1   \cf0 GetShortHint(\cf1  \cf0\b const\b0\cf1  \cf0 Hint\cf1  \cf0 :\cf1  \cf0\b string\b0 )\cf1  \cf0 :\cf1  \cf0\b string\b0\cf3 ');
\par \cf1   \cf0 GetLongHint(\cf1  \cf0\b const\b0\cf1  \cf0 Hint\cf1  \cf0 :\cf1  \cf0\b string\b0 )\cf1  \cf0 :\cf1  \cf0\b string\b0\cf3 ');
\par \cf1  \cf0 CL.AddDelphiFunction(\cf3 'Procedure PerformEraseBackground( Control : TControl; DC : HDC)'\cf0 );
\par \cf1   \cf0 InitWndProc(\cf1  \cf0 HWindow\cf1  \cf0 :\cf1  \cf0 HWnd;\cf1  \cf0 Message,\cf1  \cf0 WParam\cf1  \cf0 :\cf1  \cf0 Longint;\cf1  \cf0 LParam\cf1  \cf0 :\cf1  \cf0 Longint)\cf1  \cf0 :\cf1  \cf0 Longint\cf3 ');
\par \cf1  \cf0 CL.AddConstantN(\cf3 'CTL3D_ALL'\cf0 ,\cf3 'LongWord'\cf0 ).SetUInt(\cf1  \cf4 $\cf0 FFFF);
\par \cf1  \cf0 CL.AddDelphiFunction(\cf3 'Procedure ChangeBiDiModeAlignment( var Alignment : TAlignment)'\cf0 );
\par \cf1   \cf0 SendAppMessage(\cf1  \cf0 Msg\cf1  \cf0 :\cf1  \cf0 Cardinal;\cf1  \cf0 WParam,\cf1  \cf0 LParam\cf1  \cf0 :\cf1  \cf0 Longint)\cf1  \cf0 :\cf1  \cf0 Longint\cf3 ');\}
\par \cf1  \cf2\i //MoveWindowOrg( DC : HDC; DX, DY : Integer)');
\par \i0\cf1  
\par  \cf2\i //SetImeMode( hWnd : HWND; Mode : TImeMode)');
\par \i0\cf1  \cf2\i //SetImeName( Name : TImeName)');
\par \i0\cf1   \cf2\i //Win32NLSEnableIME( hWnd : HWND; Enable : Boolean) : Boolean');
\par \i0\cf1   \cf2\i //Imm32GetContext( hWnd : HWND) : HIMC');
\par \i0\cf1  
\par   \cf2\i //GetShortHint( const Hint : string) : string');
\par \i0\cf1   \cf2\i //GetLongHint( const Hint : string) : string');
\par \i0\cf1  \cf2\i //PerformEraseBackground( Control : TControl; DC : HDC)');
\par \i0\cf1   
\par   \cf2\i //InitWndProc( HWindow : HWnd; Message, WParam : Longint; LParam : Longint) : Longint');
\par \i0\cf1  \cf2\i //CTL3D_ALL','LongWord').SetUInt( $FFFF);
\par \i0\cf1  \cf2\i //ChangeBiDiModeAlignment( var Alignment : TAlignment)');
\par \i0\cf1  
\par  
\par  \cf0 \{DragDone(\cf1  \cf0 Drop\cf1  \cf0 :\cf1  \cf0 Boolean)\cf3 ');
\par 
\par \cf1   \cf0 Imm32ReleaseContext(\cf1  \cf0 hWnd\cf1  \cf0 :\cf1  \cf0 HWND;\cf1  \cf0 hImc\cf1  \cf0 :\cf1  \cf0 HIMC)\cf1  \cf0 :\cf1  \cf0 Boolean\cf3 ');
\par \cf1   \cf0 Imm32GetConversionStatus(\cf1  \cf0 hImc\cf1  \cf0 :\cf1  \cf0 HIMC;\cf1  \cf0 var\cf1  \cf0 Conversion,\cf1  \cf0 Sentence\cf1  \cf0 :\cf1  \cf0 DWORD)\cf1  \cf0 :\cf1  \cf0 Boolean\cf3 ');
\par \cf1   \cf0 Imm32SetConversionStatus(\cf1  \cf0 hImc\cf1  \cf0 :\cf1  \cf0 HIMC;\cf1  \cf0 Conversion,\cf1  \cf0 Sentence\cf1  \cf0 :\cf1  \cf0 DWORD)\cf1  \cf0 :\cf1  \cf0 Boolean\cf3 ');
\par \cf1   \cf0 Imm32SetOpenStatus(\cf1  \cf0 hImc\cf1  \cf0 :\cf1  \cf0 HIMC;\cf1  \cf0 fOpen\cf1  \cf0 :\cf1  \cf0 Boolean)\cf1  \cf0 :\cf1  \cf0 Boolean\cf3 ');
\par \cf1   \cf0 Imm32SetCompositionWindow(\cf1  \cf0 hImc\cf1  \cf0 :\cf1  \cf0 HIMC;\cf1  \cf0 lpCompForm\cf1  \cf0 :\cf1  \cf0 PCOMPOSITIONFORM)\cf1  \cf0 :\cf1  \cf0 Boolean\cf3 ');
\par \cf1   \cf0 Imm32SetCompositionFont(\cf1  \cf0 hImc\cf1  \cf0 :\cf1  \cf0 HIMC;\cf1  \cf0 lpLogfont\cf1  \cf0 :\cf1  \cf0 PLOGFONTA)\cf1  \cf0 :\cf1  \cf0 Boolean\cf3 ');
\par \cf1   \cf0 Imm32GetCompositionString(\cf1  \cf0 hImc\cf1  \cf0 :\cf1  \cf0 HIMC;\cf1  \cf0 dWord1\cf1  \cf0 :\cf1  \cf0 DWORD;\cf1  \cf0 lpBuf\cf1  \cf0 :\cf1  \cf0 pointer;\cf1  \cf0 dwBufLen\cf1  \cf0 :\cf1  \cf0 DWORD)\cf1  \cf0 :\cf1  \cf0 Longint\cf3 ');
\par \cf1   \cf0 Imm32IsIME(\cf1  \cf0 hKl\cf1  \cf0 :\cf1  \cf0 HKL)\cf1  \cf0 :\cf1  \cf0 Boolean\cf3 ');
\par \cf1   \cf0 Imm32NotifyIME(\cf1  \cf0 hImc\cf1  \cf0 :\cf1  \cf0 HIMC;\cf1  \cf0 dwAction,\cf1  \cf0 dwIndex,\cf1  \cf0 dwValue\cf1  \cf0 :\cf1  \cf0 DWORD)\cf1  \cf0 :\cf1  \cf0 Boolean\cf3 ');\}
\par \cf1   
\par   \cf2\i //TCheckListBox
\par \i0\cf1   \cf2\i //DrawButtonFace
\par \i0\cf1     \cf2\i //TDbEngineErrorDlg 
\par \i0\cf1  \cf0 \{\cf1       \cf0 Width\cf1  \cf0 :=\cf1  \cf4 100\cf0 ;
\par \cf1   \cf0 Height\cf1  \cf0 :=\cf1  \cf4 100\cf0 ;
\par \cf1   \cf0 ControlStyle\cf1  \cf0 :=\cf1  \cf0 [csDoubleClicks,\cf1  \cf0 csCaptureMouse,\cf1  \cf0 csDisplayDragImage,\cf1  \cf0 csPannable];
\par \cf1   \cf0 FButtonItems\cf1  \cf0 :=\cf1  \cf0 GetButtonsClass.Create(Self);
\par \cf1   \cf0 FButtonOptions\cf1  \cf0 :=\cf1  \cf0 [gboShowCaptions];
\par \cf1   \cf0 FBorderStyle\cf1  \cf0 :=\cf1  \cf0 bsSingle;\}
\par \cf1   \cf2\i //TMargins
\par \i0\cf1     \cf2\i //TCheckListBox
\par \i0\cf1     \cf2\i //TSpeedButton  
\par \i0\cf1       \cf2\i //Tpadding
\par \i0\cf1     
\par    \cf2\i //TWinControlActionLink 
\par \i0\cf1    \cf0 GetComCtlVersion
\par \cf1    \cf2\i //CheckToolMenuDropdown
\par \i0\cf1      \cf2\i //InitCommonControl
\par \i0\cf1        \cf2\i //CheckCommonControl(42);
\par \i0\cf1        
\par       \cf2\i // TToolWindow
\par \i0\cf1      
\par      
\par      
\par \cf0 end;\cf1     
\par 
\par 
\par \cf0 function\cf1  \cf0 SplitToken(\b const\b0\cf1  \cf0 Text:\cf1  \cf0\b string\b0 ;\cf1  \cf0 SplitChar:\cf1  \cf0 Char;
\par \cf1                           \cf0 var\cf1  \cf0 First,\cf1  \cf0 Last:\cf1  \cf0\b string\b0 ):\cf1  \cf0 Boolean;
\par var\cf1   \cf0 SplitPos:\cf1  \cf0 Integer;
\par \cf1       \cf0 ec:\cf1  \cf0 EJclError;
\par begin
\par \cf1   \cf0 Result:=\cf1  \cf0 False;
\par \cf1   \cf0 SplitPos:=\cf1  \cf0 Pos(SplitChar,\cf1  \cf0 Text);
\par \cf1   \cf0\b if\b0\cf1  \cf0 SplitPos\cf1  \cf0 =\cf1  \cf4 0\cf1  \cf0 then\cf1  \cf0 Exit;
\par \cf1   \cf0 First:=\cf1  \cf0 Trim(Copy(Text,\cf1  \cf4 1\cf0 ,\cf1  \cf0 SplitPos\cf1  \cf0 -\cf4 1\cf0 ));
\par \cf1   \cf0 Last:=\cf1  \cf0 Trim(Copy(Text,\cf1  \cf0 SplitPos\cf1  \cf0 +\cf4 1\cf0 ,\cf1  \cf0 Length(Text)\cf1  \cf0 -SplitPos));
\par \cf1   \cf0 Result:=\cf1  \cf0 (First\cf1  \cf0 <>\cf3 ''\cf0 )\cf1  \cf0 and\cf1  \cf0 (Last\cf1  \cf0 <>\cf3 ''\cf0 );
\par end;
\par 
\par 
\par function\cf1  \cf0 TForm1_scrollAllNode(aNode:\cf1  \cf0 TalXmlNode):\cf1  \cf0 Integer;
\par Var\cf1  \cf0 aStack:\cf1  \cf0 Tstack;
\par \cf1     \cf0 i:\cf1  \cf0 integer;
\par begin
\par \cf1   \cf0 Result\cf1  \cf0 :=\cf1  \cf4 0\cf0 ;
\par \cf1   \cf0 aStack\cf1  \cf0 :=\cf1  \cf0 Tstack.Create;
\par \cf1   \cf0\b try
\par \b0\cf1      \cf0 For\cf1  \cf0 i\cf1  \cf0 :=\cf1  \cf4 0\cf1  \cf0 to\cf1  \cf0 aNode.ChildNodes.Count\cf1  \cf0 -\cf1  \cf4 1\cf1  \cf0\b do
\par \b0\cf1         \cf0 aStack.Push((ANode.ChildNodes[i]));
\par \cf1          \cf0 While\cf1  \cf0 astack.Count\cf1  \cf0 >\cf1  \cf4 0\cf1  \cf0\b do\b0\cf1  \cf0 begin
\par \cf1         \cf0 inc(result);
\par \cf1         \cf0 aNode\cf1  \cf0 :=\cf1  \cf0 TalxmlNode(astack.Pop);
\par \cf1         \cf0 If\cf1  \cf0 assigned(ANode.ChildNodes)\cf1  \cf0 then
\par \cf1           \cf0 For\cf1  \cf0 i\cf1  \cf0 :=\cf1  \cf4 0\cf1  \cf0 to\cf1  \cf0 ANode.ChildNodes.Count\cf1  \cf0 -\cf1  \cf4 1\cf1  \cf0\b do
\par \b0\cf1             \cf0 aStack.Push((ANode.ChildNodes[i]));
\par \cf1            \cf0 If\cf1  \cf0 assigned(ANode.AttributeNodes)\cf1  \cf0 then
\par \cf1           \cf0 For\cf1  \cf0 i\cf1  \cf0 :=\cf1  \cf4 0\cf1  \cf0 to\cf1  \cf0 ANode.attributeNodes.Count\cf1  \cf0 -\cf1  \cf4 1\cf1  \cf0\b do
\par \b0\cf1             \cf0 aStack.Push((ANode.AttributeNodes[i]));
\par \cf1       \cf0 end;
\par \cf1   \cf0\b finally
\par \b0\cf1     \cf0 aStack.Free;
\par \cf1   \cf0 end;
\par 
\par end;
\par 
\par function\cf1  \cf0 IntToStrZeroPad(Value,\cf1  \cf0 Count:\cf1  \cf0 Integer):\cf1  \cf0 AnsiString;
\par begin
\par \cf1   \cf0 Result\cf1  \cf0 :=\cf1  \cf0 IntToStr(Value);
\par \cf1   \cf0\b if\b0\cf1  \cf0 Length(Result)\cf1  \cf0 <\cf1  \cf0 Count\cf1  \cf0 then
\par \cf1     \cf0 Result\cf1  \cf0 :=\cf1  \cf0 StrFillChar(\cf3 '0'\cf0 ,\cf1  \cf0 Count\cf1  \cf0 -\cf1  \cf0 Length(Result))\cf1  \cf0 +\cf1  \cf0 Result;
\par end;
\par 
\par function\cf1  \cf0 JclGUIDToString(\b const\b0\cf1  \cf0 GUID:\cf1  \cf0 TGUID):\cf1  \cf0\b string\b0 ;
\par begin
\par \cf1   \cf0 \{\cf4 $\cf0 IFDEf\cf1  \cf0 CLR\}
\par \cf1   \cf0 Result\cf1  \cf0 :=\cf1  \cf0 GUID.ToString();
\par \cf1   \cf0 \{\cf4 $\cf0 ELSE\}
\par \cf1   \cf0 Result\cf1  \cf0 :=\cf1  \cf0 Format(\cf3 '\{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x\}'\cf0 ,
\par \cf1     \cf0 [GUID.D1,\cf1  \cf0 GUID.D2,\cf1  \cf0 GUID.D3,\cf1  \cf0 GUID.D4[\cf4 0\cf0 ],\cf1  \cf0 GUID.D4[\cf4 1\cf0 ],\cf1  \cf0 GUID.D4[\cf4 2\cf0 ],
\par \cf1      \cf0 GUID.D4[\cf4 3\cf0 ],\cf1  \cf0 GUID.D4[\cf4 4\cf0 ],\cf1  \cf0 GUID.D4[\cf4 5\cf0 ],\cf1  \cf0 GUID.D4[\cf4 6\cf0 ],\cf1  \cf0 GUID.D4[\cf4 7\cf0 ]]);
\par \cf1   \cf0 \{\cf4 $\cf0 ENDIF\cf1  \cf0 CLR\}
\par end;
\par 
\par 
\par function\cf1  \cf0 GetOsVersionInfo2:\cf1  \cf0 TOSVersionInfo;\cf1  
\par \cf0 var
\par \cf1   \cf0 verInfo:\cf1  \cf0 TOSVersionInfo;
\par begin
\par \cf1   \cf0 verinfo.dwOSVersionInfoSize:=\cf1  \cf0\b sizeof\b0 (verinfo);
\par \cf1   \cf0 GetVersionEx(Verinfo);
\par \cf1   \cf0 result:=\cf1  \cf0 Verinfo;
\par end;\cf1   
\par 
\par \cf0 var\cf1   \cf0 verInfo:\cf1  \cf0 TOSVersionInfo;
\par 
\par Begin\cf1   \cf2\i //Main
\par //<Executable statements>
\par \i0\cf1   \cf2\i //TOutlookExport_Spy;
\par \i0\cf1   \cf0 Writeln(\cf3 ''\cf0 );
\par \cf1   \cf2\i //Writeln('Start Command of DLL: '+CheckIEStartCommand);  
\par //<Definitions>  
\par \i0\cf1    \cf2\i //ares:= TResolver.create;
\par \i0\cf1  \cf0 \{\cf1  \cf0 with\cf1  \cf0 TResolver.create\cf1  \cf0\b do\b0\cf1  \cf0 begin
\par \cf1    \cf2\i //writeln(inttostr(GetHostByName(gethostname)));
\par \i0\cf1     \cf0 Free;\cf1    \cf0 end;\cf1   \cf0 \}
\par \cf1     \cf0 \{repeat\cf1  
\par      \cf0 TApplication_PaintView(aform.canvas);
\par \cf1      \cf0\b switch\b0 :=\cf1  \cf0 NOT\cf1  \cf0\b switch\b0 ;
\par \cf1      \cf0 Sleep(\cf4 20\cf0 );
\par \cf1    \cf0 until\cf1  \cf0 isKeyPressed\cf1  \cf0 or\cf1  \cf0 FWait;\}
\par \cf1     \cf0 \{with\cf1  \cf0 TledForm.create(self)\cf1  \cf0\b do\b0\cf1  \cf0 begin
\par \cf1     \cf0 showmodal;\cf1  \cf0 free;\cf1  \cf0 end;\}\cf1  
\par  \cf2\i // function GetMacAddresses(const Machine: string; const Addresses: TStrings):Integer;
\par \i0\cf1    \cf0 OVCInternationalDemoClass;
\par \cf1   
\par  \cf2\i //GetProcessMemoryInfo(Process 
\par \i0\cf1      \cf0 writeln(\cf3 'mem from dll '\cf0 +inttostr(ProcessMemoryUsage(GetCurrentProcessID)));
\par \cf1      \cf0 writeln(\cf3 'page from dll '\cf0 +inttostr(ProcessPageUsage(GetCurrentProcessID)));
\par \cf1      \cf0 writeln(\cf3 'proc all from dll '
\par \cf1                  \cf0 +inttostr(ProcessAllRec(GetCurrentProcessID).workingsetsize));
\par \cf1      \cf0 writeln(\cf3 'proc peak workingset '
\par \cf1               \cf0 +inttostr(ProcessAllRec(GetCurrentProcessID).PeakWorkingSetSize\cf1  \cf0 div\cf1  \cf4 1024\cf0 ));
\par \cf1      \cf0 writeln(\cf3 'proc peak paged use '
\par \cf1               \cf0 +inttostr(ProcessAllRec(GetCurrentProcessID).QuotaPeakPagedPoolUsage));
\par \cf1      \cf0 writeln(\cf3 'proc page peak file '
\par \cf1               \cf0 +inttostr(getProcMemInfo(GetCurrentProcessID).PeakPagefileUsage\cf1  \cf0 div\cf1  \cf4 1024\cf0 ));
\par \cf1  
\par     \cf2\i // SplitImages(self);
\par \i0\cf1      \cf2\i //deletefiles(PICPATH,'*.bmp');
\par \i0\cf1       \cf2\i //GetCurrentHwProfile( var lpHwProfileInfo : THWProfileInfo) : BOOL');
\par \i0\cf1         \cf2\i //SetPriorityClass
\par \i0\cf1         \cf2\i //GetPriorityClass
\par \i0\cf1      \cf2\i //OpenClipboard( 
\par \i0\cf1      \cf2\i //booleantostr(false);
\par \i0\cf1      \cf2\i //JclGUIDToString
\par \i0\cf1        \cf2\i //TJclNumericFormat 
\par \i0\cf1           \cf2\i //function IsClass(Address: Pointer): Boolean;
\par \i0\cf1           \cf2\i //function IsObject(Address: Pointer): Boolean;
\par \i0\cf1            \cf2\i //IsClass(Address: Pointer): Boolean;
\par \i0\cf1            \cf2\i //IsObject(Address: Pointer): Boolean;
\par \i0\cf1            \cf2\i //ReadKey
\par \i0\cf1              \cf2\i //IntToStrZeroPad
\par \i0\cf1            \cf2\i //  StrFillChar
\par \i0\cf1            \cf2\i //EndDialog( 
\par \i0\cf1              \cf2\i //GetDlgItem(
\par \i0\cf1              \cf2\i //SetDlgItemInt( 
\par \i0\cf1                \cf2\i //dialogbox
\par \i0\cf1          \cf2\i //TQuaternionList(CL: TPSPascalCompiler);
\par //TByteList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf2\i //TSingleList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf2\i //TIntegerList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf2\i //TTexPointList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf2\i //TVectorList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf2\i //TAffineVectorList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf2\i //TBaseVectorList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf2\i //TBaseList(CL: TPSPascalCompiler);
\par \i0\cf1    \cf2\i //VectorLists(CL: TPSPascalCompiler);
\par \i0\cf1    \cf2\i //TXIntegerList
\par \i0\cf1    \cf2\i //TJclSimpleLog
\par \i0\cf1      \cf2\i //jExecute 
\par \i0\cf1      \cf2\i //TClipRect
\par \i0\cf1      \cf2\i //TColor
\par \i0\cf1        \cf2\i //PointLineDistance
\par \i0\cf1          \cf2\i //TSkeleton
\par \i0\cf1          \cf2\i //Turn
\par \i0\cf1        \cf2\i //SetMatrix
\par \i0\cf1        \cf2\i //ScaleMatrix
\par \i0\cf1        \cf2\i //TSpaceContains
\par \i0\cf1          \cf2\i //TriangleArea
\par \i0\cf1          \cf2\i //TVertex
\par \i0\cf1          \cf2\i //TVectorGL
\par \i0\cf1          \cf2\i //IsVolumeClipped
\par \i0\cf1          \cf2\i //DivMod
\par \i0\cf1          \cf2\i //ConvertRotation
\par \i0\cf1          \cf2\i //TRectangle
\par \i0\cf1          \cf2\i //TFrustum
\par \i0\cf1        \cf0 writeln(booleantostr(samepath(exepath,\cf1  \cf0 exepath)))
\par \cf1        
\par   \cf0 verinfo:=\cf1  \cf0 GetOsVersionInfo2;
\par \cf1   \cf0 writeln(\cf3 'OS Verinfo '\cf0 +inttostr(Verinfo.dwMajorVersion))
\par \cf1   \cf0 writeln(\cf3 'OS Verinfo '\cf0 +inttostr(Verinfo.dwMinorVersion))
\par \cf1   \cf0 writeln(\cf3 'OS Versizeinfo '\cf0 +inttostr(Verinfo.dwOSVersionInfoSize))
\par \cf1   \cf2\i //Function IsDelphiProject( const FileName : string) : Boolean');
\par \i0\cf1   \cf0 writeln(booleantoStr(IsDelphiProject(exepath+\cf3 'maxbox3.exe'\cf0 )));
\par \cf1   \cf2\i //FileBackup(const 
\par \i0\cf1   
\par   \cf2\i //TChangeFinder_SearchDirectories(exepath+'examples','*.txt');
\par \i0\cf1   \cf2\i //RemoveSpaces2
\par \i0\cf1     \cf0 \{with\cf1  \cf0 TCustomComboBoxStrings.create\cf1  \cf0\b do\b0\cf1  \cf0 begin
\par \cf1     \cf0 deleter
\par \cf1     \cf0 indexof
\par \cf1     \cf0 free
\par \cf1     \cf0 end;\}
\par \cf1     \cf2\i //IsPositiveResult
\par \i0\cf1     \cf2\i //IsAnAllResult  new
\par \i0\cf1       \cf2\i //IsAbortResult
\par \i0\cf1       \cf2\i //IsNegativeResult
\par \i0\cf1       \cf2\i //StripAllFromResult
\par \i0\cf1         \cf2\i //TSizeConstraints
\par \i0\cf1         \cf2\i //TCreateParams
\par \i0\cf1            \cf2\i //TButtonGroup 
\par \i0\cf1            \cf2\i //TOleStream
\par \i0\cf1            \cf2\i //TStringsAdapter
\par \i0\cf1            \cf2\i //SetOleStrings(Strings: 
\par \i0\cf1            \cf2\i //TAlignment
\par \i0\cf1            
\par            
\par      \cf2\i //TAfMemo       
\par \i0\cf1            
\par             
\par            
\par             
\par 
\par     \cf0 with\cf1  \cf0 TGridPanel.create(self)\cf1  \cf0\b do\b0\cf1  \cf0 begin
\par \cf1     \cf0 free
\par \cf1     \cf0 end;
\par \cf1     \cf2\i //TColorBox
\par \i0\cf1          
\par \cf0 END.\cf1  
\par 
\par \cf0 small\cf1  \cf0 set\cf1  \cf0\b for\b0\cf1  \cf0 arduino\cf1  \cf0 and\cf1  \cf0 android\cf1  \cf0 testing\cf1  
\par 
\par \cf0 var\cf1  \cf0 drive:\cf1  \cf0\b string\b0 [\cf4 20\cf0 ];
\par \cf1     \cf0 mycf:\cf1  \cf0 TChangeFinder;
\par begin
\par \cf1   \cf0 screen.cursor:=crHourglass;
\par \cf1     \cf0 drive:=\cf1  \cf0 dcbHD.Drive;
\par \cf1     \cf0 drive:=\cf1  \cf0 drive\cf1  \cf0 +\cf1  \cf3 ':'\cf0 ;
\par \cf1     \cf0 mycf:=\cf1  \cf0 TChangeFinder.prepList_and_Date(frmMain.livchangefind);
\par \cf1     \cf0 mycf.SearchDirectories(drive\cf1  \cf0 +\cf1  \cf3 '\\','\cf0 *.*\cf3 ');
\par \cf1     \cf0 mycf.Free;
\par \cf1     \cf0 screen.cursor:=crDefault;
\par end;\cf1  \cf0 \}
\par 
\par 
\par 
\par http:\cf2\i //glscene.sourceforge.net/wikka/HomePage
\par 
\par \i0\cf0 \{-Modulename\cf1  \cf0 and\cf1  \cf0 path:\cf1  \cf0 udwsfiler
\par \cf2\i //
\par //D:\\franktech\\Delphmax\\dws\\DWSServer.mpb
\par //Category    Access method
\par //
\par //Developer kleiner kommunikation
\par //Last Modification on 30.06.03 17:51:54:
\par //question is destructor of grid
\par \i0\cf1   \cf0 descript\cf1  \cf0\b as\b0\cf1  \cf0 a\cf1  \cf0\b new\b0\cf1  \cf0 field\cf1  \cf0 on\cf1  \cf4 20.6.03
\par \cf1   \cf0 modified\cf1  \cf0 flag\cf1  \cf0 on\cf1  \cf4 30.6.03
\par \cf2\i //==========================================================================\}
\par \i0\cf0 unit\cf1  \cf0 udwsfilerwiz;
\par 
\par 
\par \b interface
\par 
\par \b0 uses\cf1  \cf0 QGrids;
\par 
\par type
\par \cf1  \cf0 TAppData\cf1  \cf0 =\cf1  \cf0 record
\par \cf1    \cf0 Name:\cf1  \cf0\b string\b0 [\cf4 50\cf0 ];
\par \cf1    \cf0 Size:\cf1  \cf0 longint;
\par \cf1    \cf0 Release:\cf1  \cf0\b string\b0 [\cf4 30\cf0 ];
\par \cf1    \cf0 descript:\cf1  \cf0\b string\b0 [\cf4 80\cf0 ];
\par \cf1  \cf0 end;
\par 
\par \cf1   \cf0 TBuildAppGrid\cf1  \cf0 =\cf1  \cf0\b class\b0\cf1  \cf0 (TObject)
\par \cf1   \cf0\b private
\par \b0\cf1     \cf0 aGrid:\cf1  \cf0 TStringGrid;
\par \cf1     \cf0 app:\cf1  \cf0 TAppData;
\par \cf1     \cf0 f:\cf1  \cf0 file\cf1  \cf0 of\cf1  \cf0 TAppData;
\par \cf1     \cf0 FaDatfile:\cf1  \cf0 ShortString;
\par \cf1     \cf0 Fmodified:\cf1  \cf0 Boolean;
\par \cf1   \cf0\b protected
\par \b0\cf1     \cf0 function\cf1  \cf0 GetaDatfile:\cf1  \cf0 ShortString;
\par \cf1     \cf0 procedure\cf1  \cf0 SetaDatfile(\b const\b0\cf1  \cf0 Value:\cf1  \cf0 ShortString);
\par \cf1   \cf0\b public
\par \b0\cf1     \cf0 constructor\cf1  \cf0 initGrid(vGrid:\cf1  \cf0 TStringGrid;\cf1  \cf0 vFile:\cf1  \cf0 shortString);
\par \cf1     \cf0 procedure\cf1  \cf0 fillGrid;
\par \cf1     \cf0 procedure\cf1  \cf0 storeGrid;
\par \cf1     \cf0 property\cf1  \cf0 aDatfile:\cf1  \cf0 ShortString\cf1  \cf0 read\cf1  \cf0 GetaDatfile\cf1  \cf0 write\cf1  \cf0 SetaDatfile;
\par \cf1     \cf0 property\cf1  \cf0 modified:\cf1  \cf0 Boolean\cf1  \cf0 read\cf1  \cf0 Fmodified\cf1  \cf0 write\cf1  \cf0 Fmodified;
\par \cf1   \cf0 end;
\par 
\par 
\par implementation
\par 
\par uses\cf1  \cf0 sysutils,\cf1  \cf0 QDialogs,\cf1  \cf0 QControls,
\par \cf1   \cf0 QStdCtrls;
\par 
\par 
\par \{
\par ********************************\cf1  \cf0 TBuildAppGrid\cf1  \cf0 *********************************
\par \}
\par constructor\cf1  \cf0 TBuildAppGrid.initGrid(vGrid:\cf1  \cf0 TStringGrid;\cf1  \cf0 vFile:\cf1  \cf0 shortString);
\par begin
\par \cf1   \cf0 aGrid:=\cf1  \cf0 vGrid;
\par \cf1   \cf0 aDatfile:=\cf1  \cf0 vFile;
\par \cf1   \cf0 with\cf1  \cf0 aGrid\cf1  \cf0\b do\b0\cf1  \cf0 begin
\par \cf1     \cf0 ScrollBars:=\cf1  \cf0 ssAutoVertical;
\par \cf1     \cf0 FixedRows\cf1  \cf0 :=\cf1  \cf4 1\cf0 ;
\par \cf1     \cf0 FixedCols:=\cf1  \cf4 0\cf0 ;
\par \cf1     \cf0 ColCount:=\cf1  \cf4 4\cf0 ;
\par \cf1     \cf0 RowCount:=\cf1  \cf4 2\cf0 ;\cf1  \cf2\i //title is one row
\par \i0\cf1   \cf0 end;
\par end;
\par 
\par procedure\cf1  \cf0 TBuildAppGrid.fillGrid;
\par var
\par \cf1   \cf0 crow:\cf1  \cf0 Integer;
\par begin
\par \cf1   \cf0 crow\cf1  \cf0 :=\cf1  \cf4 1\cf0 ;
\par \cf1   \cf0 with\cf1  \cf0 aGrid\cf1  \cf0\b do\b0\cf1  \cf0 begin
\par \cf1     \cf0 Cells[\cf4 0\cf0 ,\cf4 0\cf0 ]:=\cf1  \cf3 'Application Name'\cf0 ;
\par \cf1     \cf0 ColWidths[\cf4 0\cf0 ]:=\cf1  \cf4 120\cf0 ;
\par \cf1     \cf0 Cells[\cf4 1\cf0 ,\cf4 0\cf0 ]:=\cf1  \cf3 'App Size'\cf0 ;
\par \cf1     \cf0 ColWidths[\cf4 1\cf0 ]:=\cf1  \cf4 60\cf0 ;
\par \cf1     \cf0 Cells[\cf4 2\cf0 ,\cf4 0\cf0 ]:=\cf1  \cf3 'Release Date'\cf0 ;
\par \cf1     \cf0 ColWidths[\cf4 2\cf0 ]:=\cf1  \cf4 90\cf0 ;
\par \cf1     \cf0 Cells[\cf4 3\cf0 ,\cf4 0\cf0 ]:=\cf1  \cf3 'Description'\cf0 ;
\par \cf1     \cf0 ColWidths[\cf4 3\cf0 ]:=\cf1  \cf4 140\cf0 ;
\par \cf1     \cf0\b if\b0\cf1  \cf0 aDatFile\cf1  \cf0 <>\cf1  \cf3 ''\cf1  \cf0 then\cf1  \cf0 begin
\par \cf1       \cf0 AssignFile(f,aDatFile);
\par \cf1       \cf0 Reset(f);
\par \cf1       \cf0\b try
\par \b0\cf1         \cf0\b while\b0\cf1  \cf0 not\cf1  \cf0 Eof(F)\cf1  \cf0\b do\b0\cf1  \cf0 begin
\par \cf1           \cf0 Read\cf1  \cf0 (F,\cf1  \cf0 app);
\par \cf1           \cf0 Cells[\cf4 0\cf0 ,crow]:=\cf1  \cf0 app.Name;
\par \cf1           \cf0 Cells[\cf4 1\cf0 ,crow]:=\cf1  \cf0 intToStr(app.size);
\par \cf1           \cf0 Cells[\cf4 2\cf0 ,crow]:=\cf1  \cf0 app.Release;
\par \cf1           \cf0 Cells[\cf4 3\cf0 ,crow]:=\cf1  \cf0 app.descript;
\par \cf1           \cf0 Inc(cRow);
\par \cf1           \cf0 RowCount:=\cf1  \cf0 crow\cf1  \cf0 +\cf4 1\cf0 ;\cf1   \cf2\i //new entry
\par \i0\cf1         \cf0 end;
\par \cf1       \cf0\b finally
\par \b0\cf1         \cf0 CloseFile(f);
\par \cf1       \cf0 end;
\par \cf1     \cf0 end;\cf2\i // if FileExists...
\par \i0\cf1   \cf0 end;\cf1  \cf2\i //with
\par \i0\cf0 end;
\par 
\par function\cf1  \cf0 TBuildAppGrid.GetaDatfile:\cf1  \cf0 ShortString;
\par begin
\par \cf1   \cf0\b if\b0\cf1  \cf0 FileExists(FaDatFile)\cf1  \cf0 then
\par \cf1   \cf0 result:=\cf1  \cf0 FaDatFile
\par \cf1   \cf0\b else\b0\cf1  \cf0 begin
\par \cf1      \cf0 AssignFile(f,\cf1  \cf0 FaDatFile);
\par \cf1      \cf0 Rewrite(f);
\par \cf1      \cf0 closefile(f);
\par \cf1      \cf0 result:=\cf1  \cf0 FaDatFile;
\par \cf1   \cf0 end;
\par \cf1   
\par   \cf0 with\cf1  \cf0 TCustomComboBoxStrings.create\cf1  \cf0\b do\b0\cf1  \cf0 begin
\par \cf1     \cf0 deleter
\par \cf1     \cf0 indexof
\par \cf1     \cf0 free
\par \cf1     \cf0 end;
\par end;
\par 
\par procedure\cf1  \cf0 TBuildAppGrid.SetaDatfile(\b const\b0\cf1  \cf0 Value:\cf1  \cf0 ShortString);
\par begin
\par \cf1   \cf0\b if\b0\cf1  \cf0 FaDatfile\cf1  \cf0 <>\cf1  \cf0 Value\cf1  \cf0 then
\par \cf1   \cf0 begin
\par \cf1     \cf0 FaDatfile\cf1  \cf0 :=\cf1  \cf0 Value;
\par \cf1   \cf0 end;
\par end;
\par 
\par procedure\cf1  \cf0 TBuildAppGrid.storeGrid;
\par var
\par \cf1   \cf0 crow:\cf1  \cf0 Integer;
\par begin
\par \cf1   \cf0\b if\b0\cf1  \cf0 FModified\cf1  \cf0 then
\par \cf1   \cf0\b if\b0\cf1  \cf0 MessageDlg(\cf3 'Save Changes in '\cf1  \cf0 +
\par \cf1              \cf0 aDatFile,\cf1  \cf0 mtConfirmation,mbOkCancel,\cf4 0\cf0 )\cf1  \cf0 =\cf1  \cf0 mrOK\cf1  \cf0 then
\par \cf1    \cf0 begin
\par \cf1      \cf0 AssignFile(f,\cf1  \cf0 aDatfile);
\par \cf1      \cf0 Rewrite(f);
\par \cf1    \cf0\b try
\par \b0\cf1      \cf0\b for\b0\cf1  \cf0 crow:=\cf1  \cf4 1\cf1  \cf0 to\cf1  \cf0 Pred(aGrid.RowCount)\cf1  \cf0\b do\b0\cf1  \cf0 begin
\par \cf1        \cf0 app.Name:=\cf1  \cf0 aGrid.Cells[\cf4 0\cf0 ,\cf1  \cf0 crow];
\par \cf1        \cf0 app.size:=\cf1  \cf0 strToInt(aGrid.Cells[\cf4 1\cf0 ,\cf1  \cf0 crow]);
\par \cf1        \cf0 app.Release:=\cf1  \cf0 aGrid.Cells[\cf4 2\cf0 ,\cf1  \cf0 crow];
\par \cf1        \cf0 app.descript:=\cf1  \cf0 aGrid.Cells[\cf4 3\cf0 ,\cf1  \cf0 crow];
\par \cf1        \cf0 Write\cf1  \cf0 (f,\cf1  \cf0 app);
\par \cf1      \cf0 end;
\par \cf1    \cf0\b finally
\par \b0\cf1      \cf0 CloseFile(f);
\par \cf1    \cf0 end;
\par \cf1   \cf0 end;\cf1  \cf2\i //if MessageDlg...
\par \i0\cf0 end;
\par 
\par end.
\par 
\par 
\par \cf1  \cf0\b namespace\b0\cf1  \cf0 ch.ecotronics.arduino.time\cf1  \cf0 \{
\par \cf1    \cf0\b class\b0\cf1  \cf0 ArduinoTimeSetter\cf1  \cf0 \{
\par \cf1       \cf0\b static\b0\cf1  \cf0\b void\b0\cf1  \cf0 Main(\b string\b0 []\cf1  \cf0 args)\cf1  \cf0 \{
\par \cf1         \cf0 Settings\cf1  \cf0 settings\cf1  \cf0 =\cf1  \cf0\b new\b0\cf1  \cf0 Settings();
\par \cf1         \cf0 SerialPort\cf1  \cf0 port\cf1  \cf0 =\cf1  \cf0\b new\b0\cf1  \cf0 SerialPort(settings.port,\cf4 9600\cf0 );
\par \cf1         \cf0 DateTime\cf1  \cf0 now\cf1  \cf0 =\cf1  \cf0 DateTime.Now;
\par \cf1         \cf0 port.Open();
\par \cf1         \cf2\i //time formatting, be aware new format (incl weekdays) for DS1307
\par \i0\cf1         \cf0 String\cf1  \cf0 arduinoTime\cf1  \cf0 =\cf1  \cf0 String.Format(\cf3 "\{0:HHmmssddMMyy\}"\cf0 ,DateTime.Now)+((\b int\b0 )
\par \cf1         \cf0 DateTime.Now.DayOfWeek);
\par \cf1         \cf0 Console.WriteLine(arduinoTime);
\par \cf1         \cf2\i //pass the time to COM
\par \i0\cf1         \cf0 port.Write(arduinoTime);
\par \cf1         \cf0\b while\b0\cf1  \cf0 (\b true\b0 )\cf1  \cf0 \{
\par \cf1           \cf0 Console.WriteLine(\cf3 "From Arduino "\cf1  \cf0 +\cf1  \cf0 port.ReadLine());
\par \cf1         \cf0 \}
\par \cf1       \cf0 \}
\par \cf1    \cf0 \}
\par \cf1  \cf0 \}
\par 
\par 
\par und\cf1  \cf0 am\cf1  \cf0 TV\cf1  \cf0\b in\b0\cf1  \cf0 SRF\cf1  \cf0 Info\cf1    \cf0 um\cf1  \cf4 22\cf0 :\cf4 30\cf1  \cf0 oder\cf1  \cf0 um\cf1  \cf4 23\cf1  \cf0 Uhr
\par 
\par Wieso\cf1  \cf0 dann\cf1  \cf0 ausgerechnet\cf1  \cf0 um\cf1  \cf4 10\cf1  \cf0 vor\cf1  \cf4 10\cf0 !?!
\par ----Simple\cf1  \cf0 Browser\cf1  \cf0 started----
\par ----Simple\cf1  \cf0 Browser\cf1  \cf0 started----
\par 
\par \cf1      \cf0 RegisterMethod(\cf3 'Constructor Create(AOwner: TComponent);'\cf0 );
\par \cf1     \cf0 RegisterMethod(\cf3 'Procedure Free'\cf0 );
\par \cf1  
\par  
\par  \cf0 RegisterConstructor(\cf4 @\cf0 TCustomRadioGroup.Create,\cf1  \cf3 'Create'\cf0 );
\par \cf1      \cf0 RegisterMethod(\cf4 @\cf0 TCustomRadioGroup.Free,\cf1  \cf3 'Free'\cf0 );
\par \cf1  
\par  
\par    \cf0 RegisterMethod(\cf3 'Constructor Create(AOwner: TComponent);'\cf0 );
\par \cf1    \cf0 RegisterMethod(\cf3 'Procedure Free'\cf0 );
\par \cf1    \cf0 RegisterMethod(\cf3 'function GetControlsAlignment: TAlignment;'\cf0 );
\par \cf1     \cf0 RegisterMethod(\cf3 'procedure FlipChildren(AllLevels: Boolean);'\cf0 );
\par 
\par 
\par \cf1  \cf2\i //function Focused
\par \i0\cf1    \cf0 RegisterConstructor(\cf4 @\cf0 TCUSTOMMEMO.Create,\cf1  \cf3 'Create'\cf0 );
\par \cf1    \cf0 RegisterMethod(\cf4 @\cf0 TCUSTOMMEMO.Free,\cf1  \cf3 'Free'\cf0 );
\par \cf1    \cf0 RegisterMethod(\cf4 @\cf0 TCUSTOMMEMO.GetControlsAlignment,\cf1  \cf3 'GetControlsAlignment'\cf0 );
\par \cf1  
\par      \cf0 RegisterPublishedProperties;
\par \cf1      
\par     \cf0 RegisterPublishedProperties;
\par \cf1    \cf0 RegisterProperty(\cf3 'ONCLICK'\cf0 ,\cf1  \cf3 'TNOTIFYEVENT'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'ONDBLCLICK'\cf0 ,\cf1  \cf3 'TNOTIFYEVENT'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'ONENTER'\cf0 ,\cf1  \cf3 'TNOTIFYEVENT'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'ONEXIT'\cf0 ,\cf1  \cf3 'TNOTIFYEVENT'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1      \cf0 RegisterProperty(\cf3 'ONMOUSEDOWN'\cf0 ,\cf1  \cf3 'TMouseEvent'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'ONMOUSEMOVE'\cf0 ,\cf1  \cf3 'TMouseMoveEvent'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'ONMOUSEUP'\cf0 ,\cf1  \cf3 'TMouseEvent'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1      \cf0 RegisterProperty(\cf3 'ONKEYDOWN'\cf0 ,\cf1  \cf3 'TKeyEvent'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'ONKEYPRESS'\cf0 ,\cf1  \cf3 'TKeyPressEvent'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'ONKEYUP'\cf0 ,\cf1  \cf3 'TKeyEvent'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1    \cf0 RegisterProperty(\cf3 'ALIGN'\cf0 ,\cf1  \cf3 'TALIGN'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'ALIGNMENT'\cf0 ,\cf1  \cf3 'TALIGNMENT'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'CAPTION'\cf0 ,\cf1  \cf3 'String'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'CHECKED'\cf0 ,\cf1  \cf3 'BOOLEAN'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'COLOR'\cf0 ,\cf1  \cf3 'TColor'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'FONT'\cf0 ,\cf1  \cf3 'TFont'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'PARENTCOLOR'\cf0 ,\cf1  \cf3 'Boolean'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'PARENTFONT'\cf0 ,\cf1  \cf3 'Boolean'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1      \cf0 RegisterProperty(\cf3 'CTL3D'\cf0 ,\cf1  \cf3 'Boolean'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1      \cf0 RegisterProperty(\cf3 'FONT'\cf0 ,\cf1  \cf3 'TFont'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1      \cf0 RegisterProperty(\cf3 'SORTED'\cf0 ,\cf1  \cf3 'Boolean'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1      \cf0 RegisterProperty(\cf3 'Visible'\cf0 ,\cf1  \cf3 'Boolean'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1      \cf0 RegisterProperty(\cf3 'TEXT'\cf0 ,\cf1  \cf3 'String'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'BORDERSTYLE'\cf0 ,\cf1  \cf3 'TBorderStyle'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'HIDESELECTION'\cf0 ,\cf1  \cf3 'Boolean'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'MAXLENGTH'\cf0 ,\cf1  \cf3 'Integer'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1      \cf0 RegisterProperty(\cf3 'CHARCASE'\cf0 ,\cf1  \cf3 'TEditCharCase'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     \cf0 RegisterProperty(\cf3 'OEMCONVERT'\cf0 ,\cf1  \cf3 'Boolean'\cf0 ,\cf1  \cf0 iptrw);
\par \cf1     
\par      \cf0 CL.AddClassN(CL.FindClass(\cf3 'TOBJECT'\cf0 ),\cf3 'TStatusBar'\cf0 );
\par \cf1  
\par 
\par  
\par  
\par  \cf0 Hallo\cf1  \cf0 Max
\par Zuerst\cf1  \cf0 ein\cf1  \cf0 paar\cf1  \cf0 Links:
\par 
\par Projekt\cf1  \cf0 mit\cf1  \cf0 Real\cf1  \cf0 Time\cf1  \cf0 Clock,\cf1  \cf0 Arduino\cf1  \cf0 und\cf1  \cf0 CSharp-Code
\par http:\cf2\i //ecotronics.ch.honorius.sui-inter.net/wordpress/2013/arduino-als-uhr-version-2-mit-rtc-komponente-und-led-display/
\par 
\par \i0\cf4 \cf0 berwachung\cf1  \cf0 einer\cf1  \cf0 Stevia-Pflanze,\cf1  \cf0 ebenfalls\cf1  \cf0 mit\cf1  \cf0 CSharp\cf1  \cf0 und\cf1  \cf0 Arduino
\par http:\cf2\i //ecotronics.ch.honorius.sui-inter.net/wordpress/2012/big-sister-is-watching-you-die-totale-uberwachung-einer-stevia-pflanze/
\par 
\par \i0\cf0 Alle\cf1  \cf0 Arduino-Projekte
\par http:\cf2\i //ecotronics.ch.honorius.sui-inter.net/wordpress/category/physical-computing/arduino/
\par 
\par \i0\cf0 Und\cf1  \cf0 nat\cf4 \cf0 rlich\cf1  \cf0 mein\cf1  \cf0 Arduino-Cheat-Sheet:
\par http:\cf2\i //www.ecotronics.ch/ecotron/arduinocheatsheet.htm
\par 
\par \i0\cf0 Zu\cf1  \cf0 Android\cf1  \cf0 gibt\cf1  \cf0 es\cf1  \cf0 noch\cf1  \cf0 nichts\cf1  \cf4 \cf0 ffentliches
\par 
\par Hier\cf1  \cf0 der\cf1  \cf0 Code\cf1  \cf0 der\cf1  \cf0 MainActivity\cf1  \cf0 f\cf4 \cf0 r\cf1  \cf0 das\cf1  \cf0 Android-Arduino-Projekt
\par \cf3 "Buch_07_RGB_LED_UsbHost"
\par \cf0 Der\cf1  \cf0 Code\cf1  \cf0 ist\cf1  \cf0 fast\cf1  \cf0 unver\cf4 \cf0 ndert\cf1  \cf0 aus\cf1  \cf0 dem\cf1  \cf0 Buch.
\par 
\par package\cf1  \cf0 com.example.hellousb;
\par 
\par import\cf1  \cf0 java.util.concurrent.ArrayBlockingQueue;
\par import\cf1  \cf0 java.util.concurrent.atomic.AtomicBoolean;
\par 
\par import\cf1  \cf0 android.app.Activity;
\par import\cf1  \cf0 android.content.BroadcastReceiver;
\par import\cf1  \cf0 android.content.Context;
\par import\cf1  \cf0 android.content.Intent;
\par import\cf1  \cf0 android.content.IntentFilter;
\par import\cf1  \cf0 android.graphics.Color;
\par import\cf1  \cf0 android.hardware.usb.UsbConstants;
\par import\cf1  \cf0 android.hardware.usb.UsbDevice;
\par import\cf1  \cf0 android.hardware.usb.UsbDeviceConnection;
\par import\cf1  \cf0 android.hardware.usb.UsbEndpoint;
\par import\cf1  \cf0 android.hardware.usb.UsbInterface;
\par import\cf1  \cf0 android.hardware.usb.UsbManager;
\par import\cf1  \cf0 android.os.Bundle;
\par import\cf1  \cf0 android.util.Log;
\par import\cf1  \cf0 android.view.Menu;
\par import\cf1  \cf0 android.view.WindowManager;
\par import\cf1  \cf0 android.widget.SeekBar;
\par import\cf1  \cf0 android.widget.SeekBar.OnSeekBarChangeListener;
\par 
\par \b public\b0\cf1  \cf0\b class\b0\cf1  \cf0 MainActivity\cf1  \cf0 extends\cf1  \cf0 Activity\cf1  \cf0 \{
\par 
\par \b public\b0\cf1  \cf0\b static\b0\cf1  \cf0 final\cf1  \cf0 String\cf1  \cf0 TAG\cf1  \cf0 =\cf1  \cf3 "HelloUsb"\cf0 ;
\par 
\par \b private\b0\cf1  \cf0 UsbDevice\cf1  \cf0 mDev\cf1  \cf0 =\cf1  \cf0\b null\b0 ;
\par \b private\b0\cf1  \cf0 UsbDeviceConnection\cf1  \cf0 mDeviceConnection\cf1  \cf0 =\cf1  \cf0\b null\b0 ;
\par 
\par \b private\b0\cf1  \cf0 final\cf1  \cf0 AtomicBoolean\cf1  \cf0 mStop\cf1  \cf0 =\cf1  \cf0\b new\b0\cf1  \cf0 AtomicBoolean(\b false\b0 );
\par \b private\b0\cf1  \cf0 final\cf1  \cf0 ArrayBlockingQueue<String>\cf1  \cf0 mValueQueue\cf1  \cf0 =\cf1  \cf0\b new
\par \b0 ArrayBlockingQueue<String>(\cf4 12\cf0 );
\par 
\par \cf4 @\cf0 Override
\par \b protected\b0\cf1  \cf0\b void\b0\cf1  \cf0 onCreate(Bundle\cf1  \cf0 savedInstanceState)\cf1  \cf0 \{
\par super.onCreate(savedInstanceState);
\par getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
\par registerReceiver(mDetachedReceiver,\cf1  \cf0\b new
\par \b0 IntentFilter(UsbManager.ACTION_USB_ACCESSORY_DETACHED));
\par setContentView(R.layout.activity_main);
\par ((SeekBar)findViewById(R.id.seekBarH)).setOnSeekBarChangeListener(mOnSeekBarChangeListener);
\par ((SeekBar)findViewById(R.id.seekBarS)).setOnSeekBarChangeListener(mOnSeekBarChangeListener);
\par ((SeekBar)findViewById(R.id.seekBarB)).setOnSeekBarChangeListener(mOnSeekBarChangeListener);
\par \}
\par 
\par \b private\b0\cf1  \cf0 final\cf1  \cf0 OnSeekBarChangeListener\cf1  \cf0 mOnSeekBarChangeListener\cf1  \cf0 =
\par \b new\b0\cf1  \cf0 OnSeekBarChangeListener()\cf1  \cf0 \{
\par 
\par \cf4 @\cf0 Override
\par \b public\b0\cf1  \cf0\b void\b0\cf1  \cf0 onStopTrackingTouch(SeekBar\cf1  \cf0 seekBar)\cf1  \cf0 \{\}
\par 
\par \cf4 @\cf0 Override
\par \b public\b0\cf1  \cf0\b void\b0\cf1  \cf0 onStartTrackingTouch(SeekBar\cf1  \cf0 seekBar)\cf1  \cf0 \{\}
\par 
\par \cf4 @\cf0 Override
\par \b public\b0\cf1  \cf0\b void\b0\cf1  \cf0 onProgressChanged(SeekBar\cf1  \cf0 seekBar,\cf1  \cf0\b int\b0\cf1  \cf0 progress,
\par boolean\cf1  \cf0 fromUser)\cf1  \cf0 \{
\par \b int\b0\cf1  \cf0 h\cf1  \cf0 =\cf1  \cf0 ((SeekBar)findViewById(R.id.seekBarH)).getProgress();
\par \b int\b0\cf1  \cf0 s\cf1  \cf0 =\cf1  \cf0 ((SeekBar)findViewById(R.id.seekBarS)).getProgress();
\par \b int\b0\cf1  \cf0 b\cf1  \cf0 =\cf1  \cf0 ((SeekBar)findViewById(R.id.seekBarB)).getProgress();
\par 
\par \cf2\i /*int color = Color.HSVToColor(new float[]\{
\par (float)h,
\par (float)s/255f,
\par (float)b/255f
\par \});
\par 
\par String cmdRed = "r"+Color.red(color)+"\\n";
\par String cmdGreen = "g"+Color.green(color)+"\\n";
\par String cmdBlue = "b"+Color.blue(color)+"\\n";*/
\par \i0\cf0\b int\b0\cf1  \cf0 color\cf1  \cf0 =\cf1  \cf0 Color.rgb(\cf1  \cf0 h,\cf1  \cf0 s,\cf1  \cf0 b);
\par 
\par String\cf1  \cf0 cmdRed\cf1  \cf0 =\cf1  \cf3 "r"\cf0 +Color.red(color)+\cf3 "\\n"\cf0 ;
\par String\cf1  \cf0 cmdGreen\cf1  \cf0 =\cf1  \cf3 "g"\cf0 +Color.green(color)+\cf3 "\\n"\cf0 ;
\par String\cf1  \cf0 cmdBlue\cf1  \cf0 =\cf1  \cf3 "b"\cf0 +Color.blue(color)+\cf3 "\\n"\cf0 ;
\par Log.e(TAG,\cf1  \cf3 "R: "\cf1  \cf0 +\cf1  \cf0 cmdRed\cf1  \cf0 +\cf1  \cf3 " G: "\cf1  \cf0 +\cf1  \cf0 cmdGreen\cf1  \cf0 +\cf1  \cf3 " B: "\cf1  \cf0 +\cf1  \cf0 cmdBlue);
\par 
\par mValueQueue.offer(cmdRed);
\par mValueQueue.offer(cmdGreen);
\par mValueQueue.offer(cmdBlue);
\par \}
\par \};
\par 
\par \cf4 @\cf0 Override
\par \b protected\b0\cf1  \cf0\b void\b0\cf1  \cf0 onDestroy()\cf1  \cf0 \{
\par unregisterReceiver(mDetachedReceiver);
\par super.onDestroy();
\par \}
\par 
\par \cf4 @\cf0 Override
\par \b protected\b0\cf1  \cf0\b void\b0\cf1  \cf0 onResume()\cf1  \cf0 \{
\par \b if\b0 (mDev\cf1  \cf0 ==\cf1  \cf0\b null\b0 )\{
\par \b if\b0 (getIntent().hasExtra(UsbManager.EXTRA_DEVICE))\{
\par mDev\cf1  \cf0 =
\par (UsbDevice)getIntent().getParcelableExtra(UsbManager.EXTRA_DEVICE);
\par \}
\par \}
\par 
\par \b if\b0\cf1  \cf0 (mDev\cf1  \cf0 ==\cf1  \cf0\b null\b0 )\cf1  \cf0 \{
\par e(\cf3 "no device attached"\cf0 );
\par \}\cf1  \cf0\b else\b0\cf1  \cf0 \{
\par mStop.set(\b false\b0 );
\par \b if\b0\cf1  \cf0 (sUsbThread\cf1  \cf0 ==\cf1  \cf0\b null\b0 )\cf1  \cf0 \{
\par sUsbThread\cf1  \cf0 =\cf1  \cf0\b new\b0\cf1  \cf0 Thread(mUsbRunnable);
\par sUsbThread.setName(\cf3 "Usb Thread"\cf0 );
\par sUsbThread.start();
\par \}
\par \}
\par super.onResume();
\par \}
\par 
\par \cf4 @\cf0 Override
\par \b protected\b0\cf1  \cf0\b void\b0\cf1  \cf0 onPause()\cf1  \cf0 \{
\par mStop.set(\b true\b0 );
\par \b if\b0 (sUsbThread\cf1  \cf0 !=\cf1  \cf0\b null\b0 )\{
\par sUsbThread.interrupt();
\par \}
\par super.onPause();
\par \}
\par 
\par \cf4 @\cf0 Override
\par \b protected\b0\cf1  \cf0\b void\b0\cf1  \cf0 onNewIntent(Intent\cf1  \cf0 intent)\cf1  \cf0 \{
\par l(\cf3 "on new intent"\cf0 );
\par setIntent(intent);
\par \b if\b0 (intent.hasExtra(UsbManager.EXTRA_DEVICE))\{
\par mDev\cf1  \cf0 =
\par (UsbDevice)getIntent().getParcelableExtra(UsbManager.EXTRA_DEVICE);
\par \}
\par \}
\par 
\par \cf4 @\cf0 Override
\par \b public\b0\cf1  \cf0 boolean\cf1  \cf0 onCreateOptionsMenu(Menu\cf1  \cf0 menu)\cf1  \cf0 \{
\par \cf2\i // Inflate the menu; this adds items to the action bar if it is
\par \i0\cf0 present.
\par getMenuInflater().inflate(R.menu.activity_main,\cf1  \cf0 menu);
\par \b return\b0\cf1  \cf0\b true\b0 ;
\par \}
\par 
\par \cf4 @\cf0 Override
\par \b protected\b0\cf1  \cf0\b void\b0\cf1  \cf0 onStop()\cf1  \cf0 \{
\par mStop.set(\b true\b0 );
\par \b if\b0 (sUsbThread\cf1  \cf0 !=\cf1  \cf0\b null\b0 )\{
\par sUsbThread.interrupt();
\par \}
\par mValueQueue.clear();
\par mValueQueue.offer(\cf3 "-1"\cf0 );
\par super.onStop();
\par \}
\par 
\par \b private\b0\cf1  \cf0\b static\b0\cf1  \cf0 Thread\cf1  \cf0 sUsbThread;
\par \b private\b0\cf1  \cf0 final\cf1  \cf0 Runnable\cf1  \cf0 mUsbRunnable\cf1  \cf0 =\cf1  \cf0\b new\b0\cf1  \cf0 Runnable()\cf1  \cf0 \{
\par \cf4 @\cf0 Override
\par \b public\b0\cf1  \cf0\b void\b0\cf1  \cf0 run()\cf1  \cf0 \{
\par UsbManager\cf1  \cf0 usbman\cf1  \cf0 =\cf1  \cf0 (UsbManager)\cf1  \cf0 getSystemService(USB_SERVICE);
\par \b while\b0\cf1  \cf0 (!mStop.get()\cf1  \cf0 &&\cf1  \cf0 mDev\cf1  \cf0 !=\cf1  \cf0\b null\b0\cf1  \cf0 &&
\par usbman.hasPermission(mDev))\cf1  \cf0 \{
\par mDeviceConnection\cf1  \cf0 =\cf1  \cf0 usbman.openDevice(mDev);
\par UsbInterface\cf1  \cf0 usbif\cf1  \cf0 =\cf1  \cf0 mDev.getInterface(\cf4 1\cf0 );
\par mDeviceConnection.claimInterface(usbif,\cf1  \cf0\b true\b0 );
\par mDeviceConnection.controlTransfer(\cf4 0x21\cf0 ,\cf1  \cf4 34\cf0 ,\cf1  \cf4 0\cf0 ,\cf1  \cf4 0\cf0 ,\cf1  \cf0\b null\b0 ,
\par \cf4 0\cf0 ,\cf1  \cf4 0\cf0 );
\par mDeviceConnection
\par .controlTransfer(\cf4 0x21\cf0 ,\cf1  \cf4 32\cf0 ,\cf1  \cf4 0\cf0 ,\cf1  \cf4 0\cf0 ,
\par \b new\b0\cf1  \cf0\b byte\b0 []\cf1  \cf0 \{\cf1  \cf0 (\b byte\b0 )\cf1  \cf4 0x80\cf0 ,\cf1  \cf4 0x25\cf0 ,\cf1  \cf4 0x00\cf0 ,\cf1  \cf4 0x00\cf0 ,
\par \cf4 0x00\cf0 ,\cf1  \cf4 0x00\cf0 ,\cf1  \cf4 0x08\cf1  \cf0 \},\cf1  \cf4 7\cf0 ,\cf1  \cf4 0\cf0 );
\par 
\par UsbEndpoint\cf1  \cf0 bulkOutEp\cf1  \cf0 =\cf1  \cf0\b null\b0 ;
\par \b for\b0\cf1  \cf0 (\b int\b0\cf1  \cf0 i\cf1  \cf0 =\cf1  \cf4 0\cf0 ;\cf1  \cf0 i\cf1  \cf0 <\cf1  \cf0 usbif.getEndpointCount();\cf1  \cf0 i++)\cf1  \cf0 \{
\par \b if\b0\cf1  \cf0 (usbif.getEndpoint(i).getDirection()\cf1  \cf0 ==
\par UsbConstants.USB_DIR_OUT
\par &&\cf1  \cf0 usbif.getEndpoint(i).getType()\cf1  \cf0 ==
\par UsbConstants.USB_ENDPOINT_XFER_BULK)\cf1  \cf0 \{
\par bulkOutEp\cf1  \cf0 =\cf1  \cf0 usbif.getEndpoint(i);
\par \b break\b0 ;
\par \}
\par \}
\par 
\par \b if\b0\cf1  \cf0 (bulkOutEp\cf1  \cf0 ==\cf1  \cf0\b null\b0 )\cf1  \cf0 \{
\par e(\cf3 "OUT endpoint not found"\cf0 );
\par \b break\b0 ;
\par \}
\par 
\par String\cf1  \cf0 cmd\cf1  \cf0 =\cf1  \cf3 ""\cf0 ;
\par \b try\b0\cf1  \cf0 \{
\par \b if\b0 (!mValueQueue.contains(\cf3 "-1"\cf0 ))\{
\par mValueQueue.clear();
\par \b while\b0 (!(cmd\cf1  \cf0 =\cf1  \cf0 mValueQueue.take()).equals(\cf3 "-1"\cf0 ))\{
\par mDeviceConnection.bulkTransfer(bulkOutEp,
\par cmd.getBytes(),
\par cmd.getBytes().length,\cf1  \cf4 0\cf0 );
\par \}
\par \}
\par \}\cf1  \cf0\b catch\b0\cf1  \cf0 (InterruptedException\cf1  \cf0 e)\cf1  \cf0 \{
\par e(\cf3 "interrupted while in queue"\cf0 );
\par \}
\par l(\cf3 "releasing interface"\cf0 );
\par mDeviceConnection.releaseInterface(usbif);
\par mDeviceConnection.close();
\par mDev\cf1  \cf0 =\cf1  \cf0\b null\b0 ;
\par \b while\b0 (!mStop.get()\cf1  \cf0 &&\cf1  \cf0 mDev\cf1  \cf0 ==\cf1  \cf0\b null\b0 )\cf1  \cf0 \{
\par \b try\b0\cf1  \cf0 \{
\par l(\cf3 "waiting for new device"\cf0 );
\par Thread.sleep(\cf4 500\cf0 );\cf2\i // waiting
\par \i0\cf0 \}\cf1  \cf0\b catch\b0\cf1  \cf0 (InterruptedException\cf1  \cf0 e)\cf1  \cf0 \{
\par \}\cf2\i // e-gnore
\par \i0\cf0 \}
\par \}
\par l(\cf3 "thread ended"\cf0 );
\par sUsbThread\cf1  \cf0 =\cf1  \cf0\b null\b0 ;
\par \}
\par \};
\par 
\par \b private\b0\cf1  \cf0\b static\b0\cf1  \cf0\b void\b0\cf1  \cf0 l(Object\cf1  \cf0 o)\cf1  \cf0 \{
\par Log.d(TAG,\cf1  \cf3 ">==< "\cf1  \cf0 +\cf1  \cf0 o.toString()\cf1  \cf0 +\cf1  \cf3 " >==<"\cf0 );
\par \}
\par 
\par \b private\b0\cf1  \cf0\b static\b0\cf1  \cf0\b void\b0\cf1  \cf0 e(Object\cf1  \cf0 o)\cf1  \cf0 \{
\par Log.e(TAG,\cf1  \cf3 ">==< "\cf1  \cf0 +\cf1  \cf0 o.toString()\cf1  \cf0 +\cf1  \cf3 " >==<"\cf0 );
\par \}
\par 
\par \b private\b0\cf1  \cf0 final\cf1  \cf0 BroadcastReceiver\cf1  \cf0 mDetachedReceiver\cf1  \cf0 =\cf1  \cf0\b new
\par \b0 BroadcastReceiver()\cf1  \cf0 \{
\par \cf4 @\cf0 Override
\par \b public\b0\cf1  \cf0\b void\b0\cf1  \cf0 onReceive(Context\cf1  \cf0 context,\cf1  \cf0 Intent\cf1  \cf0 intent)\cf1  \cf0 \{
\par \b if\b0\cf1  \cf0 (intent.getAction()
\par .equals(UsbManager.ACTION_USB_DEVICE_DETACHED))\cf1  \cf0 \{
\par l(\cf3 "device detached"\cf0 );
\par UsbDevice\cf1  \cf0 device\cf1  \cf0 =\cf1  \cf0 (UsbDevice)
\par intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
\par \b if\b0\cf1  \cf0 (device\cf1  \cf0 !=\cf1  \cf0\b null\b0 )\cf1  \cf0 \{
\par mValueQueue.clear();
\par mValueQueue.offer(\cf3 "-1"\cf0 );
\par \}
\par \}
\par \}
\par \};
\par \}
\par 
\par --\cf1  
\par \cf0 Mit\cf1  \cf0 freundlichen\cf1  \cf0 Gr\cf4 \cf0 ssen
\par Silvia\cf1  \cf0 Rothen
\par 
\par rothen\cf1  \cf0 ecotronics
\par Kasernenstr.\cf1  \cf4 41
\par 3013\cf1  \cf0 Bern
\par 
\par Tel.\cf1  \cf0 G:\cf1  \cf0 +\cf4 41\cf1  \cf0 (\cf4 0\cf0 )\cf4 31\cf1  \cf4 333\cf1  \cf4 71\cf1  \cf4 82
\par 
\par \cf0 http:\cf2\i //www.ecotronics.ch/
\par 
\par \i0\cf0 constructor\cf1  \cf0 TControl.Create(AOwner:\cf1  \cf0 TComponent);
\par begin
\par \cf1   \cf0 inherited\cf1  \cf0 Create(AOwner);
\par \cf1   \cf0 FWindowProc\cf1  \cf0 :=\cf1  \cf0 WndProc;
\par \cf1   \cf0 FControlStyle\cf1  \cf0 :=\cf1  \cf0 [csCaptureMouse,\cf1  \cf0 csClickEvents,\cf1  \cf0 csSetCaption,\cf1  \cf0 csDoubleClicks];
\par \cf1   \cf0 FFont\cf1  \cf0 :=\cf1  \cf0 TFont.Create;
\par \cf1   \cf0 FFont.OnChange\cf1  \cf0 :=\cf1  \cf0 FontChanged;
\par \cf1   \cf0 FAnchors\cf1  \cf0 :=\cf1  \cf0 [akLeft,\cf1  \cf0 akTop];
\par \cf1   \cf0 FConstraints\cf1  \cf0 :=\cf1  \cf0 TSizeConstraints.Create(Self);
\par \cf1   \cf0 FConstraints.OnChange\cf1  \cf0 :=\cf1  \cf0 DoConstraintsChange;
\par \cf1   \cf0 FMargins\cf1  \cf0 :=\cf1  \cf0 TMargins.Create(Self);
\par \cf1   \cf0 FMargins.OnChange\cf1  \cf0 :=\cf1  \cf0 DoMarginChange;
\par \cf1   \cf0 FColor\cf1  \cf0 :=\cf1  \cf0 clWindow;
\par \cf1   \cf0 FVisible\cf1  \cf0 :=\cf1  \cf0 True;
\par \cf1   \cf0 FEnabled\cf1  \cf0 :=\cf1  \cf0 True;
\par \cf1   \cf0 FParentFont\cf1  \cf0 :=\cf1  \cf0 True;
\par \cf1   \cf0 FParentColor\cf1  \cf0 :=\cf1  \cf0 True;
\par \cf1   \cf0 FParentShowHint\cf1  \cf0 :=\cf1  \cf0 True;
\par \cf1   \cf0 FParentBiDiMode\cf1  \cf0 :=\cf1  \cf0 True;
\par \cf1   \cf0 FIsControl\cf1  \cf0 :=\cf1  \cf0 False;
\par \cf1   \cf0 FDragCursor\cf1  \cf0 :=\cf1  \cf0 crDrag;
\par \cf1   \cf0 FFloatingDockSiteClass\cf1  \cf0 :=\cf1  \cf0 TCustomDockForm;
\par \cf1   \cf0 FHelpType\cf1  \cf0 :=\cf1  \cf0 htContext;
\par end;
\par 
\par constructor\cf1  \cf0 TWinControl.Create(AOwner:\cf1  \cf0 TComponent);
\par begin
\par \cf1   \cf0 inherited\cf1  \cf0 Create(AOwner);
\par \{\cf4 $\cf0 IFDEF\cf1  \cf0 LINUX\}
\par \cf1   \cf0 FObjectInstance\cf1  \cf0 :=\cf1  \cf0 WinUtils.MakeObjectInstance(MainWndProc);
\par \{\cf4 $\cf0 ENDIF\}
\par \{\cf4 $\cf0 IFDEF\cf1  \cf0 MSWINDOWS\}
\par \cf1   \cf0 FObjectInstance\cf1  \cf0 :=\cf1  \cf0 Classes.MakeObjectInstance(MainWndProc);
\par \{\cf4 $\cf0 ENDIF\}
\par \cf1   \cf0 FBrush\cf1  \cf0 :=\cf1  \cf0 TBrush.Create;
\par \cf1   \cf0 FBrush.Color\cf1  \cf0 :=\cf1  \cf0 FColor;
\par \cf1   \cf0 FParentCtl3D\cf1  \cf0 :=\cf1  \cf0 True;
\par \cf1   \cf0 FTabOrder\cf1  \cf0 :=\cf1  \cf0 -\cf4 1\cf0 ;
\par \cf1   \cf0 FImeMode\cf1  \cf0 :=\cf1  \cf0 imDontCare;
\par \cf1   \cf0\b if\b0\cf1  \cf0 SysLocale.PriLangID\cf1  \cf0 =\cf1  \cf0 LANG_JAPANESE\cf1  \cf0 then
\par \cf1     \cf0 FImeName\cf1  \cf0 :=\cf1  \cf3 ''
\par \cf1   \cf0\b else
\par \b0\cf1     \cf0 FImeName\cf1  \cf0 :=\cf1  \cf0 Screen.DefaultIme;
\par \cf1   \cf0 FUseDockManager\cf1  \cf0 :=\cf1  \cf0 False;
\par \cf1   \cf0 FBevelEdges\cf1  \cf0 :=\cf1  \cf0 [beLeft,\cf1  \cf0 beTop,\cf1  \cf0 beRight,\cf1  \cf0 beBottom];
\par \cf1   \cf0 FBevelInner\cf1  \cf0 :=\cf1  \cf0 bvRaised;
\par \cf1   \cf0 FBevelOuter\cf1  \cf0 :=\cf1  \cf0 bvLowered;
\par \cf1   \cf0 FBevelWidth\cf1  \cf0 :=\cf1  \cf4 1\cf0 ;
\par \cf1   \cf0 FHelpType\cf1  \cf0 :=\cf1  \cf0 htContext;
\par \cf1   \cf0 FPadding\cf1  \cf0 :=\cf1  \cf0 TPadding.Create(Self);
\par \cf1   \cf0 FPadding.OnChange\cf1  \cf0 :=\cf1  \cf0 DoPaddingChange;
\par end;
\par 
\par }