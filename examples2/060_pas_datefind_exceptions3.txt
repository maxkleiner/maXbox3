program DateFind_MX_ExceptionTester_for_EKON;

//tests all the snippets of mX3922/delphi_mxtester.html
// complex filefunction which shows all files of the day time stamp
// has findfirst with a TSearchRec structure, loc's = 730, _60

const ext = 'txt';   
      sw = 'SW_SHOW';
      BITMAP = 'examples\citymax.bmp';
     
var
  year, year1, month, month1, day, day1: word;
  dbform: TForm;  
  //E: Eheapexception; 
  //myappevent: TApplicationEvents;
   
procedure FindAllFiles(FilesList: TStringList; StartDir, FileMask: string);
var
  //SR: TSearchRec;
  DirList: TStringList;
  IsFound: Boolean;
  i: integer;
  myDosdate: TDateTime;
begin
  //E.createresfmt

  if StartDir[length(StartDir)] <> '\' then
                       StartDir:= StartDir + '\';
  { Build a list of the files in directory StartDir (not the directories!)}
  IsFound:= FindFirst(StartDir+FileMask, faAnyFile-faDirectory) = 0;
  while IsFound do begin
    myDosdate:= fileDatetoDateTime(searchrectime)
    decodedate(mydosdate, year, month, day)
    if (day = day1) and (month = month1) and (year = year1) then 
       FilesList.Add(StartDir + searchrecName);// + DateTimetoStr(mydosdate));
    IsFound:= FindNext = 0;
  end;
  FindClose;
  //Build a list of subdirectories
  DirList:= TStringList.Create;
    IsFound:= FindFirst(StartDir+'*.*', faAnyFile) = 0;
    while IsFound do begin
      if ((searchrecAttr and faDirectory) <> 0) and
         (searchrecName[1] <> '.') then
           DirList.Add(StartDir + searchrecName);
      IsFound:= FindNext = 0;
    end;
    FindClose;
  //Scan the list of subdirectories recursive!
  for i:= 0 to DirList.Count - 1 do
    FindAllFiles(FilesList, DirList[i], FileMask);
  DirList.Free;
end;

procedure StartFileFinder;
var
  FilesList: TStringList;
begin
  FilesList:= TStringList.Create;
  try
    FindAllFiles(FilesList, ExePath, '*.txt');
    fileslist.saveToFile(ExePath+ 'examples\pas_files.txt');
  finally 
    FilesList.Free;
  end;
end;

function coddingint(k: integer): string;
var s: string;
    z: integer;
begin
  s:= '';
  while k>255 do begin
    z:= k div 256; 
    if z>255 then z:= 255;
    s:= chr(z)+s;
    k:=k-z*256;
  end;
  s:= chr(k)+s;
  result:= s;
end;
  
function uncoddingint(s: string): integer;
var //s: string;
    i,k,z: integer;
begin
  //s:= '';
  result:= -1; if (s='') then exit;
  k:= 0;
  k:= ord(s[1]);
  delete(s,1,1);
  for i:= 1 to length(s) do begin
    if (ord(s[i])=0) and (i>1) then z:= 256 else z:= ord(s[i]);
    k:=k+z*256;
  end;
  result:= k;
end;

  //var nullstr: string;
  
  function LoadFile(const FileName: TFileName): string; 
  var anullstr: string;
    begin 
      with TFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite) do begin 
        try 
          SetLength(Result, Size); 
          Read(result, Size); 
          anullstr:= '0^';
          //getmem(pchar(anullstr),34);
          //getmemosize(pchar(anullstr));
         //Write(Pointer(content)^, Length(content));    //test write
        except 
          Result := '';  // Deallocates memory 
          Free; 
          //raise; 
          raiseLastWin32error;
        end; 
        Free; 
      end; 
    end; 
    
    
    procedure SaveFile(const FileName: TFileName; const acontent: string); 
    begin 
      with TFileStream.Create(FileName, fmCreate) do 
        try 
          Write(acontent, Length(acontent));
          Seek(0, soBeginning);  
        finally 
          Free; 
        end; 
    end; 
    
  
  function getBitmapOn(apath: shortstring): TBitmap;
  begin
    result:= TBitmap.Create;
    with result do try
      LoadFromFile(apath);
    finally
      //Free;
    end;
    //getbitmap
  end;
    
    
    procedure stringHashTest;
    var 
        idxclassific: TStringList; 
        i : Integer; 
    begin 
        idxclassific:= TStringList.Create; 
        idxclassific.Add('unix=good'); 
        //idxclassific[0]:= 'windows=bad'; 
        idxclassific.add('windows=bad'); 
       for i := 0 to idxclassific.Count-1 do begin 
            ShowMessage(idxclassific[i]); 
            ShowMessage(idxclassific.Names[i]); 
            ShowMessage(idxclassific.ValueFromIndex[i]); 
            ShowMessage(idxclassific.Values[idxclassific.Names[i]]); 
        end; 
       idxclassific.Free; 
     end;
     
  
    function CleanInput(input: String) : String; 
    var 
      output : string; 
      index : Integer; 
    begin 
      output:= StringReplace(input, #9, '',[rfReplaceAll, rfIgnoreCase]); 
      output:= StringReplace(output, #10, '',[rfReplaceAll, rfIgnoreCase]); 
      output:= StringReplace(output, #13, '',[rfReplaceAll, rfIgnoreCase]); 
      output:= StringReplace(output, '  ', '',[rfReplaceAll, rfIgnoreCase]); 
      output:= StringReplace(output, '&nbsp;', '',[rfReplaceAll, rfIgnoreCase]); 
      output:= StringReplace(output, '&nbsp', '',[rfReplaceAll, rfIgnoreCase]); 
      output:= StringReplace(output, '<br>', '',[rfReplaceAll, rfIgnoreCase]); 
      Result:= output; 
    end;
    
 
  procedure stopwatchtester;
    var 
      StartTime,StopTime : TDateTime; 
    begin 
      StartTime:= Now; 
      writeln(TimeToStr(StartTime)); 
       //[...]
      sleep(500); 
      StopTime:= Now; 
   //ListBox1.Items.Add('After doing'+ FormatDateTime('hh:nn:ss',StopTime-StartTime)); 
    writeln('After doing '+ FormatDateTime('hh:nn:ss:zzzz', StopTime - StartTime));    
   end;     
   
   
  type 
    TDigits = array of array of Integer; 
 
   procedure arraytester;
   //var myarray : array of string;
    var   myarray: TDigits;
          i: byte;
   begin
   
       // SetLength(MyArray,5,10); //5 rows, 10 columns each 
        //SetLength(MyArray[2],7); //We can use a different dimension for one cell 
   
    SetArrayLength(MyArray,5); //Array[3] points to a fifteen-column array 
    for i:= 0 to 4 do
    SetArrayLength(MyArray[i],10);
    SetLength(MyArray[2],7);  
    //SetLength(MyArray[2],5); //Array[2] points to a five-column array 
        //4 
        writeln(IntToStr(High(myarray))); 
        //9 
        writeln(IntToStr(High(myarray[0]))); 
        //6 
        writeln(IntToStr(High(myarray[2]))); 
        assert2(High(myarray[2])=6,'must be 6'); 
   end;
   
 
 procedure arrayHash;
    var 
      myhash: TStringList; 
      //mst: TStringHash;
      Index: Integer; 
     begin 
      myhash:= TStringList.Create; 
      myhash.Add('mykey=myvalue'); 
      myhash.Add('mykey2=myvalue2'); 
      ShowMessage(myhash.Values['mykey']); 
       for Index := 0 to myhash.Count-1 do begin 
        writeln(myhash.Names[Index] + '=' + myhash.ValueFromIndex[Index]); 
      end;
      myhash.Free;
    end;
    
    
  procedure StringHash;
    var 
      hsh: TStringHash; 
    begin 
      hsh:= TStringHash.Create(20); 
        with hsh do try 
          add('viens',1234-445-4343); 
          add('divi',2344556); 
        ShowMessage(inttostr(valueof('viens'))); 
        ShowMessage(inttostr(valueof('divi')));
      finally 
        Free;
     end; 
   end;
   
   procedure dont_do_that;
   var arr: array of integer;
   begin
     SetLength(Arr,4);
     try
       Arr[1]:= 123;
       Arr[2]:= 234;
       Arr[3]:= 345;
     except
       ShowMessageBig('out of range e');  
     end; 
   end;
   
procedure MAppOnException(sender: TObject; E: Exception);
var
  Addr: string;
  FErrorLog: Text;
  FileNamePath, userName: string;
  userNameLen: dWord;
  //mem: TMemoryStatus;
begin
  //writes errorlog.txt file
  //mem.dwLength:= sizeOf(TMemoryStatus);
  //GlobalMemoryStatus(mem);
  UserNameLen := 255;
  SetLength(userName, UserNameLen);
  FileNamePath:= extractFilePath(application.exeName) + EXCEPTLOGFILE;
  //AssignFile(FErrorLog, FileNamePath);
  try
    //Append(FErrorlog);
  except
    //on EInOutError do Rewrite(FErrorLog);
  end;
  //Addr:= inttoStr(mem.dwAvailPageFile div 1024) + 'pgf; mem:'
    //           +inttoStr(mem.dwAvailPhys div 1024);
  //Writeln(FErrorLog+ Format('%s %s [%s] %s %s [%s]'+[DateTimeToStr(Now),'V:'+MBVERSION,
    //      UserName, ComputerName, E.Message,'at:  ',Addr]));
  //Close(FErrorLog);
  MessageDlg(MBVERSION +' '+E.Message +'. occured at: '+Addr,mtError,[mbOK],0);
  //MessageBox(0, pChar(MBVERSION +' '+E.Message +'. occured at: '+Addr), 'ExceptionLog', MB_OKCANCEL)
end;

   
   
function TApplication_GetTitle: string;
var
  Buffer: array[0..255] of Char;
  Ftitle: string;
begin
  //if HandleCreated and not MainFormOnTaskBar then
  if application.handle > 2000 then
  begin
  //SetString(Result,BufferGetWindowText(application.Handle,Buffer,SizeOf(Buffer)));
    if Length(Result) = 0 then
      Result := FTitle;
  end
  else
    Result := FTitle;
end;
   

procedure TApplication_ShowException(E: Exception);
var
  Msg, s: string;
begin
  Msg := E.Message;
  s:= AnsiLastChar(Msg);
   if (Msg <> '') and (s > '.') then Msg:= Msg + '.';
  application.MessageBox(PChar(Msg),PChar(TApplication_GetTitle),MB_OK + MB_ICONSTOP);
end;


//*************************************Consumer Producer Pattern

  function getBitmapOnInternal(apath: shortstring): TBitmap;
    var E: Exception;
       bm: TBitmap;
  begin
    E:= Exception.Create('invalid path');
    bm:= TBitmap.Create;
    with bm do try
      LoadFromFile(apath);
      result:= bm;
      try
        //
      finally
        Free;
      end;
    except
      raise E.create('not a map');
    end;  
    //getbitmap
  end;

  const BITMAP3 = 'examples\citymax_gg.bmp';
  var ifexcept: TIFException;
  
  procedure gettheMAP;
  var bm: TBitmap;
  begin
    try
      //bm:= getBitmapOnInternal(bitmap3);
      bm:= getBitmap(bitmap3);
      writeln('get bitmap back '+inttostr(bm.width));
    except
      writeln('first except ' +sysErrormessage(getlasterror))
      {ifexcept:= ExceptionType;
      writeln(inttostr(ord(ifexcept))); //: TIFException;
      writeln(ExceptionToString(ifexcept,'test except'));}
      writeln(GetSafeCallExceptionMsg)
      showMessageBig('not a bitmap exception');
      //RaiseLastException;
      //GetLastError;
      writeln('in except '+sysErrormessage(getlasterror))
    end;
    writeln('after the except block')
    //loadfile
  end; 
  
  //http://max.kleiner.com/maxbox_functions_all.htm

//*******************************pattern end*************************
   
    procedure allocRes;
    var E: Exception;
    //Str: PResStringRec
    begin
    //AllocateSomeResources; 
    try
        try 
            //stuff that could trigger an exception 
        finally 
            //perform general actions, such as FreeAndNIL() 
        end; 
    except 
        //handle exception 
        //on E: Exception do begin           //mbabortretryignore
            MessageDlg(E.Message, mtWarning, [mbyestoall], 0); 
            //raise EInvalidGraphicOperation.CreateRes(Str);
            //raise E.CreateRes('Str');
        end; 
    end; 
    
   function mDivideByZero(const inValue : integer) : integer;
   var
    zero: integer;
    begin
      zero:= 0;
      result:= inValue div zero;
    end; 
    
 {Proc [61] Export: MDIVIDEBYZERO 12 @12
 [0] PUSHTYPE 12(S32) // 1
 [5] ASSIGN Base[1], [0]
 [20] ASSIGN Base[-1], Base[-2]
 [31] CALC Base[-1] / Base[1]
 [43] RET  }
 
  { with CL.AddClassN(CL.FindClass('Exception'),'EInOutError') do begin
    RegisterProperty('ErrorCode', 'Integer', iptrw);
  end;}

 
 
function mDivideByZero2(const inValue : integer) : integer;
var
  zero : integer;
  E: Exception;
  EZ: EZeroDivide;
begin
  ez:= EZeroDivide.create('my ex zero divide et impera');
  ez:= EZeroDivide.createFMT('fact %d and %d arent valid',[invalue, zero]);
  try
    zero:= 0;
    result:= inValue div zero;  //trigger exception
  except  //handle exception
    //on E : EDivByZero do
    begin
      Ez.Message:= Ez.Message + ' in unit myUnit.pas func DivideByZero';
      Application.ShowException(Ez);
      //raise EZeroDivide.create('');
    end;
  end;
end;

procedure TGraphic_LoadFromFile(const Filename: string);
var
  Stream: TStream; agraphic: TGraphic;
begin
  Stream:= TFileStream.Create(Filename, fmOpenRead or fmShareDenyWrite);
  try
    //aGraphic.LoadFromStream(Stream);
  finally
    Stream.Free;
  end;
end;

procedure TPersistent_AssignError(Source: TPersistent);
var
  SourceName: string;
begin
  if Source <> nil then
    //SourceName := Source.ClassName else
    //SourceName := 'nil';
  //raise EConvertError.CreateResFmt(@SAssignError, [SourceName, ClassName]);
end;


const BITMAP2 = 'examples\citymax33.bmp';

function mIOError(const inValue: integer): integer;
var zero : integer;
  //E: Exception;
  //EZ: EZeroDivide;
  EF: EFCreateError; 
  E: EInOutError;
  mbitmap: TBitmap;
begin
  //EF.CreateResFmt
  e:= EInOutError.create('no way in or out');
  mbitmap:= TBitmap.Create;
  try
    //mbitmap.LoadFromFile(Exepath+BITMAP);
    writeln('before the except');
    //strtoint('notaint');
    try
    zero:= 0;
    //result:= inValue div zero;
    //strtoint('notaint');
    mbitmap.LoadFromFile(Exepath+BITMAP2);
  except
    //on E : EDivByZero or on E: EConvertError do
    begin
      E.Message:= E.Message + ' in unit myUnit.pas func IOError: '
                                  +intToStr(E.ErrorCode);
      Application.ShowException(E);
      //raise;
    end;
  end;
    finally
      mbitmap.Free;
      E.Free;
     writeln('free after except');
    end; 
end;


function mTwoExceptions(const inValue: integer): integer;
var
  mbitmap: TBitmap;
begin
  mbitmap:= TBitmap.Create;
  try
    writeln('before the 2 except');
    //strtoint('notaint');
    try
      strtoint('notaint');
      mbitmap.LoadFromFile(Exepath+BITMAP2);
      writeln('after 2 try');
    finally
      mbitmap.Free;
      writeln('free after 2 except');
    end; 
  except
    begin
      //dumpexception;
      writeln('Application.ShowException(NIL)');
      raiselastException;
      //raiseException2;
      //dumpexception;
      //raise;
    end;
  end;
end;

procedure ExceptionErrorCode;
var E: EInOutError;
//    EI: EIBError;
begin
    try 
        //SomeCodeThatRaisesAnEConvertError;
        strToInt('this is not 2'); 
    except 
        //on E: EIBError do begin 
            if E.ErrorCode = 105 {iSomeCodeIWantToCatch} then begin 
                // Deal with this specific exception here 
            end else begin 
                raise; // re-raise the exception if it’s not the one I handle 
            end; 
        end; 
    end;


procedure AppException(Sender: TObject; E: Exception);
begin
  Application.ShowException(E);
  writeln('global exception intercept: '+E.message);
  //Application.HandleException(self);
  //Application.Terminate;
end; 

procedure TForm1FormCreate(Sender: TObject);
begin
  Application.OnException:= @AppException;
  //Application.OnException:= NIL;
end;
 
 
procedure TForm1Button1Click(Sender: TObject);
var epass: Exception;
begin
  epass:= Exception.Create('Incorrect password entered');
  writeln('raise goes on');
  writeln('app handle '+ inttostr(application.handle));
  //writeln('app owner'+ TApplication(application.owner).name);
   writeln('app name '+ (application.name));
   //raise Exception.Create('Incorrect password entered');
  writeln(' too late bit ');
  epass.Free;
  //abort;  //silent or not
end;

procedure TForm1_MyExceptionHandler(Sender : TObject; E : Exception );
var
  wRetVal : integer;
  Buttons: TMsgDlgButtons;
begin
  //MessageDlg('are you sure to instance?', mtConfirmation, [mbOk], 0);
  //buttons:= [mbignore]+[mbignore];
  wRetVal := MessageDlg(
    { E.Message contains the
     actual error message
     we'll customize it a bit...     }
    'ERROR: '+ E.Message,  mtError, [mbabort, mbignore], 0);
    //'ERROR: '+ E.Message,  mtError, [mbabort], 0);

  case wRetVal of
    mrAbort:
    begin
      { handle "Abort" here... }
    end;
    mrRetry:
    begin
      { handle "Retry" here... }
    end;
    mrIgnore:
    begin
      { handle "Ignore" here... }
    end;
    else begin
      { handle "other" action here...
       for example, if user choose to
       close the message box without
       clicking on any buttons
      }
    end;
  end;
  { you could also call the default
   exception handler:
      Application.ShowException( E );  }
end;

   
   procedure ShowMessageBig2(const aText : string);
   begin 
   with CreateMessageDialog(atext ,mtinformation, [mbyes, mbok])
      do try
        setBounds(100,100,500,450)
        caption:= 'Show Big Message';
        font.size:= 15;
        Color:= clwebgold;
        autoscroll:= true;
        canvas.draw(100,200,getBitMapon(Exepath+BITMAP));
        update;
        showmodal;
        //showmodal;    //GUI Exception
        //canvas.draw(100,200,getBitMapon(Exepath+BITMAP));
      finally
        Free;
      end;
      //lo
   end; 
   
 PROCEDURE initializeP;
 var half,tol,rp,funcval,stdev:real;
    errdomain,orig:boolean;

 BEGIN
  rp:=0.9189385332046727417803296; { LN SQRT(2pi) }
  maxcalcf('ln(sqrt(2*PI))');
  tol:=0.0000000001; {Accuracy of resulting normal deviate}
  half:=0.5;
  //zzobs:=0.0; {dummy value}
 END; {initialize}
 
 TYPE areal=double;

 
 procedure funcinput;
 {Global variables used: choice, funcval}
 label g77; 
 var
  QH, funcval:real;
  ppobs, half:real; //var zzobs:real
  orig:boolean;
 begin

  QH:=0.999999999999999;
  { Input of function value }
  funcval:=ppobs;
  if (abs(funcval-0.5)<0.0001) then begin
   funcval:= half;
   goto g77;
  end;
  if (funcval>QH) then funcval:=QH;

  { Convert to setting:  P>0.5, Q<0.5, normal deviate >0 }
  orig:=(funcval<=0.5);
  if not orig then funcval:=1-funcval;

  { Convert to Ln(Q) }
  funcval:=LN(funcval);
  g77:
 end; {funcinput}
 
 const
 aversion='20 Apr 2007';
 looplimit=800; {>= 500 is recommended}

 
 procedure CFmap(var dist,theta:real; dd:boolean);
{Calculates map distance from given theta (dd=true, easy) or
 theta from given map distance, using the
 Carter-Falconer mapping function}
var
 numloops:integer;
 t2,t3,x2,diff,thetaold, half, one,tol:real;
begin
 if dd
 then begin  {map distance from theta}
  t2:=theta+theta;
  t3:=half*LN((one+t2)/(one-t2)); {=tanh-1(2t)}
  dist:=0.25*(arctan(t2)+t3);
 end
 else begin  {theta from map distance}
  numloops:=0;
  theta:=dist;
  repeat
   t2:=theta+theta;
   x2:=EXP( 2.0*(4.0*dist-arctan(t2)) );
   thetaold:=theta;
   theta:=half*(x2-one)/(x2+one);
   diff:=abs(theta-thetaold);
  until (numloops=looplimit) or (diff<tol);
 end;
end; {CFmap}

procedure ShowScreenInfo(const ScrBuf: TJclScreenBuffer);
  var
    AMode: TJclConsoleOutputMode;
  OldMode: TJclConsoleOutputModes;
  Attr: IJclScreenTextAttribute;
  
  begin
    //for it:= Low(TJclConsoleOutputMode) to High(TJclConsoleOutputMode) do begin
      if AMode in ScrBuf.Mode then begin
       { if Result <> '' then
          Result := Result + ', ';
        Result:= Result+GetEnumName(TypeInfo(TJclConsoleOutputMode),Integer(AMode));
      end;
    end;}
  // ScrBuf.WriteLn('');
  ScrBuf.WriteLn(Format('Handle: 0x%.8x', [ScrBuf.Handle]),NIL);
  //ScrBuf.Writeln('Old Mode : ' + ModeToString);
  OldMode := ScrBuf.Mode;
  ScrBuf.Mode := ScrBuf.Mode - [omWrapAtEol];
  //ScrBuf.Write('New Mode : ' + ModeToString);
  //Readln;
  ScrBuf.Mode := OldMode;

  ScrBuf.WriteLn(Format('Old Size: (%d, %d)', [ScrBuf.Width, ScrBuf.Height]),nil);
  ScrBuf.Width := ScrBuf.Width * 2;
  ScrBuf.Write(Format('New Size: (%d, %d)', [ScrBuf.Width, ScrBuf.Height]),nil);
  //Readln;
  ScrBuf.Width := ScrBuf.Width div 2;

  //Attr:= TJclScreenTextAttribute.Create(fclYellow, bclBlue, True, False,
    //[fsGridHorizontal, fsUnderscore]);

  {ScrBuf.Write1('Top', thaCenter, tvaTop, Attr);
  ScrBuf.Write('Bottom', thaCenter, tvaBottom, Attr);
  ScrBuf.Write('Left', thaLeft, tvaCenter, Attr);
  ScrBuf.Write('Right', thaRight, tvaCenter, Attr);
  ScrBuf.Write('Center', thaCenter, tvaCenter, Attr);}
//end;
  
  end;
 end;
 
 
 function SetDisplayResolution(const XRes, YRes: DWORD): Longint;
//var
  //DevMode: TDeviceMode;
begin
  {Result := DISP_CHANGE_FAILED;
  FillChar(DevMode, SizeOf(DevMode), #0);
  DevMode.dmSize := SizeOf(DevMode);
  if EnumDisplaySettings(nil, 0, DevMode) then
  begin
    DevMode.dmFields := DM_PELSWIDTH or DM_PELSHEIGHT;
    DevMode.dmPelsWidth := XRes;
    DevMode.dmPelsHeight := YRes;
    Result := ChangeDisplaySettings(DevMode, 0);
  end;}
end;

function WinExec32X(const Cmd: string; const CmdShow: Integer): Bool;
var
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  asti: Pkolchar;
  apt: ___pointer;
  add: dword;
  asec: PSecurityAttributes;
  abb: bool;
  handle: THandle;
  devicenames: string;
  
begin
  //FillChar(StartupInfo, SizeOf(TStartupInfo), #0);
  StartupInfo.cb := SizeOf(StartupInfo);
  StartupInfo.dwFlags := STARTF_USESHOWWINDOW;
  StartupInfo.wShowWindow := CmdShow;

    apt:= 0; //nil; //2 //___pointer;
    add:= NORMAL_PRIORITY_CLASS;
    add:= handle;
    asti:= 'thisi';
    asti:= ''; //cmd;
    asec:= 01;
    abb:= false;
    StartupInfo:= StartupInfo;
    //processinfo:= 'nil';
  
   //CL.AddDelphiFunction('Function CreateProcess( lpApplicationName : PKOLChar; lpCommandLine : PKOLChar; lpProcessAttributes, lpThreadAttributes : PSecurityAttributes; bInheritHandles : BOOL; dwCreationFlags : DWORD; lpEnvironment : Pointer; lpCurrentDirectory : PKOLChar; const lpStartupInfo : TStartupInfo; var lpProcessInformation : TProcessInformation) : BOOL');
    {CL.AddDelphiFunction('Function wCreateProcess( lpApplicationName : PKOLChar; lpCommandLine : PKOLChar; lpProcessAttributes, lpThreadAttributes : PSecurityAttributes; bInheritHandles : BOOL; dwCreationFlags : DWORD; lpEnvironment : ___Pointer;' +'lpCurrentDirectory : PKOLChar; const lpStartupInfo : TStartupInfo; var lpProcessInformation :TProcessInformation) : BOOL'); }

//wCreateProcess('','',0,0,0,0,0,0,StartupInfo,processinfo);

{wCreateProcess('',Cmd,
  0,
  0,
  False,
  NORMAL_PRIORITY_CLASS,
  apt,
  '',
  StartupInfo,
  ProcessInfo);  }

  WCreateFile(DeviceNames,
    (GENERIC_READ or GENERIC_WRITE), 0, 0, 
    (OPEN_EXISTING), dword(FILE_ATTRIBUTE_NORMAL),0);
    
    {Function wCreateFile( lpFileName : PKOLChar; dwDesiredAccess, dwShareMode : DWORD; lpSecurityAttributes : PSecurityAttributes; dwCreationDisposition, dwFlagsAndAttributes : DWORD; hTemplateFile : THandle) : THandle');
     }
    asti:= 'thisi';
    asti:= cmd;
// Result:= wCreateProcess('', Cmd, nil, nil, False,
  //      NORMAL_PRIORITY_CLASS, nil, '', StartupInfo, ProcessInfo);
  if Result then begin
    WaitForInputIdle(ProcessInfo.hProcess, INFINITE);
    CloseHandle(ProcessInfo.hThread);
    CloseHandle(ProcessInfo.hProcess);
  end;
end;


procedure GetDOSOutput;
var aprocess: TProcess;
    AStringList: TStringList;
begin
  AProcess:= TProcess.Create(Nil);
  try
    //AProcess.CommandLine := 'gcc.exe "' + OpenDialog1.FileName + '"'
      //+ ' -o "' + OpenDialog2.FileName + '"';
    //AProcess.CommandLine:= 'cmd.exe /c "dir /s c:\windows\"';
    AProcess.CommandLine:= 'cmd.exe /c "dir *.*"';
      //AProcess.CommandLine:= 'cmd.exe /c "Ver"';
    //AProcess.CommandLine:= 'cmd.exe /c "Netstat"';
  
   
    //AProcess.CommandLine := 'calc.exe';
    // AProcess.Executable:= 'ppc386';
    // Pass -h together with ppc386 (so we're executing ppc386 -h):
     //+ OpenDialog1.FileName + '"' + ' -o "' + OpenDialog2.FileName + '"';
    AStringList:= TStringList.Create;
    AProcess.Options:= AProcess.Options +[poWaitOnExit, poUsePipes];
    //AProcess.Options:= AProcess.Options +[poNoConsole, poUsePipes];
 
    AProcess.Execute;
    //Memo2.Lines.BeginUpdate;
    //Memo2.Lines.Clear;
    Memo2.Lines.LoadFromStream(AProcess.Output);
    //Memo2.Lines.EndUpdate;
    //AStringList.LoadFromStream(AProcess.Output);
    // Save the output to a file.
    //AStringList.SaveToFile(ExePath+'pipeoutput.txt');
    //openDoc(ExePath+'pipeoutput.txt');
  finally
    AProcess.Free;
    AStringList.Free;
  end;
end;




 var mystring: string;
   z: integer;
   E: Exception;
   ExObject: TObject;
   outa: string;
   //att: threadvar;
   outa1: TStringlist;
   Console: TJclConsole;
   ScrBuf: TJclScreenBuffer;
   //anevent: TCtrlEventHandler;
   
//main script exception app
begin
  //the the date from now to compare with file date
  decodeDate(date, year1, month1, day1) 
  //StartFileFinder;
  writeln(coddingint(200000));
  writeln(inttostr(uncoddingint('@ÿÿÿ')));
  writeln(inttostr(uncoddingint(coddingint(200000))));
  beep;
  //writeln(LoadFile(exepath+'firstdemo.txt'));
  //mystring:= LoadFile(exepath+'firstdemo.txt');
  //mystring:= loadStringJ(exepath+'firstdemo.txt');
  //showmessageBig(mystring);
  //SaveFile('firstdemosave.txt', memo2.text); 
  //Searchandopendoc('firstdemosave.txt');
  //shellexecute(1, 'open', 'notepad', 'rec_files.txt', '', 2)
  //orthogonal and idempotent
  //stringHashTest;
  //writeln(CleanInput(mystring));
  //stopwatchtester;
  arraytester;
  //arrayhash;
  //StringHash;
  
 // mDivideByZero(2013);
  //mDivideByZero2(2013);
  //mIOError(2013);
 
  //exceptobject
  //exceptaddr
  //exceptproc
  {e:= ematherror.create('out of rule');
  showexception(NIL,E)
  E.Free;}
  
  //Dumpexception;
  //ShowMessageBig2('bit mapper');

  Writeln('silent except out of scope');
  
  TForm1FormCreate(self);   //my own exception handler

  TForm1Button1Click(Self);  //raise exception
  
  //mTwoExceptions(2012)
  
  dont_do_that;
  
  // test stop except - halt 
  
  //getTheMap;
   
  //outofmemoryerror;
  
  //writeln(scanf('enter a number %d ', [23]));
  
  //redrawwindow
  
  //allocres;
  //  MessageDlg('E.Message', mtWarning, [mbok,mbcancel,mbretry], 0); 
   //closure concept
   (*dbform:= CreateMessageDialog('My Fast Form XML Converter - FFP',mtinformation,
                                        [mball, mbyes, mbhelp, mbok]);
   dbform.caption:= 'FFP XML Demo';
   dbform.setBounds(50,50,800,600)
   dbform.Color:= 123;
   dbform.show;
   dbform.canvas.draw(100,200,getbitmapon(exepath+BITMAP));
   with CreateMessageDialog('My Fast Form',mtinformation,
                               [mball, mbyes, mbhelp, mbok])
      do try
        caption:= 'FFP XML Demo';
        setBounds(50,50,800,600)
        Color:= 193;
        showmodal;
        canvas.draw(100,200,getBitMapon(Exepath+BITMAP));
      finally
        Free;
   end; *)
  //Showmessagebig('this is the first TREX on the line so the box goes on');
   (*z := $2345;  // $2345 hex : $23 hi byte, $45 lo byte
  ShowMessage(Format('Integer = $%x', [z]));
  ShowMessage(Format('Hi byte = $%x', [Hi(z)]));
  ShowMessage(Format('Lo byte = $%x', [Lo(z)]));*)
  
  (*Integer = $2345
   Hi byte = $23
   Lo byte = $45*)
    //validaterect
    //ddfff
    try
    except
        //if not Error(Exception(ExObject).Message) then raise;
    end
    
    //RaiseConversionError('this is conv error');
    writeln('at the end send');
    
    //NtfsGetCompression
    //SelectDate
    
    //DecorateURLs
    
    Writeln(Format('with Format %.18f',[Fact(70)]));
    Writeln(Format('with BigFormat %s',[bigFactorial('70')]));
   
    Writeln(Format('with Format %f',[Fact(10)]));
    Writeln(Format('with Format %f',[Fact(170)]));
    Writeln(Format('with Format %.18f',[Fact(21)]));
    Writeln(Format('with Format %f',[Factorial(21)]));
    Writeln(Format('with BigFormat %s',[bigFactorial('21')]));
    Writeln(Format('with FacFormat %f',[Fact(170)]));
    //Writeln(Format('with BigFormat %s',[bigFactorial('170')]));
    
    Writeln(Format('Fisher Test %.18f',[Fact(5)*fact(10)]));
    maXcalcF('(fact(5)^2*fact(6)*fact(4))/(fact(10)*(fact(5)*fact(0)*fact(1)*'+
                                            'fact(4)))')
    maXcalcF('5!')
    maXcalcF('0!')

    maXcalcF('((5!)^2*(6!)*(4!))/((10!)*((5!)*(0!)*(1!)*(4!)))')
    maXcalcF('fact(5)^2*fact(6)*fact(4)')
    maXcalcF('(6!)/(3!)/(6^3)*100') //=55.5555555555556
    maXcalcF('(5!)*(2!)')
    
    //initializeP
  
    Writeln(Format('BigMuluTest: %s',[bigFactorial('21')]));
    Writeln(Format('BigMuluTest: %s',[bigmulu(bigFactorial('21'), 
                                           bigFactorial('21'))]));
    Writeln(Format('BigMuluTest: %s',[bigmul(bigFactorial('21'), 
                                           bigFactorial('21'))]));
    Writeln(Format('BigMuluTest: %s',[bigexp(bigFactorial('21'),'2')]));
   
    //WinExec32AndWait
    //WinExec32AndRedirectOutput
     if CreateDOSProcessRedirected('cmd.exe /c "dir *.*"',exepath+'\outin.txt',
                     exepath+'\outa.txt') then

     writeln('out: '+outa);
     
     //getScriptandRun('http://www.softwareschule.ch/examples/moon2.txt');
     
     //CopyEXIF
   //  ExecConsoleApp(const AppName, Parameters: String; AppOutput: TStrings): DWORD;
    
{    This unit demonstrates a GUI application spawning a
console application, and capturing the output of the
console application to display in the GUI application.}
    //http://www.swissdelphicenter.ch/torry/showcode.php?id=683
    outa1:= TStringlist.create;
    //ExecConsoleApp('cmd.exe' ,'dir *.*',outa1) 
    outa1.Free; 
    
    //winExec32AndRedirectOutput
    
    {with TConsoleAppEx.create do begin
        execute('cmd.exe /c dir *.*',nil,nil)
      end;}
    
    //GetCPInfoEx
    //TCPInfoEx
    //Assert(TJclConsole.IsConsole(ParamStr(0)));
    Console:= TJclConsole.create;
    with Console do begin
     //ActiveScreen.WriteLn('Old Windows Title : ' + Console.Title,nil);
     //Console.Title := 'Information of the Default Output Screen Buffer';
    //Console.ActiveScreen.WriteLn('New Windows Title : ' + Console.Title,1);
  //Console.ActiveScreen.WriteLn(Format('Input Code Page : %s', [CodePageToName(Console.InputCodePage)]));
  //Console.ActiveScreen.WriteLn(Format('Output Code Page : %s', [CodePageToName(Console.OutputCodePage)]));
    //close
    //Free;
    end;
    
    GetDOSOutput;
    
    
     
end.     

ref

http://www.swissdelphicenter.ch/en/showcode.php?id=990
https://adcf.googlecode.com/svn/ConsoleApp.pas
http://www.jurgott.org/linkage/util.htm
http://www.swissdelphicenter.ch/en/niklauswirth.php

http://home.stusta.mhn.de/~005694/sourcehub/ColorPicker/JVCL340CompleteJCL221-Build3845/jcl/examples/windows/console/ConsoleExamples.dpr

CreateDOSProcessRedirected('C:\MyDOSApp.exe',
                                             'C:\InputPut.txt',
                                             'C:\OutPut.txt',
                                             'Please, record this message')

Bendicht
Paulistrasse 79
8834 Schindellegi

No More Headaches or Discomfort.
Motivated by an increased interest of physical computing and embedded in
automatic management of large systems
For all we know, the three dimensional world we see around us is really an illusion — one that’s actually in 2D.

Most of our strength to put something in 3D is paved with good intentions but lacked of services and simplification.
For example 3D Glasses invoke headaches or discomfort.
Motivated by an increased interest of physical computing and embedded in
automatic management of large systems they want us to buy 3D things but forget that 2D is most of the cases more efficient and easy to use.
Obviously a seemingly 3-D world exists only on a 2-D screen!
For all we know, the three dimensional world we see around us is really an illusion — one that’s actually in 2D:

http://www.theverge.com/2014/8/26/6071511/a-physics-experiment-might-soon-tell-us-if-were-living-in-a-2d


on biology, then the relevant matrix would be
Math. Mag. Science ; math 5 0 R_1=5; biology 1 4 R_2=5; C_1=6 C_2=4 N=10. 	
(3)

Computing P_(cutoff) gives
P_(cutoff)=(5!^26!4!)/(10!(5!0!1!4!))=0.0238, 

 and the other possible matrices and their Ps are
[4 1; 2 3] P	=	0.2381	
(5)
[3 2; 3 2] P	=	0.4762	
(6)
[2 3; 4 1] P	=	0.2381	
(7)
[1 4; 5 0] P	=	0.0238,


// code snippets

  With ASQLite3DB1 do begin 
        DefaultDir := ExtractFileDir(Application.ExeName); 
        Database := 'test.sqlite'; 
        CharacterEncoding := 'STANDARD'; 
        Open; 
        SQLite3_ExecSQL('CREATE TABLE IF NOT EXISTS mytable (id INTEGER PRIMARY KEY, label VARCHAR)'); 
    end; 
      
    AssignFile(SomeTxtFile, FILE2PARSE) ; 
    Reset(SomeTxtFile) ; 
    ASQLite3DB1.SQLite3_ExecSQL('BEGIN;'); 
      
    while not EOF(SomeTxtFile) do begin 
        ReadLn(SomeTxtFile, buffer) ; 
      
        PerlRegEx1.RegEx := '^([^d].+)\s(\d+)$'; 
        PerlRegEx1.Options := [preCaseLess]; 
        PerlRegEx1.Subject := buffer; 
        If PerlRegEx1.Match then begin 
            row := Format('INSERT INTO mytable (id,label) VALUES (%s,"%s");',[PerlRegEx1.SubExpressions[2],PerlRegEx1.SubExpressions[1]]); 
            ASQLite3DB1.SQLite3_ExecSQL(row); 
        end; 
    end; 

 Use OnException to change the default behavior that occurs when an exception is not handled by application code. The OnException event handler is called automatically in the HandleException method.  

OnException only handles exceptions that occur during message processing. Exceptions that occur before or after the execution of the application's Run method do not generate OnException events. 

If an exception passes through the tryblocks in the application code, the application automatically calls the HandleException method. Unless the exception object is EAbort, HandleException calls the OnException handler, if one exists. Otherwise, it calls ShowException to display a message box indicating an error occurred. 

TExceptionEvent is the type of the OnException event. It points to a method that handles exceptions in the application. The Sender parameter is the object that raised the exception, and E is the exception object.
Note: You can also respond to this event using the TApplicationEvents component, which allows you to assign an event handler using the IDE. 


int
main(void)
{
    int n;
    while (scanf("%d", & n) > 0)
        printf("%d\n", n);
    return 0;
}


procedure MAppOnException(sender: TObject; E: Exception);
var
  Addr: string[64];
  FErrorLog: System.Text;
  FileNamePath, userName: string;
  userNameLen: dWord;
  mem: TMemoryStatus;
begin
  //writes errorlog.txt file
  mem.dwLength:= sizeOf(TMemoryStatus);
  GlobalMemoryStatus(mem);
  UserNameLen := 255;
  SetLength(userName, UserNameLen);
  FileNamePath:= extractFilePath(application.exeName) + EXCEPTLOGFILE;
  AssignFile(FErrorLog, FileNamePath);
  try
    System.Append(FErrorlog);
  except
    on EInOutError do Rewrite(FErrorLog);
  end;
  Addr:= inttoStr(mem.dwAvailPageFile div 1024) + 'pgf; mem:'
               +inttoStr(mem.dwAvailPhys div 1024);
  Writeln(FErrorLog, Format('%s %s [%s] %s %s [%s]',[DateTimeToStr(Now),'V:'+MBVERSION,
          getUserNameWin, getComputerNameWin, E.Message,'at:  '+Addr]));
  System.Close(FErrorLog);
  MessageDlg(MBVERSION +' '+E.Message +'. occured at: '+Addr,mtError,[mbOK],0);
  //MessageBox(0, pChar(MBVERSION +' '+E.Message +'. occured at: '+Addr), 'ExceptionLog', MB_OKCANCEL)
end;

unit Classes;

  EFOpenError = class(EFileStreamError);


unit RTLConsts
  SFOpenErrorEx = 'Cannot open file "%s". %s';


constructor TFileStream.Create(const AFileName: string; Mode: Word; Rights: Cardinal);
begin
  if Mode = fmCreate then
  begin
    inherited Create(FileCreate(AFileName, Rights));
    if FHandle < 0 then
      raise EFCreateError.CreateResFmt(@SFCreateErrorEx, [ExpandFileName(AFileName), SysErrorMessage(GetLastError)]);
  end
  else
  begin
    inherited Create(FileOpen(AFileName, Mode));
    if FHandle < 0 then
      raise EFOpenError.CreateResFmt(@SFOpenErrorEx, [ExpandFileName(AFileName), SysErrorMessage(GetLastError)]);
  end;
  FFileName := AFileName;
end;


procedure TGraphic.LoadFromFile(const Filename: string);
var
  Stream: TStream;
begin
  Stream := TFileStream.Create(Filename, fmOpenRead or fmShareDenyWrite);
  try
    LoadFromStream(Stream); //virtual abstract
  finally
    Stream.Free;
  end;
end;

procedure TBitmap.LoadFromStream(Stream: TStream);
begin
  ReadStream(Stream, Stream.Size - Stream.Position);
end;


procedure TBitmap.ReadStream(Stream: TStream; Size: Longint);
var
  Bmf: TBitmapFileHeader;
  DIB: TDIBSection;
begin
  FreeContext;
  if Size = 0 then
  begin
    FillChar(DIB, sizeof(DIB), 0);
    NewImage(0, 0, DIB, False);
  end
  else
  begin
    Stream.ReadBuffer(Bmf, sizeof(Bmf));
    if Bmf.bfType <> $4D42 then InvalidBitmap;
    ReadDIB(Stream, Size - sizeof(Bmf), @Bmf);
  end;
end;
procedure InvalidGraphic(Str: PResStringRec);
begin
  raise EInvalidGraphic.CreateRes(Str);
end;

procedure InvalidBitmap; 
begin
  InvalidGraphic(@SInvalidBitmap);
end;

//sysutils!
{ Raise abort exception }

procedure Abort;

  function ReturnAddr: Pointer;
  asm
          MOV     EAX,[EBP + 4]
  end;

begin
  raise EAbort.CreateRes(@SOperationAborted) at ReturnAddr;
end;

  SOperationAborted = 'Operation aborted';

{ Raise out of memory exception }

procedure OutOfMemoryError;
begin
  raise OutOfMemory;
end;

{ Exception class }

constructor Exception.Create(const Msg: string);
begin
  FMessage := Msg;
end;




http://pages.cs.wisc.edu/~rkennedy/exception-messages
Why do I continue getting error messages even after I have written an exception handler?


In its default settings, the Delphi IDE
notifies you whenever an exception occurs in your program, as in Figure
1. What’s important to realize is that at that point, none
of your program’s exception-handling code has run yet. It’s
all Delphi itself; its special status as a debugger allows it to get
first notification of any exception in your program, even before your
program knows about it.

  Exception
  
    Exception = class(TObject)
  private
    FMessage: string;
    FHelpContext: Integer;
  public
    constructor Create(const Msg: string);
    constructor CreateFmt(const Msg: string; const Args: array of const);
    constructor CreateRes(Ident: Integer); overload;
    constructor CreateRes(ResStringRec: PResStringRec); overload;
    constructor CreateResFmt(Ident: Integer; const Args: array of const); overload;
    constructor CreateResFmt(ResStringRec: PResStringRec; const Args: array of const); overload;
    constructor CreateHelp(const Msg: string; AHelpContext: Integer);
    constructor CreateFmtHelp(const Msg: string; const Args: array of const;
      AHelpContext: Integer);
    constructor CreateResHelp(Ident: Integer; AHelpContext: Integer); overload;
    constructor CreateResHelp(ResStringRec: PResStringRec; AHelpContext: Integer); overload;
    constructor CreateResFmtHelp(ResStringRec: PResStringRec; const Args: array of const;
      AHelpContext: Integer); overload;
    constructor CreateResFmtHelp(Ident: Integer; const Args: array of const;
      AHelpContext: Integer); overload;
    property HelpContext: Integer read FHelpContext write FHelpContext;
    property Message: string read FMessage write FMessage;
  end;


  {$IFDEF MSWINDOWS}
  { TIniFile - Encapsulates the Windows INI file interface
    (Get/SetPrivateProfileXXX functions) }

  TIniFile = class(TCustomIniFile)
  public
    destructor Destroy; override;
    function ReadString(const Section, Ident, Default: string): string; override;
    procedure WriteString(const Section, Ident, Value: String); override;
    procedure ReadSection(const Section: string; Strings: TStrings); override;
    procedure ReadSections(Strings: TStrings); override;
    procedure ReadSectionValues(const Section: string; Strings: TStrings); override;
    procedure EraseSection(const Section: string); override;
    procedure DeleteKey(const Section, Ident: String); override;
    procedure UpdateFile; override;
  end;
{$ELSE}
    TIniFile = class(TMemIniFile)
    public
      destructor Destroy; override;
    end;
{$ENDIF}

 with TColorDialog.Create(self) do try
    execute;
  finally
    free;
  end;    
 

  private
    function RunCaptured(const _dirName, _exeName, _cmdLine: string): Boolean;
    
{....}

function TForm1.RunCaptured(const _dirName, _exeName, _cmdLine: string): Boolean;
var
  start: TStartupInfo;
  procInfo: TProcessInformation;
  tmpName: string;
  tmp: Windows.THandle;
  tmpSec: TSecurityAttributes;
  res: TStringList;
  return: Cardinal;
begin
  Result := False;
  try
    { Setze ein Temporäres File }
    { Set a temporary file }
    tmpName := 'Test.tmp';
    FillChar(tmpSec, SizeOf(tmpSec), #0);
    tmpSec.nLength := SizeOf(tmpSec);
    tmpSec.bInheritHandle := True;
    tmp := Windows.CreateFile(PChar(tmpName),
           Generic_Write, File_Share_Write,
           @tmpSec, Create_Always, File_Attribute_Normal, 0);
    try
      FillChar(start, SizeOf(start), #0);
      start.cb          := SizeOf(start);
      start.hStdOutput  := tmp;
      start.dwFlags     := StartF_UseStdHandles or StartF_UseShowWindow;
      start.wShowWindow := SW_Minimize;
      { Starte das Programm }
      { Start the program }
      if CreateProcess(nil, PChar(_exeName + ' ' + _cmdLine), nil, nil, True,
                       0, nil, PChar(_dirName), start, procInfo) then
      begin
        SetPriorityClass(procInfo.hProcess, Idle_Priority_Class);
        WaitForSingleObject(procInfo.hProcess, Infinite);
        GetExitCodeProcess(procInfo.hProcess, return);
        Result := (return = 0);
        CloseHandle(procInfo.hThread);
        CloseHandle(procInfo.hProcess);
        Windows.CloseHandle(tmp);
        { Die Ausgaben hinzufügen }
        { Add the output }
        res := TStringList.Create;
        try
          res.LoadFromFile(tmpName);
          Memo1.Lines.AddStrings(res);
        finally
          res.Free;
        end;
        Windows.DeleteFile(PChar(tmpName));
      end
      else
      begin
        Application.MessageBox(PChar(SysErrorMessage(GetLastError())),
          'RunCaptured Error', MB_OK);
      end;
    except
      Windows.CloseHandle(tmp);
      Windows.DeleteFile(PChar(tmpName));
      raise;
    end;
  finally
  end;
end;


// Beispiel:
// Example:

procedure TForm1.Button1Click(Sender: TObject);
begin
  RunCaptured('C:\', 'cmd.exe', '/c dir');
end;

function CreateDOSProcessRedirected(const CommandLine, InputFile, OutputFile: string): Boolean;
var
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  SecAtrrs: TSecurityAttributes;
  hInputFile, hOutputFile: THandle;
begin
  Result := False;
  hInputFile := CreateFile(PChar(InputFile), GENERIC_READ, FILE_SHARE_READ,
    CreateInheritable(SecAtrrs), OPEN_EXISTING, FILE_ATTRIBUTE_TEMPORARY, 0);
  if hInputFile <> INVALID_HANDLE_VALUE then
  begin
    hOutputFile := CreateFile(PChar(OutPutFile), GENERIC_READ or GENERIC_WRITE,
      FILE_SHARE_READ, CreateInheritable(SecAtrrs), CREATE_ALWAYS,
      FILE_ATTRIBUTE_TEMPORARY, 0);
    if hOutputFile <> INVALID_HANDLE_VALUE then
    begin
      FillChar(StartupInfo, SizeOf(StartupInfo), #0);
      StartupInfo.cb := SizeOf(StartupInfo);
      StartupInfo.dwFlags := STARTF_USESHOWWINDOW or STARTF_USESTDHANDLES;
      StartupInfo.wShowWindow := SW_HIDE;
      StartupInfo.hStdOutput := hOutputFile;
      StartupInfo.hStdInput := hInputFile;
      Result := CreateProcess(nil, PChar(CommandLine), nil, nil, True,
        CREATE_NEW_CONSOLE or NORMAL_PRIORITY_CLASS, nil, nil, StartupInfo,
        ProcessInfo);
      if Result then
      begin
        WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
        CloseHandle(ProcessInfo.hProcess);
        CloseHandle(ProcessInfo.hThread);
      end;
      CloseHandle(hOutputFile);
    end;
    CloseHandle(hInputFile);
  end;
end;


CL.AddDelphiFunction('Function CreateProcess( lpApplicationName : PChar; lpCommandLine : PChar; lpProcessAttributes, lpThreadAttributes : PSecurityAttributes; bInheritHandles : BOOL; dwCreationFlags : DWORD; lpEnvironment : Pointer; lpCurrentDirectory : PChar; const lpStartupInfo : TStartupInfo; var lpProcessInformation : TProcessInformation) : BOOL');
 
 
 CL.AddDelphiFunction('Function GetCurrentThread : THandle');
 CL.AddDelphiFunction('Function GetCurrentThreadId : DWORD');
 CL.AddDelphiFunction('Function SetThreadAffinityMask( hThread : THandle; dwThreadAffinityMask : DWORD) : DWORD');
 CL.AddDelphiFunction('Function SetThreadIdealProcessor( hThread : THandle; dwIdealProcessor : DWORD) : BOOL');
 CL.AddDelphiFunction('Function SetProcessPriorityBoost( hThread : THandle; DisablePriorityBoost : Bool) : BOOL');
 CL.AddDelphiFunction('Function GetProcessPriorityBoost( hThread : THandle; var DisablePriorityBoost : Bool) : BOOL');
 CL.AddDelphiFunction('Function SetThreadPriority( hThread : THandle; nPriority : Integer) : BOOL');
 CL.AddDelphiFunction('Function GetThreadPriority( hThread : THandle) : Integer');
 CL.AddDelphiFunction('Function SetThreadPriorityBoost( hThread : THandle; DisablePriorityBoost : Bool) : BOOL');
 CL.AddDelphiFunction('Function GetThreadPriorityBoost( hThread : THandle; var DisablePriorityBoost : Bool) : BOOL');
 CL.AddDelphiFunction('Function GetThreadTimes( hThread : THandle; var lpCreationTime, lpExitTime, lpKernelTime, lpUserTime : TFileTime) : BOOL');
 CL.AddDelphiFunction('Procedure ExitThread( dwExitCode : DWORD)');
 CL.AddDelphiFunction('Function TerminateThread( hThread : THandle; dwExitCode : DWORD) : BOOL');
 CL.AddDelphiFunction('Function GetExitCodeThread( hThread : THandle; var lpExitCode : DWORD) : BOOL');
 
 CL.AddDelphiFunction('Function GetTimeZoneInformation( var lpTimeZoneInformation : TTimeZoneInformation) : DWORD');
 CL.AddDelphiFunction('Function SetTimeZoneInformation( const lpTimeZoneInformation : TTimeZoneInformation) : BOOL');
  CL.AddDelphiFunction('Function IsProcessorFeaturePresent( ProcessorFeature : DWORD) : BOOL');

 S.RegisterDelphiFunction(@GetCurrentThread, 'GetCurrentThread', CdStdCall);
 S.RegisterDelphiFunction(@GetCurrentThreadId, 'GetCurrentThreadId', CdStdCall);
 S.RegisterDelphiFunction(@SetThreadAffinityMask, 'SetThreadAffinityMask', CdStdCall);
 S.RegisterDelphiFunction(@SetThreadIdealProcessor, 'SetThreadIdealProcessor', CdStdCall);
 S.RegisterDelphiFunction(@SetProcessPriorityBoost, 'SetProcessPriorityBoost', CdStdCall);
 S.RegisterDelphiFunction(@GetProcessPriorityBoost, 'GetProcessPriorityBoost', CdStdCall);
 S.RegisterDelphiFunction(@SetThreadPriority, 'SetThreadPriority', CdStdCall);
 S.RegisterDelphiFunction(@GetThreadPriority, 'GetThreadPriority', CdStdCall);
 S.RegisterDelphiFunction(@SetThreadPriorityBoost, 'SetThreadPriorityBoost', CdStdCall);
 S.RegisterDelphiFunction(@GetThreadPriorityBoost, 'GetThreadPriorityBoost', CdStdCall);
 S.RegisterDelphiFunction(@GetThreadTimes, 'GetThreadTimes', CdStdCall);
 S.RegisterDelphiFunction(@ExitThread, 'ExitThread', CdStdCall);
 S.RegisterDelphiFunction(@TerminateThread, 'TerminateThread', CdStdCall);
 S.RegisterDelphiFunction(@GetExitCodeThread, 'GetExitCodeThread', CdStdCall);

 S.RegisterDelphiFunction(@IsProcessorFeaturePresent, 'IsProcessorFeaturePresent', CdStdCall);
 S.RegisterDelphiFunction(@GetTimeZoneInformation, 'GetTimeZoneInformation', CdStdCall);
 S.RegisterDelphiFunction(@SetTimeZoneInformation, 'SetTimeZoneInformation', CdStdCall);
 