{***************************************************************
 * Project  : System Graphic Function Overview
 * App Name : 300_treeview_animation tester, loc's = 800 
 * Purpose  : Demonstrates outline in a tree
 * Date     : 09/12/2012  -  17:07
 * History  : convert outline VCL to maXbox Nov 2011
 *          : system save demo for mX3.9.2, not finished yet!!
            : animates a sprite cursor and balls, if XP then ProcessMessagesOFF;
 ****************************************************************}

Program Treeview3_tester3;

{@BOOL WINAPI MessageBeep(
  __in  UINT uType  );}
//TThreadFunction = function(P: Pointer): Longint; stdcall;
//Procedure ExecuteThread(afunc: TThreadFunction; var thrOK: boolean);


function MessageBoxTimeOut(hWnd: HWND; lpText: PChar; lpCaption: PChar; uType: UINT;
                wLanguageId: WORD; dwMilliseconds: DWORD): Integer;
             external 'MessageBoxTimeoutA@user32.dll stdcall';
  
procedure CloseClick(Sender: TObject; var action: TCloseAction); forward;
  
Const
  BACKMAP = 'examples\images\bmp47.bmp';
  //BACKMAP = 'examples\images\bmp33.bmp';
  BITMAP1 = 'examples\images\empty.bmp';
  BITMAP2 = 'examples\images\empty.bmp';
  //BITMAP1 = 'examples\images\bmp21.bmp';  //try another combinations
  //BITMAP2 = 'examples\images\bmp29.bmp';
  //BITMAP2 = 'examples\images\bmp33.bmp';
  SAVEPATH = 'examples\treeview_300.txt';
  AExponent = 4;
  ANIMATEDELAY = 6;
  
type
  TByteArr = array of byte;
  
var
  except_state, execute_state: string;  
  mytimestamp: TDateTime;
  osType: TIdWin32Type;
  bfrm: TForm;
  FMask, FPic, FPicled, FPicRed, FPicGreen, FStorage: TBitMap;
  FNewRect: TRect; 
  FOldRect: tRect; //make foldrect local!
  FirstTime: boolean;
  tv1: TTreeView;
  mt: ttoolwindow;
  mtd: ttooldockform;
  distX, distY, glx,gly, step, pct: float;
  endX, endY, beginX, beginY: integer;
  ashape: TShape;

  
procedure getMaxBoxIni;
var Ini: TIniFile;   
begin
  Ini:= TIniFile.Create(ExePath+'maxboxdef.ini');
  try
    except_state:= Ini.ReadString('Form', 'EXCEPTIONLOG','');
    execute_state:= Ini.ReadString('Form', 'EXECUTESHELL','');
  finally
    writeln('inifile sysdata test: '+(except_state)+ ' '+(execute_state))
    ini.Free;
  end;
end;


procedure FormDrawBitmap(const fname: String; const x,y: Integer; acanvas: TCanvas);
var aBmp: TBitmap;
begin
  if not FileExists(Fname) then begin
    ShowMessage('The big bitmap ' + Fname + ' was not found!');
    Exit;
  end;
  aBmp:= TBitmap.Create;
  try
    aBmp.LoadFromFile(Fname);
    //aCanvas.Draw(x,y, aBmp);
    aCanvas.StretchDraw(Rect(0,0,bfrm.width, bfrm.height), aBmp);
  finally
    aBmp.Free;
  end;
end; 

procedure BitmapFormCreate(Sender: TObject);
begin
  FMask:= TBitMap.Create;
  FMask.LoadFromFile(exepath+BITMAP2);
  //FMask.LoadFromFile(exepath+'examples\citymax.bmp');
  FPic:= TBitMap.Create;
  FPic.LoadFromFile(exepath+BITMAP1);
  FPicled:= TBitMap.Create;
  FPicRed:= TBitMap.Create;
  FPicGreen:= TBitMap.Create;
    
  FPicled.LoadFromFile(Exepath+'\examples\images\yellow1.bmp');
  FPicRed.LoadFromFile(Exepath+'\examples\images\red1.bmp');
  FPicGreen.LoadFromFile(Exepath+'\examples\images\green1.bmp');
  
  FStorage:= TBitMap.Create;
  FStorage.Width:= FPic.Width;
  FStorage.Height:= FPic.Height;
  Screen.Cursor:= crCross;//loadCursor(hinstance,'Pan_All'); //crCross;
end;  


//********************************Event Handler*****************************//
procedure BtnAddClick(Sender: TObject);
{   fill(0, 2);
  rect(0, 0, width, height);
  pct += step;
  if (pct < 1.0) {
    x = beginX + (pct * distX);
    y = beginY + (pow(pct, exponent) * distY);  }
  //fill(255);  //ellipse(x, y, 20, 20);
var i: integer;  
begin
  pct:= 0.0;
  distX:= endX - beginX;
  distY:= endY - beginY;
  for i:= 1 to 100 do begin
  pct:= pct+ step;
  if (pct < 1.0) then begin
    glx:= beginX + (pct * distX);
    gly:= beginY + (Power(pct, AExponent) * distY);
  end;
  //  bfrm.repaint;
  //bfrm.canvas.draw(round(x),round(y), fpic);                           
  bfrm.canvas.draw(round(glx)-20,round(gly-20),fPicLed);
  bfrm.canvas.draw(round(glx)+30,round(gly+30),fPicRed);
  bfrm.canvas.draw(round(glx)+80,round(gly+80),fPicGreen);
    // BitBlt(FStorage.Canvas.Handle,0,0, FPic.Width, FPic.Height,
              // bfrm.Canvas.Handle, round(x), round(y), SRCCOPY);
  delay(ANIMATEDELAY);
  end;
end;

procedure TForm1_Button1Click(Sender: TObject);
var panel1: TPanel;
begin
 with Panel1 do begin
   BevelInner:= bvLowered;
   BevelOuter:= bvRaised;
   if BevelWidth = 0 then
     BevelWidth := 2
   else
   BevelWidth := 0;
  end;
end;

procedure RandomClick(Sender: TObject);
var i: integer;  
begin
  pct:= 0.0;
  beginX:= random(round(glx));
  beginY:= random(round(gly));
  distX:= abs(random(endX - beginX)+50);
  distY:= abs(random(endY - beginY)+50);
  //showmessage(inttostr(endx));
  for i:= 1 to 100 do begin
  pct:= pct+ step;
  if (pct < 1.0) then begin
    glx:= beginX + (pct * distX);
    gly:= beginY + (Power(pct, sin(AExponent)) * distY);
  end;
  //bfrm.repaint;
  //bfrm.canvas.draw(round(x),round(y), fpic);                           
  bfrm.canvas.draw(round(glx)-20,round(gly-20),fPicLed);
  bfrm.canvas.draw(round(glx)+30,round(gly+30),fPicRed);
  bfrm.canvas.draw(round(glx)+80,round(gly+80),fPicGreen);
    // BitBlt(FStorage.Canvas.Handle,0,0, FPic.Width, FPic.Height,
              // bfrm.Canvas.Handle, round(x), round(y), SRCCOPY);
  delay(ANIMATEDELAY);
  end;

end;

procedure CloseClick(Sender: TObject; var action: TCloseAction);
begin
  FMask.Free;
  FPic.Free;
  if assigned (FPicled) then FPicled.Free;
  if assigned (FPicRed) then FPicRed.Free;
  if assigned (FPicGreen) then FPicGreen.Free;
  FStorage.Free;
  if assigned (ashape) then ashape.Free;
  action:= caFree;
  Screen.Cursor:= crDefault;
  writeln('Outline Form being closed');
end;

procedure CloseButtonClick(Sender: TObject);
begin
  bfrm.Close; //calls close click
end;

procedure ClickTestButton(Sender: TObject);
begin
  //tv1.SaveToFile(SAVEPATH);
  //SaveCanvas2(bfrm.Canvas, Exepath+SAVEPATH);
  writeln(objectToStr(sender)+' has been hit at: '+Exepath+SAVEPATH);
end;


procedure DblClickButton(Sender: TObject);
begin
  tv1.SaveToFile(Exepath+SAVEPATH);
  //SaveCanvas2(bfrm.Canvas, Exepath+SAVEPATH);
  writeln('Outline being stored at: '+Exepath+SAVEPATH);
  bfrm.canvas.draw(300,200, getbitmap(Exepath+'\examples\citymax.bmp'));
end;

procedure drawE(abeginx, abeginy, endx, endy: integer); 
{   fill(0, 2);
  rect(0, 0, width, height);
  pct += step;
  if (pct < 1.0) {
    x = beginX + (pct * distX);
    y = beginY + (pow(pct, exponent) * distY);  }
  //fill(255);  //ellipse(x, y, 20, 20);
var i: integer;  
begin
  pct:= 0.0;
  distX:= endX - beginX;
  distY:= endY - beginY;
  for i:= 1 to 100 do begin
  pct:= pct+ step;
  if (pct < 1.0) then begin
    glx:= beginX + (pct * distX);
    gly:= beginY + (power(pct, AExponent) * distY);
  end;
  //  bfrm.repaint;
  //bfrm.canvas.draw(round(x),round(y), fpic);
  bfrm.canvas.draw(round(glx)-20,round(gly-20),fPicLed);
    // BitBlt(FStorage.Canvas.Handle,0,0, FPic.Width, FPic.Height,
              // bfrm.Canvas.Handle, round(x), round(y), SRCCOPY);
  delay(ANIMATEDELAY);
  end;
end;  


procedure drawE2(abeginx, abeginy, endx, endy: integer); 
var i: integer;  
begin
  pct:= 0.0;
  distX:= endX - beginX;
  distY:= endY - beginY;
  for i:= 1 to 100 do begin
  pct:= pct+ step;
  if (pct < 1.0) then begin
    glx:= beginX + (pct * distX);
    gly:= beginY + (power(pct, AExponent+5) * distY);
  end;
  bfrm.canvas.draw(round(glx)-20,round(gly-20), fPicRed);
  delay(ANIMATEDELAY);
  end;
end;  

procedure drawE3(abeginx, abeginy, endx, endy: integer); 
var i: integer;  
begin
  pct:= 0.0;
  ashape:= TShape.create(bfrm);
  with ashape do begin
    parent:= bfrm;
    Shape:= stCircle;
    Brush.Color:= clpurple;
    Brush.Style:= bsSolid; //bsVertical;
    Pen.width:= 2;
    //onmousedown;
 end;
  for i:= 1 to 100 do begin
  pct:= pct+ step;
    if (pct < 1.0) then begin
      glx:= beginX + (pct * (endX - beginX));
      gly:= beginY + (power(pct, AExponent+9) * (endY - beginY));
    end;
    //bfrm.canvas.draw(round(glx)-20,round(gly-20), fPicGreen);
    ashape.SetBounds(round(glx)-20, round(gly-20), 35,35);
    //ashape.screentoclient;
    //ashape.repaint;
    //ashape.show;
    delay(ANIMATEDELAY);
  end;
  //ashape.Free;
end;  


procedure setup(); 
{ size(640, 360); noStroke();
  distX = endX - beginX;
  distY = endY - beginY; }
begin
  beginX:= 20;  // Initial x-coordinate
  beginY:= 20;  // Initial y-coordinate
  endX:= 570;   // Final x-coordinate
  endY:= 320;   // Final y-coordinate
  glx:= 20.0;        // Current x-coordinate
  gly:= 20.0;        // Current y-coordinate
  step:= 0.01;    // Size of each step along the path  100 steps
  pct:= 0.0;      // Percentage traveled (0.0 to 1.0)
  distX:= endX - beginX;
  distY:= endY - beginY;
end;


procedure FormMouseDown(sender: TObject; Button: TMouseButton; 
                                Shift: TShiftState; vX, vY: Integer);
begin
  BitBlt(FStorage.Canvas.Handle,0,0, FPic.Width, FPic.Height,
               bfrm.Canvas.Handle, FNewRect.Left, FNewRect.Top, SRCCOPY);
  pct:= 0.0;
  beginX:= round(glx);
  beginY:= round(gly);
  endX:= vX;     //mouseX
  endY:= vY;
  if shift = [ssleft] then
    bfrm.repaint;
  //FormDrawBitmap(Exepath+BACKMAP,10,10, bfrm.canvas);
  drawE(beginx,beginy, endx,endy);
  drawE2(beginx,beginy, endx,endy);
  drawE3(beginx,beginy, endx,endy);
end;

procedure FormMouseMove(Sender: TObject; Shift: TShiftState; X,Y: Integer);
//const FirstTime: boolean = True;
//var FOldRect: TRect;     //makes a blur and zoom effect
begin
  //firsttime:= true;   //move tester
  { 1) Restore Form1: copy storage onto Form1 at its old location }
  //FOldRect:= Rect(280, 200, X , Y);
  if FirstTime then FirstTime:= False
    else BitBlt(bfrm.Canvas.Handle, FOldRect.Left, FOldRect.Top,
     FPic.Width,FPic.Height, FStorage.Canvas.Handle,0,0,SRCCOPY);
  { save old location }
  FNewRect:= Rect(X, Y, X + FPic.Width, Y + FPic.Height);
  FOldRect:= FNewRect;
  { 2) Save copy: copy rectangle from Form1 to storage at new location.}
  BitBlt(FStorage.Canvas.Handle,0,0, FPic.Width, FPic.Height,
         bfrm.Canvas.Handle, FNewRect.Left, FNewRect.Top,  SRCCOPY);
  { 3) copy the image to Form1 using SRCINVERT }
  BitBlt(bfrm.Canvas.Handle, FNewRect.Left, FNewRect.Top, FPic.Width, FPic.Height,
         FPic.Canvas.Handle,0,0, SRCAND);
end;



//********************************Form Builder*****************************//
procedure InitBitmapForm;
var
  RootNode: TTreeNode;
   myc: TCollection;   
   //images: TCustomImagelist;
 
begin
 Setup;
 bfrm:= TForm.create(self);
  //mt.free;  in on close
 with bfrm do begin
   //FormStyle := fsStayOnTop;
   Position:= poScreenCenter;
   caption:='Outline TreeView Velocity OTV Demo - DblClick to Save Outline';
   color:= clwhite;
   width:= 800;
   height:= 700;
   //canvas.Pen.mode:= pmNotXor;
   onMouseMove:= @FormMouseMove;
   onMouseDown:= @FormMouseDown;
   onDblClick:= @DblClickButton;
   onclick:= @clicktestbutton;
   onClose:=  @CloseClick;
   //canvas.brush.bitmap.loadfromfile(Exepath+backmap);
   Show;
   //canvas.draw(300,200, getbitmapObject2(Exepath+'\examples\citymax.bmp'));
   //Show;
 end;

 with TBitBtn.create(bfrm) do begin
   parent:= bfrm;
   setbounds(580,580,150,55)
   font.size:= 12;
   glyph.LoadFromResourceName(HINSTANCE,'CL_MPSTOP');
   mXButton(05,05,width, height,12,12,handle);
   caption:= '&Close App';
   onClick:= @closeButtonClick;
 end;
 with TBitBtn.Create(bfrm) do begin
   Parent:= bfrm;
   setbounds(260,580,150, 55);
   caption:= 'All& Balls';
   font.size:= 12;
   glyph.LoadFromResourceName(getHINSTANCE,'CL_MPNEXT');
   mXButton(05,05,width, height,12,12,handle);
   onClick:= @BtnAddClick;
 end;
 with TBitBtn.Create(bfrm) do begin
   Parent:= bfrm;
   setbounds(420,580,150, 55);
   caption:= '&Random Ball';
   font.size:= 12;
   glyph.LoadFromResourceName(getHINSTANCE,'CL_MPRECORD');
   mXButton(05,05,width, height,12,12,handle);
   onClick:= @RandomClick;
 end;
 FirstTime:= true;
 
  (*with TStatusPanel.create(self) do begin
  //parent
    width:= 200;
    text:= 'status panel';
    alignment:= alleft;
  end;*)
  
  with TStatusBar.create(bfrm) do begin
    parent:= bfrm;
    simplepanel:= true;
    color:= clyellow;
    //align:= alleft;
    showhint:= true;
    hint:= 'this is box';
    //simpletext.font.size:= 12;
    simpletext:= 'this is status bar';
    //visible:= true;
    //width:= 200;
    //alignment:= alleft;
    //onclick:= 
  end;
   tv1:= TTreeView.Create(bfrm);
  with tv1 do begin
   parent:= bfrm;
   Loadfromfile(ExePath+SAVEPATH);
  setbounds(5,310,160, 160);
   writeln(inttostr(width));
   FullExpand;
   //Items[2].addchild('','');
   //color
    onclick:= @clicktestbutton;
    //images.getBitmap(0,getBitmap2(Exepath+BITMAP2));
   //onclick
   //images
  end; 
 
  with TRichEdit.Create(bfrm) do begin
    parent:= bfrm;
    clear;
    setbounds(5,475,220,160);
    //findtext
    wordwrap:= true;
    color:= clteal;
    font.size:= 12;
    //Loadfromfile(ExePath+SAVEPATH);
    //PlainText
    scrollbars:= true;
    Lines.Add('This is {b super} real');
    Lines.LoadfromFile(ExePath+SAVEPATH);
    with SelAttributes do begin
      Color:= clGreen;
      Height:= 10;
      Style:= [fsBold]; // b
    end;
    //print
    ///align
    wanttabs:= true;
    onclick:= @clicktestbutton;
    //free;
  end;
end; 

procedure PrintList(Value: TStringList);
var
  I, Line, Pagenum: Integer;
begin
  //let's print
  //if Assigned(FOnBeginPrint) then
    //FOnBeginPrint(Self);
  line := 0;
  Printer.BeginDoc;
  Pagenum := 1;
  for I := 0 to Value.Count - 1 do begin
    //if Assigned(FOnProgress) then
      //FOnProgress(Self, I + 1, Value.Count);
    Line := Line + Printer.Canvas.TextHeight(Value[I]);
    if Line + Printer.Canvas.TextHeight(Value[I]) > Printer.PageHeight then begin
      Line := Printer.Canvas.TextHeight(Value[I]);
      Printer.NewPage;
      Inc(PageNum);
      //if Assigned(FOnNextPage) then
        //FOnNextPage(Self, PageNum);
    end;
    Printer.Canvas.TextOut(0, Line, Value[I]);
  end;
  Printer.EndDoc;
  //if Assigned(FOnFinishedPrint) then
    //FOnFinishedPrint(Self);
end;

  function maxcalcfunc(a: extended): extended;
  begin
    result:= cotan(a);
  end;  
  
function TimeStampInterval(StartStamp, EndStamp: TDateTime): integer;
var
  days: Integer;
  hour, min, s, ms: Word;
begin
  days := Trunc(EndStamp - StartStamp); // whole days
  DecodeTime(EndStamp - StartStamp, hour, min, s, ms);
  result := (((days * 24 + hour) * 60 + min) * 60 + s) * 1000 + ms;
end;

 
 var    myus: TUserfunction;
        aobj: TObject;
        //mylog: TFoLog;
        bitstyle: TBitmapstyle;
        UserSpaceAvail, TotalSpaceAvail, DiskSize: Comp; {disk size}

begin   //main of animationbox
   //InifileRead;
   ProcessMessagesON;
   getMaxBoxIni;
   writeln('Thread ID :'+intToStr(CurrentThreadID))
   writeln('Process ID :'+intToStr(CurrentProcessID))
   writeln('machine name is: '+getHostName)
   writeln('user name is: '+getUserName)
   osType:= Win32Type;
   writeln('OS Type is: '+intToStr(ord(osType)));
   mytimestamp:= GetFileCreationTime(exepath+'maxbox3.exe')
   writeln(DateTimeToStr(mytimestamp)+' for maXbox3 file')
   //SearchAndOpenDoc(ExtractFilePath(ParamStr(0))+'docs\maxbox_starter16.pdf')
   //ExecuteCommand('cmd','/k dir *.*')
   BitmapFormCreate(self);
   InitBitmapForm;
   //FormDrawBitmap(Exepath+BACKMAP,10,10, bfrm.canvas);
   //bfrm.canvas.brush.bitmap.loadfromfile(Exepath+backmap);
   //bfrm.canvas.draw(300,200, getbitmapObject(Exepath+backmap));
    //Form1.Canvas.Brush.Bitmap := Bitmap;
    //Form1.Canvas.FillRect(Rect(0,0,100,100));
   //abmap:= getbitmapObject(Exepath+backmap);
   //GrayscaleBitmap(abmap);
   //bfrm.canvas.brush.bitmap:= abmap;

   bfrm.canvas.brush.bitmap:= getbitmapObject(Exepath+backmap);
   bfrm.Canvas.FillRect(Rect(400,300,100,100));
 
   //bfrm.canvas.top:= 200;
   //bfrm.canvas.brush.bitmap.width:= 300;
   //FormDrawBitmap(BITMAP2,540,10, bfrm.canvas);
   CurrencyFormat;
   //VarComplexToPolar
   //CheckSynchronize
    if isMultiThread then writeln('multi');
    //maXbox
    myus:= @maxcalcfunc;
    
    with TJvMathParser.create do begin
      //registeruserfunction('maxcalcfunc', myus);
      execute('4+6')
      Free;
    end; 
    //TObject.instancesize
    with TPersistent.Create do begin
      //cleanupinstance;
      //classname
      writeln(getnamepath);
      Free;
    end;
    with TComport.Create(self) do begin
      //cleanupinstance;
      //classname
      open;
      writeln('com handle '+inttostr(handle));
      codepage;
      buffer;
      writeln('of com port '+getnamepath);
      if connected then writeln(' com connect');
      close;
      Free;
    end;
  
    aobj:= TObject.Create;
    freeandnil2(aobj);
    //RIRegister_StGenLog_Routines
    //Function HexifyBlock( var Buffer, BufferSize : Integer) : string');
    //HexifyBlock( var Buffer, BufferSize : Integer) : string');
    //maxform1.CB1SCList.color:= clred;
    maxform1.mxNavigator.color:= clyellow;
    
    //JvFormLog
    with TJvLogFile.Create(self) do begin
      add('first','second','third');
     //parent:= bfrm;
     //showlog('maxbox');
     free;
    end;
    RandomClick(Self);
    bitstyle:= bsCentered;
    //printimage(getbitmapObject(Exepath+backmap),bscentered); 
    writeln(inttostr(vk_back))
    writeln(inttostr(vk_F1))
    //formatmasktext
    //MaskGetMaskSave
    GetEnvironmentInfo;
    //FindFilesDlg(StartIn: string; SpecialFolder: TJvSpecialFolder; UseFolder: Boolean): Boolean;
    //FindFilesDlg(Exepath, sfPrograms, true);
    //getrandomstring
    //copyfile
    //CreateTempFile
    
    {DeleteVolumeLabel}
//function DeleteVolumeLabel(Drive : AnsiChar) : Cardinal;
{-Deletes an existing volume label on Drive. Returns 0 for success,
  or OS error code.}
   //DeleteVolumeLabel(Drive : AnsiChar) : Cardinal;

{EnumerateDirectories}
//procedure EnumerateDirectories(const StartDir : AnsiString; FL : TStrings; {!!.02}
  //                             SubDirs : Boolean;
    //                           IncludeItem : TIncludeItemFunc);
{-Retrieves the complete path name of directories on requested file
  system path.}
  //EnumerateDirectories
  
  writeln('DriveDelim= '+DriveDelim) 

{EnumerateFiles}
//procedure EnumerateFiles(const StartDir : AnsiString; FL : TStrings;   {!!.02}
  //                       SubDirs : Boolean;
    //                     IncludeItem : TIncludeItemFunc);
{-Retrieves the complete path name of files in a requested file system path.}

  //EnumerateFiles
{FileHandlesLeft}
 //FileHandlesLeft(MaxHandles : Cardinal) : Cardinal;
{-Return the number of available file handles.}

{FileMatchesMask}
   //FileMatchesMask(const FileName, FileMask : AnsiString ) : Boolean;
{-see if FileName matches FileMask}

{FileTimeToStDateTime}
  //FileTimeToStDateTime(FileTime : LongInt) : TStDateTimeRec;
{-Converts a DOS date-time value to TStDate and TStTime values.}

{FindNthSlash}
  //FindNthSlash( const Path : AnsiString; n : Integer ) : Integer;
{ return the position of the character just before the nth slash }
  writeln('FindNthSlash '+inttostr(FindNthSlash(Exepath, 9)));

{FlushOsBuffers}
   //FlushOsBuffers(Handle : Integer) : Boolean;
{-Flush the OS buffers for the specified file handle.}

{GetCurrentUser}
  //GetCurrentUser : AnsiString;
{-Obtains current logged in username}

{GetDiskClass}
 //GetDiskClass(Drive : AnsiChar) : DiskClass;
{-Return the disk class for the specified drive.}
{GetDiskInfo}
  //GetDiskInfo(Drive : AnsiChar; var ClustersAvailable, TotalClusters,
    //                 BytesPerSector, SectorsPerCluster : Cardinal) : Boolean;
{-Return technical information about the specified drive.}
{GetDiskSpace}
 //GetDiskSpace(Drive : AnsiChar;
   //               var UserSpaceAvail  : Comp;           {space available to user}
     //             var TotalSpaceAvail : Comp;           {total space available}
       //           var DiskSize        : Comp) : Boolean;{disk size}
{-Return space information about the drive.}

 if GetDiskSpace('C',UserSpaceAvail,TotalSpaceAvail,DiskSize) then
     printF('UserSpaceAvail: %d TotalSpaceAvail: %d DiskSize: %d',
         [UserSpaceAvail div 1024,TotalSpaceAvail div 1024,DiskSize div 1024]);
{

{GetFileCreateDate}
 //GetFileCreateDate(const FileName : AnsiString) :
  //TDateTime;
{-Obtains file system time of file creation.}

{GetFileLastAccess}
 //StGetFileLastAccess(const FileName : AnsiString) :
  //TDateTime;
{-Obtains file system time of last file access.}

{GetFileLastModify}
 //GetFileLastModify(const FileName : AnsiString) :
  //TDateTime;
{-Obtains file system time of last file modification.}

{GetHomeFolder}
 //GetHomeFolder(aForceSlash : Boolean) : AnsiString;
{-Obtains the "Home Folder" for the current user}

{$IFNDEF CBuilder}
{GetLongPath}
 //GetLongPath(const APath : AnsiString) : AnsiString;
{-Returns the long filename version of a provided path.}
{$ENDIF}

{GetMachineName}
  //GetMachineName : AnsiString;
{-Returns the "Machine Name" for the current computer }
  //gethostname
{GetMediaID}
  //GetMediaID(Drive : AnsiChar; var MediaIDRec : MediaIDType) : Cardinal;
{-Get the media information (Volume Label, Serial Number) for the specified drive}

{GetParentFolder}
 //GetParentFolder(const APath : AnsiString; aForceSlash : Boolean) : AnsiString;
{-return the parent directory for the provided directory }
{GetShortPath}
 //GetShortPath(const APath : AnsiString) : AnsiString;
{-Returns the short filename version of a provided path.}

{GetSystemFolder}
 //GetSystemFolder(aForceSlash : Boolean) : AnsiString;
{-Returns the path to the Windows "System" folder".)

{GetTempFolder}
 //GetTempFolder(aForceSlash : boolean) : AnsiString;
{-Returns the path to the system temporary folder.}

{GetWindowsFolder}
 //StGetWindowsFolder(aForceSlash : boolean) : AnsiString;
{-Returns the path to the main "Windows" folder.}

{GetWorkingFolder}
 //GetWorkingFolder(aForceSlash : boolean) : AnsiString;
{-Returns the current working directory.}

{GlobalDateTimeToLocal}
 //GlobalDateTimeToLocal(const UTC: TStDateTimeRec; MinOffset: Integer): TStDateTimeRec; {!!.02}
{-adjusts a global date/time (UTC) to the local date/time}

{IsDirectory}
 //StIsDirectory(const DirName : AnsiString) : Boolean;
{-Return True if DirName is a directory.}
{IsDirectoryEmpty}
 //IsDirectoryEmpty(const S : AnsiString) : Integer;
{-checks if there are any entries in the directory}
{IsDriveReady}
 //IsDriveReady(Drive : AnsiChar) : Boolean;
{-determine if requested drive is accessible }
{IsFile}
 //IsFile(const FileName : AnsiString) : Boolean;
{-Determines if the provided path specifies a file.}
{IsFileArchive}
 //IsFileArchive(const S : AnsiString) : Integer;
{-checks if file's archive attribute is set}
{IsFileHidden}
 //IsFileHidden(const S : AnsiString) : Integer;
{-checks if file's hidden attribute is set}
{IsFileReadOnly}
  //IsFileReadOnly(const S : AnsiString) : Integer;
{-checks if file's readonly attribute is set}
{IsFileSystem}
 //IsFileSystem(const S : AnsiString) : Integer;
{-checks if file's system attribute is set}
{LocalDateTimeToGlobal}
 //LocalDateTimeToGlobal(const DT1: TStDateTimeRec; MinOffset: Integer): TStDateTimeRec; {!!.02}
{-adjusts a local date/time to the global (UTC) date/time}
{ReadVolumeLabel}
 //ReadVolumeLabel(var VolName : AnsiString; Drive : AnsiChar) : Cardinal;
{-Get the volume label for the specified drive.}
{SameFile}
 //SameFile(const FilePath1, FilePath2 : AnsiString; var ErrorCode : Integer) : Boolean;
{-Return True if FilePath1 and FilePath2 refer to the same physical file.}
{SetMediaID} {!!!! does not work on NT/2000 !!!!}
 //SetMediaID(Drive : AnsiChar; var MediaIDRec : MediaIDType) : Cardinal;
{-Set the media ID record for the specified drive.}

{SplitPath}
 //SplitPath(const APath : AnsiString; Parts : TStrings);
{-Splits the provided path into its component sub-paths}

{StDateTimeToFileTime}
 //StDateTimeToFileTime(const FileTime : TStDateTimeRec) : LongInt;  {!!.02}
{-Converts an TStDate and TStTime to a DOS date-time value.}
{StDateTimeToUnixTime}
 //StDateTimeToUnixTime(const DT1 : TStDateTimeRec) : Longint;   {!!.02}
{-converts a TStDateTimeRec to a time in Unix base (1970)}
{UnixTimeToStDateTime}
 //UnixTimeToStDateTime(UnixTime : Longint) : TStDateTimeRec;
{-converts a time in Unix base (1970) to a TStDateTimeRec}

{ValidDrive}
 //ValidDrive(Drive : AnsiChar) : Boolean;
{-Determine if the drive is a valid drive.}

{WriteVolumeLabel}
 //WriteVolumeLabel(const VolName : AnsiString; Drive : AnsiChar) : Cardinal;
{-Sets the volume label for the specified drive.}

End.   

------------------------------------------------
Windows crashed again. I am the Blue Screen of Death. No one hears your screams.
Three things are certain: Death, taxes, and lost data. Guess which has occurred.
There is no place like 127.0.0.1 

http://en.wikipedia.org/wiki/Sneakers_%281992_film%29

with WebOutline.Outline.Items do
  begin
    {The following example code for adding nodes came from the Delphi 7 Help
     for TTreeView. Apologies for lack of imagination.}

    Clear; { remove any existing nodes }
    MyTreeNode1:= Add(nil,ExtendFakeData('RootTreeNode0'));{ Add a root node }
    { Add a child node to the node just added }
    AddChild(MyTreeNode1,ExtendFakeData('ChildNode0'));

    {Add another root node}
    MyTreeNode2 := Add(MyTreeNode1, ExtendFakeData('RootTreeNode1'));
    {add a child }
    AddChild(MyTreeNode2,ExtendFakeData('ChildNode1'));

    {Reuse MyTreeNode2}
    { and add a child node to it}
    MyTreeNode2 := WebOutline.Outline.Items[3];
    AddChild(MyTreeNode2,ExtendFakeData('ChildNode1a'));

    {Add a sibling}
    Add(MyTreeNode2,ExtendFakeData('ChildNode1b'));

    {add another root node}
    Add(MyTreeNode1, ExtendFakeData('RootTreeNode2'));
  end;
end;

procedure RotateBitmap(var htmpBitmapDC: TBitmap; var lWidth : Longint;
                  var lHeight : Longint; lRadians : real; origmap: TBitmap);
var
         I,J : Longint;               // loop counter
         //htmpBitmapDC : Longint;    // DC of the new bitmap
         lSine,lCosine : extended;          // sine,cosine used in rotation
         X1,X2,X3,Y1,Y2,Y3 : Longint;     // used in calculating new bitmap dimensions
         lMinX,lMaxX,lMinY,lMaxY: Longint;  
         lNewWidth,lNewHeight : Longint;  // width of new bitmap
         lSrcX,lSrcY  : Longint;   // x,y pixel coord we are blitting from the source image
         myrect: TRect;
begin
   // create a compatible DC from the one just brought
   // compute the sine/cosinse of the radians used to // rotate this image
    //tbmpDC:= tbmp.handle;
   lSine := Sin(lRadians);
   lCosine := Cos(lRadians);
   // compute the size of the new bitmap being created
   X1 := Round(-lHeight * lSine);
   Y1 := Round(lHeight * lCosine);
   X2 := Round(lWidth * lCosine - lHeight * lSine);
   Y2 := Round(lHeight * lCosine + lWidth * lSine);
   X3 := Round(lWidth * lCosine);
   Y3 := Round(lWidth * lSine);
   // figure out the max/min size of the new bitmap
   lMinX := Min(0, Min(X1, Min(X2, X3)));
   lMinY := Min(0, Min(Y1, Min(Y2, Y3)));
   lMaxX := Max(X1, Max(X2, X3));
   lMaxY := Max(Y1, Max(Y2, Y3));
   // set the new bitmap width/height
   lNewWidth:= lMaxX - lMinX;
   lNewHeight:= lMaxY - lMinY;
   // create a new bitmap based upon the new width/height of the // rotated bitmap
   //hNewBitmap := CreateCompatibleBitmap(hBitmapDC, lNewWidth, lNewHeight);
   htmpBitmapDC.height:= lNewHeight;
   htmpBitmapDC.width:= lNewWidth;
   //myRect:= Rect(0,0,lwidth,lheight); 
   //bfrm.Canvas.BrushCopy(MyRect, Image1.Picture.Bitmap, MyRect, clred);
   For I:= 0 To lNewWidth do begin
     For J:= 0 To lNewHeight do begin
       lSrcX:= Round((J + lMinX) * lCosine + (I + lMinY) * lSine);
       lSrcY:= Round((I + lMinY) * lCosine - (J + lMinX) * lSine);
       If (lSrcX >= 0) And (lSrcX <= lWidth) And
          (lSrcY >= 0) And (lSrcY <= lHeight) Then begin
         BitBlt(htmpBitmapDC.canvas.handle,J,I,lnewheight,lnewwidth,origmap.canvas.handle, lSrcX,lSrcY, SRCCOPY);
        end;
     end;
  end;
  //Image1.Refresh; 
  lWidth:= htmpBitmapDC.width;
  lHeight:= htmpBitmapDC.height;
End;
      
procedure TForm1_RotateTest2(Sender: TObject);
var
 lRadians: real;
 tbmpDC, H,W, Degrees: longint;
 mybitmap: TBitmap;
 MyRect: TRect;
begin
  mybitmap:= TBitmap.create;
  mybitmap.loadfromfile(exepath+'examples\citymax.bmp')
  image1.width:= mybitmap.width;
  image1.height:= mybitmap.height;
  //Image1.Picture.BitMap.PixelFormat:= pf24bit; 
  Image1.Picture.BitMap:= mybitmap;
  //mybitmap.Free;
  Degrees:= 45;
  lRadians:= PI * Degrees / 180;
  W:= Image1.Picture.Width;
  H:= Image1.Picture.Height;
  //W:= Image1.Width;
  //H:= Image1.Height;
  mybitmap:= TBitmap.create;
  RotateBitmap(mybitmap, W, H, lRadians, Image1.Picture.Bitmap);
  myRect:= Rect(0,0,W,H); 
  //bfrm.Canvas.CopyRect(MyOther,mybitmap.Canvas,MyRect);
  Image1.Width:= W;
  Image1.Height:= H;
  Image1.Picture.Bitmap.Width:= W;
  Image1.Picture.Bitmap.Height:= H;
  //Image1.Picture.bitmap:= mybitmap;
  BitBlt(Image1.Picture.Bitmap.Canvas.Handle,0,0,W,H,mybitmap.canvas.handle,0,0,SRCCopy);
  //bfrm.Canvas.BrushCopy(MyRect, Image1.Picture.Bitmap, MyRect, clRed);
  //for j:= 1 to image1.height do
    //image1.Picture.Bitmap.Canvas.pixels[j,j]:= clred; //test line
  mybitmap.Free;
  Image1.Refresh; 
end;



procedure CurrencyFormat;
var fSettings: TFormatSettings;
begin
  GetLocaleFormatSettings(LOCALE_SYSTEM_DEFAULT, fSettings);
  writeln(fsettings.timeAMString);
  writeln(fsettings.longDateFormat);
  writeln(fsettings.shortDateFormat);
    //writeln(currtostrF
  writeln('currtostrFS 1234.56 formats with setting as = '+
             CurrToStrFS(1234.5678989, ffCurrency, 4, fSettings));
             writeln(FloatToStrF(1234.5678989, ffCurrency, 6, 6));
  writeln('currtostrFS and back as = '+
             CurrToStrFS(strToCurr('1234.5678989'), ffCurrency, 4, fSettings));
end; 

procedure maxcalc_demo;
begin
  printF('this is %.6f',[maXcalc('ln(2)+fact(388)+2!')]); 
  printF('this is %.6f',[maXcalc('(4!)^(3!)')]); 
  printF('this is %.6f',[maXcalc('4!+4!')]); 
  printF('this is %.6f',[maXcalc('log(22)')]); 
  printF('this is logN %.6f',[maXcalc('2%256')]);
  writeln('ln(e): '+floattostr(maXcalc('ln(e)')))
  writeln(floattostr(maXcalc('e+10^6')))
  printF('addition theorem %.18f ',[maXcalc('sin(2.5/2)')])
  printF('addition theorem %.18f ',[maXcalc('sqrt(1/2*(1-cos(2.5)))')])
  printF('addition theorem2 %22.18f ',[maXcalc('cos(2.5/2)')])
  printF('addition theorem2 %22.18f ',[maXcalc('sqrt(1/2*(1+cos(2.5)))')])
  maXcalcF('2%256+2^10');
end; 

50000  = 0.693137180659968
100000 = 0.693142180584982
500000 = 0.693146180561005
10^6   = 0.693146680560255
5*10^6 = 0.693147080560068
50*10^6= 0.693147170560399    //Runtime: 0:28:22.422
ln(2)  = 0.693147180559945

(* zeta:= 0;
     for i:= 1 to 50000 do 
       if i mod 2 = 0 then
         zeta:= zeta - 1/i else
         zeta:= zeta + 1/i;
       writeln('harmonic alternate to ln(2): '+floattostr(zeta))  
       writeln(floattostr(maxcalc('ln(2)')))
       writeln(floattostr(ln2))    *)
   

type
  //PThreadSortArray = ^TThreadSortArray;
  //TThreadSortArray = array[0..MaxInt div SizeOf(Integer) - 1] of Integer;
  TSortArray =  array[1..ARRSIZE] of Integer;


  TSortThread = class(TThread)
  strict private
    FBox: TPaintBox;
    //FSortArray: PThreadSortArray;
    FSortArray: TSortArray;
    FSize: Integer;
    FA, FB, FI, FJ: Integer;
    Fbolthslowmotion: boolean;
    procedure DoVisualSwap;
    procedure Setbolthslowmotion(const Value: boolean);
  protected
    procedure Execute; override;
    procedure VisualSwap(A, B, I, J: Integer);
    procedure Sort(var A: array of Integer); virtual; abstract;
  public
    constructor Create(Box: TPaintBox; var SortArray: TSortArray);
    property  bolTHslowmotion: boolean read Fbolthslowmotion write Setbolthslowmotion;

  end;


procedure SIRegister_TThreadSortForm(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TForm', 'TThreadSortForm') do
  with CL.AddClassN(CL.FindClass('TForm'),'TThreadSortForm') do
  begin
    RegisterProperty('BubbleSortBox', 'TPaintBox', iptrw);
    RegisterProperty('SelectionSortBox', 'TPaintBox', iptrw);
    RegisterProperty('QuickSortBox', 'TPaintBox', iptrw);
    RegisterProperty('Bevel1', 'TBevel', iptrw);
    RegisterProperty('Bevel2', 'TBevel', iptrw);
    RegisterProperty('Bevel3', 'TBevel', iptrw);
    RegisterProperty('StartBtn', 'TButton', iptrw);
    RegisterProperty('Label1', 'TLabel', iptrw);
    RegisterProperty('Label2', 'TLabel', iptrw);
    RegisterProperty('Label3', 'TLabel', iptrw);
    RegisterProperty('BitBtn1slowmotion', 'TBitBtn', iptrw);
    RegisterMethod('Procedure StartBtnClick( Sender : TObject)');
    RegisterMethod('Procedure BubbleSortBoxPaint( Sender : TObject)');
    RegisterMethod('Procedure SelectionSortBoxPaint( Sender : TObject)');
    RegisterMethod('Procedure QuickSortBoxPaint( Sender : TObject)');
    RegisterMethod('Procedure FormCreate( Sender : TObject)');
    RegisterMethod('Procedure FormDestroy( Sender : TObject)');
    RegisterMethod('Procedure FormKeyPress( Sender: TObject; var Key: Char)');
    RegisterMethod('Procedure BitBtn1slowmotionClick( Sender : TObject)');
    RegisterMethod('Procedure ThreadDone( Sender : TObject)');
    RegisterProperty('mouse', 'boolean', iptrw);
  end;
end;




***********************************Thread Class *****************************
  TThread = class
  private
{$IFDEF MSWINDOWS}
    FHandle: THandle;
    FThreadID: THandle;
{$ENDIF}
{$IFDEF LINUX}
    // ** FThreadID is not THandle in Linux **
    FThreadID: Cardinal;
    FCreateSuspendedSem: TSemaphore;
    FInitialSuspendDone: Boolean;
{$ENDIF}
    FCreateSuspended: Boolean;
    FTerminated: Boolean;
    FSuspended: Boolean;
    FFreeOnTerminate: Boolean;
    FFinished: Boolean;
    FReturnValue: Integer;
    FOnTerminate: TNotifyEvent;
    FSynchronize: TSynchronizeRecord;
    FFatalException: TObject;
    procedure CallOnTerminate;
    class procedure Synchronize(ASyncRec: PSynchronizeRecord; QueueEvent: Boolean = False); overload;
{$IFDEF MSWINDOWS}
    function GetPriority: TThreadPriority;
    procedure SetPriority(Value: TThreadPriority);
{$ENDIF}
{$IFDEF LINUX}
    // ** Priority is an Integer value in Linux
    function GetPriority: Integer;
    procedure SetPriority(Value: Integer);
    function GetPolicy: Integer;
    procedure SetPolicy(Value: Integer);
{$ENDIF}
    procedure SetSuspended(Value: Boolean);
  protected
    procedure CheckThreadError(ErrCode: Integer); overload;
    procedure CheckThreadError(Success: Boolean); overload;
    procedure DoTerminate; virtual;
    procedure Execute; virtual; abstract;
    procedure Queue(AMethod: TThreadMethod); overload;
    procedure Synchronize(AMethod: TThreadMethod); overload;
    property ReturnValue: Integer read FReturnValue write FReturnValue;
    property Terminated: Boolean read FTerminated;
  public
    constructor Create(CreateSuspended: Boolean);
    destructor Destroy; override;
    procedure AfterConstruction; override;
    procedure Resume;
    procedure Suspend;
    procedure Terminate;
    function WaitFor: LongWord;
    class procedure Queue(AThread: TThread; AMethod: TThreadMethod); overload;
    class procedure RemoveQueuedEvents(AThread: TThread; AMethod: TThreadMethod);
    class procedure StaticQueue(AThread: TThread; AMethod: TThreadMethod);
    class procedure Synchronize(AThread: TThread; AMethod: TThreadMethod); overload;
    class procedure StaticSynchronize(AThread: TThread; AMethod: TThreadMethod);
    property FatalException: TObject read FFatalException;
    property FreeOnTerminate: Boolean read FFreeOnTerminate write FFreeOnTerminate;
{$IFDEF MSWINDOWS}
    property Handle: THandle read FHandle;
    property Priority: TThreadPriority read GetPriority write SetPriority;
{$ENDIF}
{$IFDEF LINUX}
    // ** Priority is an Integer **
    property Priority: Integer read GetPriority write SetPriority;
    property Policy: Integer read GetPolicy write SetPolicy;
{$ENDIF}
    property Suspended: Boolean read FSuspended write SetSuspended;
{$IFDEF MSWINDOWS}
    property ThreadID: THandle read FThreadID;
{$ENDIF}
{$IFDEF LINUX}
    // ** ThreadId is Cardinal **
    property ThreadID: Cardinal read FThreadID;
{$ENDIF}
    property OnTerminate: TNotifyEvent read FOnTerminate write FOnTerminate;
  end;
  
  
8 Tipps für die richtige Business-Software-Auswahl!

Die Auswahl einer Business Software lässt verschiedene Lösungswege zu, selten gibt es ein klares “Falsch”. Einige abenteuerliche Ansätze die geradewegs und unbeirrbar zu den bekannten Projektschwierigkeiten führen, sollte man aber vermeiden. Unsere 8 Tipps für die Auswahl der Business-Software-Lösung helfen Ihnen, die richtige Lösung sowie den passenden Software-Partner zu finden:

    Ganzes Angebot!
    Gehen Sie von der ganzen Angebotspalette aus und entscheiden Sie sich nicht zu schnell für einen Anbieter.
    Prozesse!
    Analysieren Sie zuerst die Prozesse und definieren Sie dann die funktionale Abdeckung der Anforderungen.
    Zukunft!
    Versuchen Sie auch die Anpassungen des Systems an zukünftige Bedürfnisse abzuschätzen.
    Potenzial des Partners!
    Beurteilen Sie das Potenzial des Systemlieferanten.
    Referenzen!
    Besuchen Sie Referenzkunden mit ähnlichen Anforderungen. Verlassen Sie sich nicht einfach auf Aussagen von Kollegen und Partnern.
    Drum prüfe wer sich bindet?
    Hinter der evaluierten Lösung stehen immer auch Menschen mit denen Sie in den nächsten zehn Jahren zu tun haben. Beziehen Sie daher Aspekte wie «Sympathie und Chemie» in die Überlegungen ein.
    Ressourcen!
    Nehmen Sie sich Zeit! Die Einführung eines ERP-Systems braucht Zeit und das Management muss voll und ganz hinter dem Projekt stehen und die nötigen Ressourcen dazu freigeben.
    Schulung, Schulung, Schulung!
    Und ganz wichtig: Unterschätzen Sie nicht die Anwender-Schulung. Sie ist wichtig und braucht Zeit!

 
http://www.hitekdev.com/delphi/BITMAPANIMATION.html

void draw() 
{
  fill(0, 2);
  rect(0, 0, width, height);
  pct += step;
  if (pct < 1.0) {
    x = beginX + (pct * distX);
    y = beginY + (pow(pct, exponent) * distY);
  }
  fill(255);
  ellipse(x, y, 20, 20);
}

function FindRootNode(ACaption: String; ATreeView: TTreeView): TTreeNode; 
var LCount: Integer; 
begin 
  result := nil; 
  LCount := 0; 
  while (LCount < ATreeView.Items.Count) and (result = nil) do 
  begin 
    if (ATreeView.Items.Item[LCount].Text = ACaption) and (ATreeView.Items.Item[LCount].Parent = nil) then 
      result := ATreeView.Items.Item[LCount]; 
    inc(LCount); 
  end; 
end;

...

var LDestNode: TTreeNode; 
begin 
  LDestNode := FindRootNode('category', TreeView1); 
  if LDestNode <> nil then 
  begin 
    TreeView1.Items.AddChild(LDestNode, 'node1'); 
    TreeView1.Items.AddChild(LDestNode, 'node2'); 
  end; 
end;

Hi all,
>>
>> To help prioritize and design them, I'd like to better understand the 
>> various requests for editor improvements (e.g. auto-complete, better 
>> syntax highlighting).  What are the user experience problems you're 
>> trying to solve?  For who?  (Please be more specific than "making 
>> Arduino more like other IDEs".  If that's the goal, I think we're 
>> better off making it easier to let you use those other IDEs.)
>>
>> Anything that requires heuristic parsing of incomplete / invalid code 
>> (e.g. because you're in the middle of typing it) is probably beyond 
>> the scope of what we can reasonably do (unless there's a great 
>> library or example to draw on).  That is, I don't think we're going 
>> to be able to do things like dynamically parse the user sketch as 
>> it's being typed, extract the names of functions defined in the 
>> sketch, and provide dynamic syntax highlighting / command completion 
>> for calls to those functions elsewhere in the sketch.  On the other 
>> hand, looking for a known string like "digitalWrite(" to appear in 
>> your sketch and dropping down a list of arguments doesn't seem so unrealistic.
>>
>> The overall point is that, for each feature request, we're trying to 
>> balance the degree to which we can improve the user experience with 
>> the feasibility / difficulty of implementation.  Keep that in mind as 
>> we discuss improvements to the IDE.
>>
>> David




_____________________________________________________________
 
Gesellschaft zur Förderung der Software Technologie
 
        Internet of Things

        Viele sehen im Internet of Things vor allem eines: ein gigantisches Potenzial für neue Geschäftsmodelle. Ich denke einfach mal, dass bald die ganze Welt programmierbar sein wird. Jedes EBike, jede Waschmaschine, Kaffeemaschine, jeder Blutdruckmesser oder jede Armbanduhr wird irgendwie vernetzt sein. Geräte werden untereinander als Physical Computing kommunizieren, sich aufeinander abstimmen. Man geht also nicht mehr ins Internet, sondern das Internet ist Teil von uns, Sensoren messen meinen Blutzucker und berechnen so die nächste Krankenkassenprämie. Sensoren und Aktoren lassen sich dann serienmässig in Fahrzeuge, Waren oder Kleider einbauen.



    Es kann auch sein, dass intelligente Gebäude so störanfällig werden, dass der Fahrstuhl des Grauens Wirklichkeit wird.
    Nette Spielereien oder der Anfang einer neuen solargetriebenen Manufakturindustrie inklusive 3D-Drucker und Roboter in der Altersbetreuung. 



   Max bespricht:


       -  REST als Command Protocol

       - Web to Serial Applications
       - Microcontrollers

       -   Aktoren und Sensoren
       - RFIDs sind überall




    Gezeigt wird konkret, wie mit Android ein Arduino Board gesteuert wird.
