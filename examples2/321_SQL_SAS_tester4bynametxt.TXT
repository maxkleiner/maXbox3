//****************ReportTimeDATATester**************************
program DataBase_SQLQuery_ScholzSoft_Excel;

// this is in conjunction with example _28_pas_dataset.txt - 25.11.2012
// in V3.2 you find DBX, SQLExpress for Interbase, Firebird, Oracle 
 //GetShortPathName(PChar(LongName), ShortName, Max_Path);, #locs=893
 //#head:XT max: MAXBOX8: 26.11.2014 09:10:35 C:\maXbook\maxbox3\mX3999\maxbox3\examples\321_SQL_SAS_tester4bynametxt.TXT 

function GetShortPathName(lname, sname: pchar; mpath: longint): bool;
  external 'GetShortPathNameW@kernel32.dll stdcall';

//***********************Configuration Direct*********************************//

Const SCHOLZALIAS =  'SAS';  //'mX3base';
      TEXTOUTPUT  = false;
      EXCELOUT = false;
      USEHEADER = false;
      AFILENAME  = 'ScholzDatasetdata42.txt';
      FILEHEADER  = 'Rec'+#9+'Int'+#9+'FirstName'+#9+'LastName'+#9+'Phone'+#9#9+
                    'Termin'+#9#9+'ProgNr';
      
      Fakturiert = 90;
      Erledigt   = 50;
      Unerledigt = 10;
    
      ABAUFTRAG = '10000';   //SQL Filter
      ASTATUS = '10';        //Status siehe oben

//***********************Configuration Direct*********************************//
      

Const //SQLQuery = 
        // 'Select Int, FirstName, LastName, Phone from Table1';

    {SQLQuery =
    'Select AuftragsNr, KundenNr, Suchbegriff, Status, Termin, Menge, VKTotal, ProgNr '+
    'from Auftrag, AufAtb, Kunde where '+
    'Auftrag.AuftragsNr = AufAtb.AuftragsNr AND AufAtb.KundenNr = Kunde.KundenNr '+
    'AND Status = '+ASTATUS+' AND AuftragsNr > '+ABAUFTRAG+' ORDER BY KundenNr, Termin, Menge';} 
 
    //SQLQuery = 'select * from ID.DB';
    //SQLQuery = 'select * from Passwort_.DB';
 
    //SQLQuery = 'select * from Kasse.DB';
    
   //SQLQuery = 'select * from AB.DB where Gedruckt=false';
   SQLQuery = 'select * from PrParams.DB';
    
      //SQLQueryExec = 'UPDATE ID2013 SET Stationen = 13';
    //SQLQuery = 'select * from ID2013';
    
  //  ALTER TABLE TOSCAK.SHOPSITZUNG
//ADD (xxx VARCHAR2(15 BYTE));

//-- 

    
   // SQLQueryExec = 'UPDATE Maschine SET Einheit = ''min22'' WHERE Nr=''505''';
    //SQLQueryExec = 'UPDATE Maschine SET Einheit = ''min22'' WHERE Nr=''505''';
   
    
    //SQLQueryExec = 'DELETE FROM maschine WHERE Nr=''651''';
    
    //SQLQueryExec = 'INSERT INTO Maschine (Nr,DL,Einheit,EK) '+ 
      //                'VALUES (''651'',''maxmachine'',''min'',''120.44'')';

    //SQLQueryExec = 'INSERT INTO PrParams (AngTextbreite) '+ 
      //               'VALUES (''65'')';

    
    
    {'Select AuftragsNr, KundenNr, Suchbegriff, Status, Termin, Menge, VKTotal, ProgNr '+
    'from Auftrag, AufAtb, Kunde where '+
    'Auftrag.AuftragsNr = AufAtb.AuftragsNr AND AufAtb.KundenNr = Kunde.KundenNr '+
    'AND Status = '+ASTATUS+' AND AuftragsNr > '+ABAUFTRAG+' ORDER BY KundenNr, Termin, Menge';} 

{const SQLQuery = 'Select AuftragsNr, Termin, ReNr, KundenNr, ProgNr, Text1, Text2 FROM Auftrag, Aufpos where '+
                  'Auftrag.AuftragsNr = Aufpos.AuftragsNr AND AuftragsNr > 42543 '+
                  'ORDER BY Termin,AuftragsNr';} 
///const SQLQuery = 'Select AuftragsNr, ReNr, Text1, Text2 FROM Auftrag, Aufpos where '+
   //               'Auftrag.AuftragsNr = Aufpos.AuftragsNr AND AuftragsNr > 42543'; 
//const SQLQuery = 'Select count(*) from Auftrag'; 
//const SQLQuery = 'Select AuftragsNr, ReNr, Text1, Text2 FROM Auftrag, Aufpos where '+
  //                'Auftrag.AuftragsNr = Aufpos.AuftragsNr AND AuftragsNr > 212000'; 
//const SQLQuery = 'select * from customer where company like "%SCUBA%"''';    
//const SQLQuery = 'Select Fertig, AuftragsNr, LeistungsNr from ZeitBTmp'; 
//const SQLQuery = 'Select Fertig, BeginnDatum, AuftragsNr, LeistungsNr from ZeitBtmp where AuftragsNr > 200000'; 

(*with SqlSearchAB do begin
       Close;
       Sql.Clear;
       Sql.Add('Select AbNr, ATBNr, Produkt, Menge, Einheit, EP, Vk, Rabatt, Rabattbetrag, VkTotal, Termin from AbATB');
       Sql.Add(format('where AuftragsNr=%d',[aAuftragsNr]));
       Open;
  end;*)
  
  type
   TRGB24 = record
      b, g, r : Byte;
   end;
  

var
   dbMain: TDatabase;   //@global
   afix: TFixedVector;
   asyn: TStFloat; //TAcson //TNeuralNet //TNeuron //TSynapse;
   
function RGB24ToColor(const rgb24 : TRGB24) : TColor;
begin
   Result:=RGB(rgb24.r, rgb24.g, rgb24.b); 
   //Clamp
   //CopyRightL
   //AnalyzeExpr
   //ssplus //((TStToken
   //CreateGoal
   //Number
   //strip
end;

function LerpRGB24(const c1, c2 : TRGB24; f : Single) : TRGB24;
var
   invf : Single;
begin
   invf:=1-f;
   Result.b:=Round(c1.b*invf+c2.b*f);
   Result.g:=Round(c1.g*invf+c2.g*f);
   Result.r:=Round(c1.r*invf+c2.r*f);
end;

function SizeToString(size : Int64; const unitStr : String) : String;
begin
   if size<1024*1024 then
      Result:=Format('%.1f k', [size*(1/1024)])
   else if size<1024*1024*1024 then
      Result:=Format('%.1f M', [size*(1/(1024*1024))])
   else Result:=Format('%.1f G', [size*(1/(1024*1024*1024))]);
   Result:=Result+unitStr;
end;


function ReadUntil(const ReadFrom, len: Integer; const C: Char; s: string): Integer;
  var
    j: Integer;
    //s: string;
  begin
    for j := ReadFrom to Len do
      if (s[j] = C) then begin
        Result := j;
        Exit;
      end;
    Result := Len+1;
  end;
 
function StripTags2(const S: string): string;
var
  Len: Integer;
 
  {function ReadUntil(const ReadFrom: Integer; const C: Char): Integer;
  var
    j: Integer;
  begin
    for j := ReadFrom to Len do
      if (s[j] = C) then
      begin
        Result := j;
        Exit;
      end;
    Result := Len+1;
  end;}
 
var
  i, APos: Integer;
begin
  Len := Length(S);
  i := 0;
  Result := '';
  while (i <= Len) do begin
    Inc(i);
    APos := ReadUntil(i, len, '<', s);
    Result := Result + Copy(S, i, APos-i);
    i := ReadUntil(APos+1,len, '>',s);
  end;
end;

//origin
(*function StripTags(const S: string): string;
var
  Len: Integer;
 
  {function ReadUntil(const ReadFrom: Integer; const C: Char): Integer;
  var
    j: Integer;
  begin
    for j := ReadFrom to Len do
      if (s[j] = C) then
      begin
        Result := j;
        Exit;
      end;
    Result := Len+1;
  end;}
 
var
  i, APos: Integer;
begin
  Len := Length(S);
  i := 0;
  Result := '';
  while (i <= Len) do begin
    Inc(i);
    APos := ReadUntil(i, '<');
    Result := Result + Copy(S, i, APos-i);
    i := ReadUntil(APos+1, '>');
  end;
end;*)

{Parameters:

S: A string value containing the HTML / XML type tags that are to be removed.
Return Value:

This function will return a string value conatining the value of S with any tags removed.
Example:

Delphi/Pascal
procedure TForm1.Button1Click(Sender: TObject); var s: String; begin s := StripTags('<p>This is text.<br/>This is line 2</p>'); ShowMessage(s); // will display 'This is text.This is line 2' end;
}

FUNCTION Strip(const SubString: String; MainString: String): String;
{ =================================================================== }
VAR i,j: Integer;

BEGIN{Strip}
    j := Ord(SubString[0]);
    If j <> 0 Then Begin
       i := Pos(SubString,MainString);
       While i <> 0 Do Begin
           Delete(MainString, i, j);
           i := Pos(SubString,MainString);
       End;
   End;
   result:= MainString;
END{Strip};


FUNCTION StripAny(const SubString: String; MainString: String): String;
{ =================================================================== }
VAR i,j: Integer;
      s: char;
BEGIN{Strip}
    j := Ord(SubString[0]);
    While j > 0 Do Begin
       s := SubString[j];
       i := Pos(s,MainString);
       While i <> 0 Do Begin
           Delete(MainString,i,1);
           i := Pos(s,MainString);
       End;
       Dec(j);
   End;
   result:= MainString;
END{Strip};


	
{procedure TForm1.Button1Click(Sender: TObject);
var
  s: String;
begin
  s := StripTags('<p>This is text.<br/>This is line 2</p>');
  ShowMessage(s);   // will display 'This is text.This is line 2'
end;}

   


function TFormMain_GetTime:TDateTime;
begin
  result:= StrToTime(FormatDateTime('h:n',time)); // Sekunden abschneiden
end;


function GetQuery(SQLCommand: string; aQuery: TQuery): TFields;
begin
  aQuery.SQL.Text:= SQLCommand;
  aQuery.Open;
  aQuery.Active:= true;
  result:= aQuery.Fields;
end; 


procedure DoExecQuery2(aDB: TDataBase);
var dQuery: TQuery;
begin
   dQuery:= TQuery.create(self); 
   with dQuery do begin
   DatabaseName:= aDB.DataBaseName;
     try
        writeln('');
        writeln('exec the query for DB starts: ');
        SQL.Clear;
        SQL.Text:= SQLQuery;
        writeln('exec sql ready to run: ');
        ExecSQL;
        Writeln(inttostr(RecordCount)+' Records found: ')
       finally
         Close;
         Free;
         //CloseDataBase(aDB)
       end;
    end   
end; 


procedure DoQuery2(aDB: TDataBase; vafilename: shortstring; fileout: boolean);
var i,z: integer;
    dQuery: TQuery;
    reslist: TStringlist;
    tmps, fhead: shortstring;
begin
   dQuery:= TQuery.create(self); 
   reslist:= TStringList.create;
   tmps:= '';
   with dQuery do begin
   DatabaseName:= aDB.DataBaseName;
     try
        writeln('');
        writeln('search for DB starts: ');
        SQL.Clear;
        SQL.Text:= SQLQuery;
        Open;
        Writeln(inttostr(RecordCount)+' Records found: ')
        if fileout then begin
        if USEHEADER then
          reslist.Add(FILEHEADER) else begin
            for i:= 0 to FieldDefs.Count-1 do
            fhead:= fhead + fieldDefs[i].name+ #9': ';
            // Field:= Table1.FieldDefs[i].CreateField(Table1,NIL,'',False);
            reslist.Add(fhead);
          end;     
        reslist.Add(S_RepeatChar(160,'-'));
        for i:= 0 to Recordcount - 1 do begin
          for z:= 0 to Fieldcount - 1 do  
            tmps:= tmps + Fields[z].asString+#9;
          reslist.Add(inttoStr(i+1)+':'+#9+tmps);
          tmps:='';
          Next;
        //Writeln(inttostr(i)+' Records in file: ')
        end 
        end else
        for i:= 0 to Recordcount - 1 do begin   //add tab
          write(inttoStr(i)+' ')
          for z:= 0 to Fieldcount - 1 do 
            Write((Fields[z].asString)+' ');
          writeln('');
          Next;  
        end;
        writeln('');
        try
          //showmessage(exepath+afilename);
          reslist.SaveToFile(vafilename);
        except
          showmessage('file '+vafilename+' not saved error');
        end;  
       //ExecSQL;
       finally
         reslist.Free;
         Close;
         Free;
         //CloseDataBase(aDB)
       end;
    end   
end; 


procedure DoQuery2Excel(aDB: TDataBase; afilename: shortstring; fileout: boolean);
var i,z: integer;
    dQuery: TQuery;
    reslist: TStringlist;
    tmps: shortstring;
    mySt: TStringGrid;
begin
   dQuery:= TQuery.create(self); 
   reslist:= TStringList.create;
   tmps:= '';
   mySt:= TStringGrid.Create(self)
   afilename:= ChangeFileExt(extractFileName(afilename), '.xls');
   with dQuery do begin
     DatabaseName:= aDB.DataBaseName;
     try
       writeln('');
       writeln('search for excel DB starts: ');
       SQL.Clear;
       SQL.Text:= SQLQuery;
       Open;
       Writeln(inttostr(RecordCount)+' Records found: ')
       with mySt do begin
         rowcount:= Recordcount+2;
         colcount:= FieldCount;
        //DefaultColWidth:= 20;
       end;
       //dataset
       //ExportDataSetToExcel(dquery, NIL)
       if fileout then begin
        //reslist.Add(FILEHEADER); to do in excel
        //reslist.Add(S_RepeatChar(160,'-'));
         for i:= 0 to Recordcount - 1 do begin
           for z:= 0 to Fieldcount - 1 do 
             mySt.Cells[z,i]:= Fields[z].asString;
           Next;
         end 
       end else
         for i:= 0 to Recordcount - 1 do begin   //add tab
           write(inttoStr(i)+' ')
           for z:= 0 to Fieldcount - 1 do 
             Write((Fields[z].asString)+' ');
           writeln('');
           Next;  
         end;
         writeln('');
         myst.Cells[0,17]:= '=SUMME(A1:A16)'; 
       if SaveAsExcelFile(mySt, 'maxcel_map',Exepath+ afilename,true)
          then Msg('maXcel export success');
       SearchAndOpenDoc(ExePath+afilename)
       //ExecSQL;
     ExportDataSetToExcel(dquery, NIL)
     
     finally
       reslist.Free;
       myst.Free;
       Close;
       Free;
       //CloseDataBase(aDB)
     end;
   end   
end; 

procedure DoQueryByName3(aDB: TDataBase; vafilename: shortstring);
var i,z: integer;
    dQuery: TQuery;
    reslist: TStringlist;
    tmps, fhead: shortstring;
begin
   dQuery:= TQuery.create(self); 
   tmps:= '';
   with dQuery do begin
   DatabaseName:= aDB.DataBaseName;
     try
        writeln('');
        writeln('search for DB starts: ');
        SQL.Clear;
        SQL.Text:= SQLQuery;
        Open;
        Writeln(inttostr(RecordCount)+' Records found: ')
        for i:= 0 to Recordcount - 1 do begin   //add tab
          write(inttoStr(i)+' ')
          for z:= 0 to Fieldcount - 1 do 
            Write((Fields[z].asString)+' ');
          writeln('');
          Next;  
        end;
        writeln('');
       //ExecSQL;
       finally
         Close;
         Free;
         //CloseDataBase(aDB)
       end;
    end   
end; 

Procedure SetADOSETAccess2byName;
var 
  adoquery: TAdoQuery; //TAdoDataSet;
  i, z: integer;
  adoCom: TADoCommand;
  ad: TDataType;
  //arcset: _Recordset;
begin  
  adoquery:= TAdoQuery.Create(self);
  if adoquery.Active then adoquery.close;

  with adoquery do begin
    cachesize:= 500;
    //SQL.Clear;
    //adocom.CommandText := 'update rooms set roomname = :p1, description = :p2 where RoomNumber = :p3';
    //ADOCom.Parameters[0].value := 'dbedit1.Text';
    //adoCom.recordset
    //execute1;
    //commandtext:= 'select count(*)'
    {commandtext:= 'INSERT INTO Table1 (FirstName, LastName, Phone)'+
                        'VALUES (''Max'', ''Box545'', ''031-333 77 88'')';}
    //commandText:= 'SELECT * FROM Table1';
    //SQL.Clear;
    SQL.Add('SELECT Firstname, Phone FROM Table1');
    connectionString:= 'Provider=MSDASQL;DSN=mx3base;Uid=sa;Pwd=admin';
    //Parameters[0].Value:=CurrentRoom;
  //try
    Open;
    //<Field 1>
     //writeln(fieldbyname('Phone').asString);
     //FieldByName('FirstName').DataType;
     //writeln(fieldbyname('<Field 1>').asString);
    
    //Execute;
  //except   
    //Writeln(intToStr(Recordcount)+' records found')
  //end;
  
  //http://www.delphipages.com/forum/showthread.php?t=129825
  
  for i:= 0 to Recordcount - 1 do begin
    for z:= 0 to Fieldcount - 1 do begin 
         ad:= Fields[z].DataType;
         //Writeln(inttostr(FieldDefs[z].datatype));
         //ad.asstring;
         case ad of
           ftWideString: write('wide streng: ');
           ftAutoInc: write('ft auto inc: ');
         end;  
    
      //Write((Fields[z].DataType));
      Write((Fields[z].asString)+'  ');
      //writeln(fieldbyname('Phone').asString);
     end;
    Writeln(#13#10) 
    Next;
  end;
    Close;
    Free;        
  end;
end;

//http://edn.embarcadero.com/article/10270

 const selectstr = 'SELECT * FROM Table1';
      execstr = 'INSERT INTO Table1 (FirstName, LastName, Phone)'+
                        'VALUES (''MaxNewNew'', ''Box545'', ''031-333 77 88'')';
    
      DSNStr = 'Provider=MSDASQL;DSN=mx3base;Uid=sa;Pwd=admin';
 

procedure TForm1_VariantBtnClick(Sender: TObject);
var
  RecordSet: OleVariant;
  Y, i: Integer;
begin
  //OleCheck(CoCreateInstance(CLASS_RecordSet, nil, 
    //CLSCTX_ALL, IID__RecordSet, RecordSet));
  // Create an empty recordset object
  RecordSet:= CreateOleObject('ADODB.Recordset');
  // Fill recordset
  RecordSet.Open(SELECTSTR, DSNSTR);
  // Display data
  Y := 1;
  repeat
    for i := 0 to RecordSet.Fields.count-1 {3} do begin
      //StringGrid1.Cells[i, Y] :=  RecordSet.Fields[i].Value;
       write((RecordSet.Fields[i].Value));
       write(' ')
    end;
    RecordSet.Move(1);
    Writeln(#13#10)
    Inc(Y);
  until RecordSet.EOF;
end;


//http://edn.embarcadero.com/article/10270

const
 adCmdText = $00000001;
 adExecuteNoRecords = $00000080;

procedure RunScriptADOOLE();
var
 tString: TStringList;
 ADOCommand: Variant;
 ADORecordset: Variant;
 ADOConnection: Variant;  
 i, len: Integer;
 strToQuery, str: String;
begin
 try
 ADOConnection:= CreateOleObject('ADODB.Connection'); 
 ADOConnection.ConnectionString :=  DSNStr;
  (*'Provider=SQLOLEDB;' +               // provider
  'Data Source=(local)\SQL2000;' +   // server name
  'Initial Catalog=databasename;' +       // default database
  'User Id=userId;' +                // user name
  'Password=password;';                   // password *)
 ADOConnection.Open;
 try
  ADOCommand:= CreateOleObject('ADODB.Command');
  ADOCommand.ActiveConnection:= ADOConnection;
   tString:= TStringList.Create;
   //tString.LoadFromFile('C:\sqlscript.sql');
   len:= tString.Count;
   strToQuery:='';
   //for i:=0 to len-1 do begin
    //str := trim(tString[i]);          
    //if POS('go', lowercase(str)) = 1  then begin
     //If GO is found run the script added in to strToQuery since last GO
     //ADOCommand.CommandText := strToQuery;    
     ADOCommand.CommandText := execStr;      
     ADOCommand.Execute(NULL, NULL, adCmdText or adExecuteNoRecords);
     strToQuery:='';        //Clear the string to start adding till next GO
     //end else strToQuery:= strToQuery +#13#10+ str;  //Add script to strToQuery
    //end;
    //ADOCommand.CommandText := strToQuery;                           
    //ADOCommand.Execute(NULL, NULL, adCmdText or adExecuteNoRecords);
 finally
  ADOConnection.Close;
  tString.Free;
 end;
 except
    MsgBox('GetExceptionMessage', 'mbError', MB_OK);
 end;
end;


//http://edn.embarcadero.com/article/10270

Const
  adCmdTxt = $00000001;
  adExecNoRecords = $00000080;

procedure RunScriptADOOLE_3();
var
 ADOCommand: Variant;
 ADORecordset: Variant;
 ADOConnection: Variant; 
 exeStr, DSNString: string; 
begin
  exeStr:= 'INSERT INTO Table1 (FirstName, LastName, Phone)'+
                     'VALUES (''MaxNewNew'', ''Box545'', ''031-333 77 88'')';
  DSNString:= 'Provider=MSDASQL;DSN=mx3base;Uid=sa;Pwd=admin';
 try
  ADOConnection:= CreateOleObject('ADODB.Connection'); 
  ADOConnection.ConnectionString:=  DSNString;
  ADOConnection.Open;
 try
   ADOCommand:= CreateOleObject('ADODB.Command');
   ADOCommand.ActiveConnection:= ADOConnection;
     ADOCommand.CommandText:= exeStr;      
     ADOCommand.Execute(NULL, NULL, adCmdTxt or adExecNoRecords);
 finally
   ADOConnection.Close;
 end;
 except
    MsgBox('GetExceptionMessage_ADOOLE', 'mbError', MB_OK);
 end;
end;

function LoadScriptFromFile(const FileName: string; out CommandList: TStrings): Integer;
var
  I: Integer;
  SQLCommand: string;
  ScriptFile: TStringList;
begin
  Result := 0;
  ScriptFile := TStringList.Create;
  try
    SQLCommand := '';
    ScriptFile.LoadFromFile(FileName);

    for I := 0 to ScriptFile.Count - 1 do
    begin
      if Pos('go', LowerCase(Trim(ScriptFile[I]))) = 1 then
      begin
        Result := Result + 1;
        CommandList.Add(SQLCommand);
        SQLCommand := '';
      end
      else
        SQLCommand := SQLCommand + ScriptFile[I] + #13#10;
    end;

    //EDIT: If there is no GO syntax present int the file AND
    //To add the script after the last GO - Govs
    CommandList.Add(SQLCommand);
    Result:= Result + 1;
  finally
    ScriptFile.Free;
  end;
end;


procedure BDEDataBaseConnectQuery(aAlias: shortstring;
                                     afilen: shortstring; atextout: boolean);
  var aParams, aTblNames: TStringList;
      aSession: TSession;
      //dbMain: TDatabase;
      BDEAlias: string;
      i: integer;
begin 
  //create alias params list 
  AParams:= TStringList.Create;  
  aTblNames:= TStringList.Create; 
  //BDEAlias:= 'DBDEMOS';
  BDEAlias:= aAlias; 
  //create a session to get alias parameters  
  ASession:= TSession.Create(NIL);  
  ASession.SessionName:= 'Session8'; 
  //ASession.PrivateDir := 'c:\xxxtmp'; 
  //ASession.NetFileDir:= getnetpath;
  //ASession.SaveConfigFile;
  //dbMain:= TDatabase.Create(NIL);  
  try  //except
    ASession.GetAliasParams(BDEAlias, AParams);
  try  
    Writeln('***********DB Parameters************')
    for i:= 0 to aparams.count -1 do 
      writeln(aParams[i]);
      //connect to database 
    with dbMain do begin  
      Params.Assign(AParams);  
      dbMain:= ASession.OpenDatabase(BDEAlias);
      Writeln('Database is: '+dbMain.DataBaseName)
      KeepConnection:= True;
      GetTableNames(aTblNames, true)
      {for i:= 0 to atblNames.count -1 do 
        Writeln(atblnames[i]);}
      //doQuery2(dbMain, afilen, atextout);    //true to fileout //change switch
      doQuerybyname3(dbMain, afilen);
      
      if EXCELOUT then 
        DoQuery2Excel(dbMain, afilen, atextout);
      //doExecQuery2(dbmain);
    end;
  finally  
    DBMain.Free;
    ASession.Free;  
    AParams.Free;
    aTblNames.Free;
  end;
  except
    writeln('BDE connect or execute exception');
    msgBig('BDE connect or execute exception');
    writeln('');
    //ee.raise;
  end;  
end;
  

function BinToInt(Value: string): Integer;
var
  i, iValueSize: Integer;
begin
  Result:= 0;
  iValueSize := Length(Value);
  for i:= iValueSize downto 1 do
    if Value[i] = '1' then Result := Result + (1 shl (iValueSize - i));
end; 

procedure getSystemInformation;
begin
   Writeln('maXbox Version: '+MBVER);
   Writeln('maXbox Version: '+Version);
   //from unit uPSI_JclSysInfo;
   Writeln('Function GetCommonFilesFolder :'+GetCommonFilesFolder);
   Writeln('Function GetCurrentFolder :'+GetCurrentFolder);
   Writeln('Function GetProgramFilesFolder :'+GetProgramFilesFolder);
   Writeln('Function GetWindowsFolder :'+GetWindowsFolder);
   Writeln('Function GetWindowsSystemFolder :'+GetWindowsSystemFolder);
   Writeln('Function GetWindowsTempFolder :'+GetWindowsTempFolder);
   Writeln('Function GetDesktopFolder :'+GetDesktopFolder);
   Writeln('Function GetProgramsFolder :'+GetProgramsFolder);
   Writeln('Function GetPersonalFolder :'+GetPersonalFolder);
   Writeln('Function GetFavoritesFolder :'+GetFavoritesFolder);
   Writeln('Function GetStartupFolder :'+GetStartupFolder);
   Writeln('Function GetRecentFolder :'+GetRecentFolder);
   Writeln('Function GetSendToFolder :'+GetSendToFolder);
   Writeln('Function GetStartmenuFolder :'+GetStartmenuFolder);
   Writeln('Function GetDesktopDirectoryFolder :'+GetDesktopDirectoryFolder);
   Writeln('Function GetNethoodFolder :'+GetNethoodFolder);
   Writeln('Function GetFontsFolder :'+GetFontsFolder);
   Writeln('Function GetCommonStartmenuFolder :'+GetCommonStartmenuFolder);
   Writeln('Function GetCommonProgramsFolder :'+GetCommonProgramsFolder);
   Writeln('Function GetCommonStartupFolder :'+GetCommonStartupFolder);
   Writeln('Function GetCommonDesktopdirectoryFolder:'+GetCommonDesktopdirectoryFolder);
   Writeln('Function GetCommonAppdataFolder :'+GetCommonAppdataFolder);
   Writeln('Function GetAppdataFolder :'+GetAppdataFolder);                     
   Writeln('Function GetPrinthoodFolder :'+GetPrinthoodFolder);
   Writeln('Function GetCommonFavoritesFolder :'+GetCommonFavoritesFolder);
   Writeln('Function GetTemplatesFolder :'+GetTemplatesFolder);
   Writeln('Function GetInternetCacheFolder :'+GetInternetCacheFolder);
   Writeln('Function GetCookiesFolder :'+GetCookiesFolder);
   Writeln('Function GetHistoryFolder :'+GetHistoryFolder);
   //Writeln('Function GetAPMLineStatus : TAPMLineStatus;
   Writeln('Function GetAPMBatteryLifePercent:'+InttoStr(GetAPMBatteryLifePercent));
   Writeln('Function GetVolumeName(const Drive : string) : '+GetVolumeName('C'));
   Writeln('Function GetVolumeSerialNumber :'+GetVolumeSerialNumber('C'));
   Writeln('Function GetVolumeFileSystem  :'+GetVolumeFileSystem('C'));
   //Function GetIPAddress( const HostName : string) : string;
   Writeln('Function GetLocalComputerName :'+GetLocalComputerName);
   Writeln('Function GetLocalUserName :'+GetLocalUserName);
   //Function GetUserDomainName( const CurUser : string) : string;
   Writeln('Function GetDomainName :'+GetDomainName);
   Writeln('Function GetRegisteredCompany :'+GetRegisteredCompany);
   Writeln('Function GetRegisteredOwner :'+GetRegisteredOwner);
   Writeln('Function GetBIOSName :'+GetBIOSName);
   Writeln('Function GetBIOSCopyright :'+GetBIOSCopyright);
   Writeln('Function GetBIOSExtendedInfo :'+GetBIOSExtendedInfo);
   Writeln('Function GetMaxAppAddress :'+IntToStr(GetMaxAppAddress));
   Writeln('Function GetMinAppAddress :'+IntToStr(GetMinAppAddress));
   Writeln('Function GetMemoryLoad :'+IntToStr(GetMemoryLoad));
   Writeln('Function GetSwapFileSize :'+IntToStr(GetSwapFileSize));
   Writeln('Function GetSwapFileUsage :'+InttoStr(GetSwapFileUsage));
   Writeln('Function GetTotalPhysicalMemory :'+IntToStr(GetTotalPhysicalMemory));
   Writeln('Function GetFreePhysicalMemory :'+IntToStr(GetFreePhysicalMemory));
   Writeln('Function GetTotalPageFileMemory :'+IntToStr(GetTotalPageFileMemory));
   Writeln('Function GetFreePageFileMemory :'+InttoStr(GetFreePageFileMemory));
   Writeln('Function GetTotalVirtualMemory :'+InttoStr(GetTotalVirtualMemory));
   Writeln('Function GetFreeVirtualMemory :'+InttoStr(GetFreeVirtualMemory));
   Writeln('Function GetShellProcessName :'+GetShellProcessName);
   //Function GetShellProcessHandle : THandle;
   //Function GetWindowsVersion : TWindowsVersion;
   //Function NtProductType : TNtProductType;
   Writeln('Function GetWindowsVersionString :'+GetWindowsVersionString);
   Writeln('Function NtProductTypeString :'+NtProductTypeString);
   Writeln('Function IsAdministrator :'+BoolToStr(IsAdministrator, True));
end;


var 
   mylst: TStringlist;
   i: integer;
   myregxs: RegExprString;
       
begin
  //maxform1.ShellStyle1click(self)
  //  maxform1.Console1Click(self)
  //maxform1.Decompile1Click(self)
 {try
  dbMain:= TDatabase.Create(self);  
  BDEDataBaseConnectQuery(SCHOLZALIAS, ExePath+AFILENAME, textoutput); //alias to db, text out
  //DBMain.Free;
  //CloseDataBase(aDB)
 except
   writeln('BDE Error')
   msgBig('BDE Error in query');
 end; } 
 
 SetADOSETAccess2byName;
 
 //TForm1_VariantBtnClick(self)
 
  //dbMain.Close;
  
  if TEXTOUTPUT then
  SearchandOpenFile(ExePath+AFILENAME);
  mylst:= TStringlist.create;
  with TSession.Create(NIL) do try
    SessionName:= 'Mars3'
    getAliasNames(mylst);
    Writeln('BDE / DB Alias List:  ******************************');
    for i:= 1 to mylst.count-1 do
      write(mylst[i]+' ');
    finally
      Free;
      mylst.Free; 
    end;      
  Writeln(' ');
  Writeln('BDE/DB Parameters: ******************************');
  Writeln('BDE Directory '+GetBdeDirectory);
  writeln('DB Alias Path '+GetAliasPath(SCHOLZALIAS));
  writeln('Temp File Path'+getTempDir)
  Writeln('*************************************************');
  //getSystemInformation;
  //GetAliasDriverName('SAS')
  
    //ExecuteShell('cmd','/c  systeminfo > systeminfo_scholz.txt')
    //SearchAndOpenFile('systeminfo_scholz.txt')

  writeln(timetoStr(TFormMain_GetTime))
  writeln(timeToStr(time))
  
//  function ExecRegExpr (const ARegExpr, AInputStr : RegExprString) : boolean;
// true if string AInputString match regular expression ARegExpr
// ! will raise exeption if syntax errors in ARegExpr
   Writeln(ReplaceRegExpr ('({-i}block|var)\s*\(\s*([^ ]*)\s*\)\s*',
                          'BLOCK( test1)', 'def "$1" value "$2"', True))
                          
   //RunScriptADOOLE_3;                       

  sr:= StripTags2('<p>This is text.<br/>This is line 2</p>');
  //ShowMessage(s);   // will display 'This is text.This is line 2'
  writeln(sr);   // will display 'This is text.This is line 2'
  Writeln(ReplaceRegExpr ('([</pbr>])*',
                          '<p>This is text.<br/>This is line 2</p>','', True))
 
End.


function ReplaceRegExpr (const ARegExpr, AInputStr, AReplaceStr : RegExprString;
      AUseSubstitution : boolean{$IFDEF D4_}= False{$ENDIF}) : RegExprString; //###0.947
// Returns AInputStr with r.e. occurencies replaced by AReplaceStr
// If AUseSubstitution is true, then AReplaceStr will be used
// as template for Substitution methods.
// For example:
//  ReplaceRegExpr ('({-i}block|var)\s*\(\s*([^ ]*)\s*\)\s*',
//   'BLOCK( test1)', 'def "$1" value "$2"', True)
//  will return:  def 'BLOCK' value 'test1'
//  ReplaceRegExpr ('({-i}block|var)\s*\(\s*([^ ]*)\s*\)\s*',
//   'BLOCK( test1)', 'def "$1" value "$2"')
//   will return:  def "$1" value "$2"

beleg.rtm ist hauptvorlage

Exception: An error occurred while attempting to initialize the Borland Database Engine (error $2A04) at 0.569

$2A04 (10756) = Operation not applicable.
DBIO will not start: BDE Error $2A04


Full error:
  CRITICAL (Work) An error occurred while attempting 
  to initialize the Borland Database Engine (error $2A04)

Issue:
This error indicates a core problem with BDE configuration.


Resolution:

1) Close ALL application software, stop all OmniRush modules including
   Launcher
2) Open the BDE Administrator
3) Go to the Configuration | System | INIT area
4) Check the Default Driver setting. The recommended setting
   (for ALL systems) is DBASE
5) Go to the Configuration | Drivers | Native | Paradox area
6) Check the NET DIR setting. This should be set to a LOCAL
   drive and a simple directory that exists. For example, check
   if you have a C:\TEMP\ directory. If not, create one and grant
   all users full access to it.
   Then set NET DIR to c:\temp\
7) We advise that the PC now be rebooted.
8) Check for proper operation.



Re:Getting ERROR: "to initialize the Borland Database Engine (error $210D)"
The errors are "shared memory conflict" and "insufficient memory to
complete this operation" respectively.
I assume that "several Delphi 7's running" means several programs
created with Delphi7 not several instances of the Delphi 7 IDE. You
need to change the SharedMemLocation and SharedMemSize in the BDE
Administrator. Try 0x5BDE and 4096. If that does not work try some of
the other locations suggested in the on-line help.
--

  
  

procedure TFormMain.FormKeyPress(Sender: TObject; var Key: Char);
var i,n:integer;
begin
  if key=#13
  then begin c2:=c1; c1:=''; end // Barcode ist vollständig eingegeben
  else begin c1:=concat(c1,key); c2:=''; end; // Barcode wird eingelesen
  key:=#0;

  if c2<>'' then begin
     LabelInfo.Caption:='';

     // eventuelle vorherige Tatstauranschläge löschen
     i:=pos('KOMMT',c2); if (i>1) then c2:=copy(c2,i,5);
     i:=pos('GEHT',c2);  if (i>1) then c2:=copy(c2,i,4);
     i:=pos('F01',c2);  if (i>1) then c2:=copy(c2,i,3);
     i:=pos('F12',c2);  if (i>1) then c2:=copy(c2,i,3);
     i:=pos('PERS',c2);  if (i>1) then c2:=copy(c2,i,12); // Personalkarte hat nur 12 Stellen
//     if length(c2)>13 then c2:=copy(c2,length(c2)-13+1,13);
     if length(c2)>14 then c2:=copy(c2,length(c2)-14+1,14);

     n:=length(c2);
     if      c2='KOMMT' then CodeTyp:=cKommt
     else if c2='GEHT' then CodeTyp:=cGeht
     else if c2='F01' then CodeTyp:=cF1
     else if c2='F12' then CodeTyp:=cF12
     else if pos('PERS',c2)=1 then CodeTyp:=cPersonalNr
//     else if pos('  OK',c2)=10 then CodeTyp:=cAtbOk
     else if pos('  OK',c2)=n-3 then CodeTyp:=cAtbOk
//     else if length(c2)=13 then CodeTyp:=cAuftrag
     else if (n=13) or (n=14) then CodeTyp:=cAuftrag
     else SetError(zErrorReadScan);
     CheckCode;
  end;
end;

F12
F01
201206301L999
201206301L010
201206301M804
201206301M801
201206301M802
201206301M803

SMS Error - Directory is controlled by other .NET file.
Error Message
Directory is controlled by other .NET file.
Directory: \\ComputerName\CYRIOUS$\SMS\
File: \\Computername\CYRIOUS$\SMS\DATA\PDOXUSRS.LCK

Explanation of Error
The BDE (Borland Database Engine) utilizes the PDOXUSRS.NET, PARADOX.LCK, and PDOXUSRS.LCK files to lock the database tables for reading and writing. In order to maintain file integrity, the path in which the database tables are accessed must be the same, when they are not the same you may receive errors alerting you to this problem.

This error can also keep you from accessing certain SMS Utilities such as DBRebuild, DBBrowser, GenImp, IDRepair, ProdExp, and ProdImp.

Severity
High. Normally new users can't login to SMS until this resolved.

Possible Root Cause(s)

    Power fluctuation. If the BDE is not properly shut down, it may not clear these locks.
    Network connection loss. If the remote client is not properly shut down, it may not clear these locks or may only clear one of them.
    BDE Configuration. The BDE LOCALSHARE setting must be set to TRUE or it will not attempt to maintain lock integrity.
    
    
procedure AlterTable(NewLocaleID: Integer=LOCALE_ANSI_STD;
       NewUserMajorVersion: Word=1; NewUserMinorVersion: Word=0;
       NewEncrypted: Boolean=False; const NewPassword: String='';
       const NewDescription: String='';
       NewIndexPageSize: Integer=DEFAULT_PAGE_SIZE;
       NewBlobBlockSize: Integer=DEFAULT_BLOCK_SIZE;
       NewLastAutoIncValue: Integer=-1;
       const NewTextIndexFields: String='';
       NewTextIndexStopWords: TStrings=nil;
       const NewTextIndexSpaceChars: String='';
       const NewTextIndexIncludeChars: String='';
       SuppressBackups: Boolean=False)


Usage

Call the AlterTable method to alter the structure of a table using the field definitions and index definitions specified in the FieldDefs and IndexDefs properties, respectively.

The NewLocaleID parameter specifies the new locale ID for the table. If this parameter is 0, then the table will use the default locale of "ANSI Standard".

The NewUserMajorVersion and NewUserMinorVersion parameters specify the new user-defined major and minor version numbers for the table.

The NewEncrypted parameter specifies whether the table should be encrypted, and the NewPassword parameter specifies the specifies the password for the encryption.
The NewDescription parameter specifies the new description for the table.

The NewIndexPageSize and NewBlobBlockSize parameters specify the index page size and BLOB block size for the table, respectively. Please see Appendix C - System Capacities for more information on the proper values for these parameters.

The NewLastAutoIncValue parameter specifies the new last autoinc value for the table.

The NewTextIndexFields is a list of field names that should be included in the full text index for the table. These field names should be separated by semicolons and should only be the names of string or memo fields. Leaving this parameter blank will remove any entries in the full text index. There is no explicit limit to the number of string or memo fields that can be text indexed.

The NewTextIndexStopWords parameter specifies a list of stop words to be used for the full text index. Stop words are words that will be removed from the index due to the fact that they are too common, such as is the case with the word "the". This parameter is a TStrings object, and if you leave this parameter nil DBISAM will use the default stop words list for the full text index.

The NewTextIndexSpaceChars parameter specifies a set of characters to be used as word separators for the full text index. Space characters are used to determine how words are separated from one another for the purposes of indexing the words in the full text index. This parameter is a string, and if you leave this parameter blank DBISAM will use the default space characters above for the full text index.

The NewTextIndexIncludeChars parameter specifies a set of characters to be used as valid characters in a word for the full text index. Include characters are used to determine how words are formed by specifying which characters are included in the word and which are ignored. This parameter is a string, and if you leave this parameter blank DBISAM will use the default include characters above for the full text index.

Information You can retrieve the default full text indexing parameters using the TDBISAMEngine GetDefaultTextIndexParams method. Please see the Full Text Indexing topic for more information.

The SuppressBackups parameter specifies whether the creation of backup files should take place during the alteration of the table structure.
More Support Options More Support Options

Ok. Sorry

You where saying that I had a quote missing.

No, that was a typo when I posted the thread.

The problem is that If I make reference in any part of my code like

Code:

adoquery.fieldByName('fieldWhatEver').aswhatever,

then I have to declare those fields inside my SELECT Query, and also have to be declared inside my Persistent Field Editor for the TAdoQuery Component.

Unless there is another way to do it 

Value	               Description
------------------------------------
ftUnknown	   //  Unknown or undetermined
ftString	        //  Character or string field
ftSmallint	      //  16-bit integer field
ftInteger	       //  32-bit integer field
ftWord	               //  16-bit unsigned integer field
ftBoolean	    //  Boolean field
ftFloat	                 // Floating-point numeric field
ftCurrency	    // Money field
ftBCD	               // Binary-Coded Decimal field
ftDate	                // Date field
ftTime	                // Time field
ftDateTime	   // Date and time field
ftBytes	                // Fixed number of bytes (binary storage)
ftVarBytes	     // Variable number of bytes (binary storage)
ftAutoInc	       // Auto-incrementing 32-bit integer counter field
ftBlob	                 // Binary Large OBject field
ftMemo	              // Text memo field
ftGraphic	      // Bitmap field
ftFmtMemo	  // Formatted text memo field
ftParadoxOle	  // Paradox OLE field
ftDBaseOle	  // dBASE OLE field
ftTypedBinary	  // Typed binary field
ftCursor	      // Output cursor from an Oracle stored procedure (TParam only)
ftFixedChar	   // Fixed character field
ftWideString	  // Wide string field
ftLargeint	      // Large integer field
ftADT	                // Abstract Data Type field
ftArray	                 // Array field
ftReference	   // REF field
ftDataSet	     // DataSet field
ftOraBlob	     // BLOB fields in Oracle 8 tables
ftOraClob	    // CLOB fields in Oracle 8 tables
ftVariant	      // Data of unknown or undetermined type
ftInterface	     // References to interfaces (IUnknown)
ftIDispatch	   // References to IDispatch interfaces
ftGuid	              //  globally unique identifier (GUID) values


const
 adCmdText = $00000001;
 adExecuteNoRecords = $00000080;

procedure RunScript();
var
 tString: TStringList;
 ADOCommand: Variant;
 ADORecordset: Variant;
 ADOConnection: Variant;  
 i, len: Integer;
 strToQuery, str: String;
begin
 try
 ADOConnection := CreateOleObject('ADODB.Connection'); 
 ADOConnection.ConnectionString := 
  'Provider=SQLOLEDB;' +               // provider
  'Data Source=(local)\SQL2000;' +   // server name
  'Initial Catalog=databasename;' +       // default database
  'User Id=userId;' +                // user name
  'Password=password;';                   // password
 ADOConnection.Open;
 try
  ADOCommand := CreateOleObject('ADODB.Command');
  ADOCommand.ActiveConnection := ADOConnection;
   tString:= TStringList.Create;
   tString.LoadFromFile('C:\sqlscript.sql');
   len:= tString.Count;
   strToQuery:='';
   for i:=0 to len-1 do begin
    str := trim(tString[i]);          
    if POS('go', lowercase(str)) = 1  then begin
     //If GO is found run the script added in to strToQuery since last GO
     ADOCommand.CommandText := strToQuery;                           
     ADOCommand.Execute(NULL, NULL, adCmdText or adExecuteNoRecords);
     strToQuery:='';        //Clear the string to start adding till next GO
     end else strToQuery:= strToQuery +#13#10+ str;  //Add the script to strToQuery
    end;
    ADOCommand.CommandText := strToQuery;                           
    ADOCommand.Execute(NULL, NULL, adCmdText or adExecuteNoRecords);
 finally
  ADOConnection.Close;
  tString.Free;
 end;
 except
  MsgBox(GetExceptionMessage, mbError, MB_OK);
 end;
end;

http://www.retroarchive.org/garbo/pc/turbopas/index.html