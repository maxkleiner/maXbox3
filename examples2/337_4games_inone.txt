{//*********************************************************************
 logic game examples with form, objects & structure, loc's=168  example _175ff
 How to play: Create horizontal lines using the falling blocks. When you make a
  line, it is cleared from the screen. The game is over when the blocks pile up
  and reach the top of the screen. Use the left and right arrow keys to move
  blocks,  and down arrow key to drop pieces faster. locS=2168
  Runs in maXbox www.softwareschule.ch

//http://www.softwareschule.ch/examples/281_picturepuzzle4.txt
//http://www.softwareschule.ch/examples/picturepuzzle3.png

  ********************************************************************* }
// declaration of 4 form class, bug of inc(score+5) & linux  solved!

program FourGamesinOne;

const
  GlassWidth=10;
  GlassHeight=19; //orig is 23
  BarWidth= 14;
  BarHeight=14;
  NextBarWidth= 9;
  NextBarHeight=9;
  TopOfs=    6;
  LeftOfs=   5;
  FieldWidth=4;
  MaxFigureNumber=7;
  MaxCornerNumber=4;
  MaxFigureSize=  4;
  MaxFigureColor= 7;


type                                              
  TMoveDirect=  (mdDown,mdLeft,mdRight);
  TFigureCorner= (fc00,fc90,fc180,fc270);
  TFigureCornerSet = set of TFigureCorner;
  TFigureWorksheet1 = array [1..4] of Byte;
  TFigureWorksheet = array [1..4] of TFigureWorksheet1;
  TGlassWorkSheet1 = array [1..GlassWidth] of Byte;
  TGlassWorkSheet = array [1..GlassHeight] of TGlassWorkSheet1;


var
  pForm: TForm;
  sbutton: TButton;
  label3, label4: TLabel;
  Timer1: TTimer;
  bevel3: TBevel;
  GlassWS, OldGlassWS:  TGlassWorkSheet;
  Triada, LCorner, RCorner: TFigureWorksheet;
  LZigzag, RZigzag, Stick, Box: TFigureWorkSheet;
  FigureWS: TFigureWorksheet;
    Level,cntr:   Byte;
    Score:        Longint;
    ReentTimer:   Boolean;
    ReentKeys:    Boolean;
    FigureActive: Boolean;
    FigureType:   Byte;
    FigureX:      Byte;
    FigureY:      Byte;
    FigureCorner: TFigureCorner;
    FigureMove:   TMoveDirect;
    FirstColor:   Byte;
    SecondColor:  Byte;
    FirstFigure:  Byte;
    SecondFigure: Byte;
    NextTopOfs:   Integer;
    NextLeftOfs:  Integer;
    RedrawSheet:  Boolean;

//----------------------Sub Routines--------------------------------------- 

procedure Move(const Source: TFigureWorksheet;
                      var Dest: TFigureWorksheet; count : Integer );
//{$IFDEF PUREPASCAL}
var
  I,J: Integer;
begin
  //S:= PChar(@Source);
  //D:= PChar(@Dest);
  //if Cardinal(D) > Cardinal(S) then
  //if D[1][1] > S[1][1] then
   for J:= 1 to 4 do
    for I:= 1 to 4  do
     //if Source[J][I] > 0 then  //special effect
      Dest[J][I]:= Source[J][I]
end;


procedure MoveOld(const Source: TGlassWorksheet;
                      var Dest: TGlassWorksheet; count : Integer );
//{$IFDEF PUREPASCAL}
var
  I,J: Integer;
begin
  //if high(S) = high(D) then Exit;
  for J:= 1 to GlassHeight do
    for I:= 1 to GlassWidth  do
    //if Source[J][I] > 0 then
      Dest[J][I]:= Source[J][I]
end;

procedure FillCharOldGlass(sign: byte);
var
  I,J: Byte;
begin
    for J:= 1 to GlassHeight  do
      for I:= 1 to GlassWidth  do
        OldGlassWS[J][I]:= sign;
end;        

procedure FillCharCS(sign: byte; var worksheet: TFigureWorksheet);
var I,J: Byte;
begin
    for J:= 1 to 4  do
      for I:= 1 to 4  do
        worksheet[J][I]:= sign;
end;

procedure FillCharWS(sign: byte);
var I,J: Byte;
begin
    for J:= 1 to 4 do
      for I:= 1 to 4  do
        FigureWS[J][I]:= sign;
end;        

procedure SetFigures;
begin
  Triada[1][1]:= 0;  Triada[1][2]:= 1;  Triada[1][3]:= 0;  Triada[1][4]:= 0;
  Triada[2][1]:= 1;  Triada[2][2]:= 1;  Triada[2][3]:= 1;  Triada[2][4]:= 0;
  Triada[3][1]:= 0;  Triada[3][2]:= 0;  Triada[3][3]:= 0;  Triada[3][4]:= 0;
  Triada[4][1]:= 0;  Triada[4][2]:= 0;  Triada[4][3]:= 0;  Triada[4][4]:= 0;

  FigureWS[1][1]:= 0; FigureWS[1][2]:= 0; FigureWS[1][3]:= 0; FigureWS[1][4]:= 0;
  FigureWS[2][1]:= 0; FigureWS[2][2]:= 0; FigureWS[2][3]:= 0; FigureWS[2][4]:= 0;
  FigureWS[3][1]:= 0; FigureWS[3][2]:= 0; FigureWS[3][3]:= 0; FigureWS[3][4]:= 0;
  FigureWS[4][1]:= 0; FigureWS[4][2]:= 0; FigureWS[4][3]:= 0; FigureWS[4][4]:= 0;

  LCorner[1][1]:= 1;  LCorner[1][2]:= 1;  LCorner[1][3]:= 1;  LCorner[1][4]:= 0;
  LCorner[2][1]:= 1;  LCorner[2][2]:= 0;  LCorner[2][3]:= 0;  LCorner[2][4]:= 0;
  LCorner[3][1]:= 0;  LCorner[3][2]:= 0;  LCorner[3][3]:= 0;  LCorner[3][4]:= 0;
  LCorner[4][1]:= 0;  LCorner[4][2]:= 0;  LCorner[4][3]:= 0;  LCorner[4][4]:= 0;

  RCorner[1][1]:= 1;  RCorner[1][2]:= 1;  RCorner[1][3]:= 1;  RCorner[1][4]:= 0;
  RCorner[2][1]:= 0;  RCorner[2][2]:= 0;  RCorner[2][3]:= 1;  RCorner[2][4]:= 0;
  RCorner[3][1]:= 0;  RCorner[3][2]:= 0;  RCorner[3][3]:= 0;  RCorner[3][4]:= 0;
  RCorner[4][1]:= 0;  RCorner[4][2]:= 0;  RCorner[4][3]:= 0;  RCorner[4][4]:= 0;

  LZigzag[1][1]:= 1;  LZigzag[1][2]:= 1;  LZigzag[1][3]:= 0;  LZigzag[1][4]:= 0;
  LZigzag[2][1]:= 0;  LZigzag[2][2]:= 1;  LZigzag[2][3]:= 1;  LZigzag[2][4]:= 0;
  LZigzag[3][1]:= 0;  LZigzag[3][2]:= 0;  LZigzag[3][3]:= 0;  LZigzag[3][4]:= 0;
  LZigzag[4][1]:= 0;  LZigzag[4][2]:= 0;  LZigzag[4][3]:= 0;  LZigzag[4][4]:= 0;

  RZigzag[1][1]:= 0;  RZigzag[1][2]:= 1;  RZigzag[1][3]:= 1;  RZigzag[1][4]:= 0;
  RZigzag[2][1]:= 1;  RZigzag[2][2]:= 1;  RZigzag[2][3]:= 0;  RZigzag[2][4]:= 0;
  RZigzag[3][1]:= 0;  RZigzag[3][2]:= 0;  RZigzag[3][3]:= 0;  RZigzag[3][4]:= 0;
  RZigzag[4][1]:= 0;  RZigzag[4][2]:= 0;  RZigzag[4][3]:= 0;  RZigzag[4][4]:= 0;

  Stick[1][1]:= 1;  Stick[1][2]:= 1;  Stick[1][3]:= 1;  Stick[1][4]:= 1;
  Stick[2][1]:= 0;  Stick[2][2]:= 0;  Stick[2][3]:= 0;  Stick[2][4]:= 0;
  Stick[3][1]:= 0;  Stick[3][2]:= 0;  Stick[3][3]:= 0;  Stick[3][4]:= 0;
  Stick[4][1]:= 0;  Stick[4][2]:= 0;  Stick[4][3]:= 0;  Stick[4][4]:= 0;
 
  Box[1][1]:= 1;  Box[1][2]:= 1;  Box[1][3]:= 0;  Box[1][4]:= 0;
  Box[2][1]:= 1;  Box[2][2]:= 1;  Box[2][3]:= 0;  Box[2][4]:= 0;
  Box[3][1]:= 0;  Box[3][2]:= 0;  Box[3][3]:= 0;  Box[3][4]:= 0;
  Box[4][1]:= 0;  Box[4][2]:= 0;  Box[4][3]:= 0;  Box[4][4]:= 0;
 
 {FWSheet[1][1]:= 0;  FWSheet[1][2]:= 0;  FWSheet[1][3]:= 0;  FWSheet[1][4]:= 0;
  FWSheet[2][1]:= 0;  FWSheet[2][2]:= 0;  FWSheet[2][3]:= 0;  FWSheet[2][4]:= 0;
  FWSheet[3][1]:= 0;  FWSheet[3][2]:= 0;  FWSheet[3][3]:= 0;  FWSheet[3][4]:= 0;
  FWSheet[4][1]:= 0;  FWSheet[4][2]:= 0;  FWSheet[4][3]:= 0;  FWSheet[4][4]:= 0;}
end;

procedure SetFigureColor;
var I,J: Byte;
begin
  for I:= 1 to MaxFigureSize do
    for J:= 1 to MaxFigureSize do
      if FigureWS[I][J] > 0 then FigureWS[I][J]:= SecondColor;
end;

function FigureXSize: Byte;
var I,J,K: Byte;
begin
  K:= 0;
  for J:= 1 to MaxFigureSize do
    for I:= 1 to MaxFigureSize do
      if FigureWS[J][I]>0 then
        if K<I then K:= I;
  result:= K;
end;

function FigureYSize: Byte;
var I,J,K: Byte;
begin
  K:= 0;
  for J:= 1 to MaxFigureSize do
    for I:= 1 to MaxFigureSize do
      if FigureWS[J][I]>0 then
        if K<J then K:= J;
  result:= K;
end;

//------------------------------------Procedures Routines-------------------
procedure GenerateNewFigure;         
begin
  Timer1.Enabled:= False;
  SecondFigure:= FirstFigure;
  SecondColor:= FirstColor;
  FigureType:= SecondFigure;
  FigureX:= 5;
  FigureY:= 0;
  FigureCorner:= fc270;
  FillCharWS(0);    //is 0 or 255?
  writeln('debug figure: '+inttostr(figuretype))
  case FigureType of
    0: Move(Triada,FigureWS,SizeOf(FigureWS));
    1: Move(LCorner,FigureWS,SizeOf(FigureWS));
    2: Move(RCorner,FigureWS,SizeOf(FigureWS));
    3: Move(LZigzag,FigureWS,SizeOf(FigureWS));
    4: Move(RZigzag,FigureWS,SizeOf(FigureWS));
    5: Move(Stick,FigureWS,SizeOf(FigureWS));
    6: Move(Box,FigureWS,SizeOf(FigureWS));
  end;
  SetFigureColor;
  FigureMove:= mdDown;
  FirstFigure:= Random(MaxFigureNumber);
  FirstColor:= Random(MaxFigureColor)+1;
  Timer1.Enabled:= True;
end;

procedure ClearFigureIntoGlass;
var I,J: Byte;
begin
  for J:= 1 to FigureYSize do
    for I:= 1 to FigureXSize do
      if FigureWS[J][I]>0 then
        GlassWS[FigureY+J][FigureX+I]:= 0;
end;

procedure FormPaint(Sender: TObject);
var
  X1,Y1,X2,Y2: Integer;
  NewRect:     TRect;
  I,J:         Byte;
  CurSheet:    TFigureWorksheet;
  NextColor:   TColor;
begin
if RedrawSheet then FillCharoldGlass(255); //#255
  for J:= 1 to GlassHeight do
    for I:= 1 to GlassWidth do begin
      if GlassWS[J][I]= OldGlassWS[J][I] then Continue;
      X1:= LeftOfs+(I-1)*BarWidth;
      X2:= X1+BarWidth;
      Y1:= TopOfs+(J-1)*BarHeight;
      Y2:= Y1+BarHeight;
      case GlassWS[J][I] of
        0: pForm.Canvas.Brush.Color:= clNavy;
        1: pForm.Canvas.Brush.Color:= clSilver;
        2: pForm.Canvas.Brush.Color:= clOlive;
        3: pForm.Canvas.Brush.Color:= clGray;
        4: pForm.Canvas.Brush.Color:= clBlue;
        5: pForm.Canvas.Brush.Color:= clPurple;
        6: pForm.Canvas.Brush.Color:= clAqua;
        7: pForm.Canvas.Brush.Color:= clTeal;
        8: pForm.Canvas.Brush.Color:= clWhite;
      end;
      if GlassWS[J][I]>0 then begin
        NewRect := Rect(X1+1,Y1+1,X2-1,Y2-1);
        pForm.Canvas.FillRect(NewRect);
        pForm.Canvas.Pen.Color:= clGray;
        pForm.Canvas.MoveTo(X1,Y1);
        pForm.Canvas.LineTo(X1,Y2-1);
        pForm.Canvas.LineTo(X2-1,Y2-1);
        pForm.Canvas.Pen.Color:= clWhite;
        pForm.Canvas.LineTo(X2-1,Y1);
        pForm.Canvas.LineTo(X1,Y1);
      end
      else begin
        NewRect:= Rect(X1,Y1,X2,Y2);
        pForm.Canvas.FillRect(NewRect);
      end;
    end;
  case FirstFigure of
    0: Move(Triada,CurSheet,SizeOf(CurSheet));
    1: Move(LCorner,CurSheet,SizeOf(CurSheet));
    2: Move(RCorner,CurSheet,SizeOf(CurSheet));
    3: Move(LZigzag,CurSheet,SizeOf(CurSheet));
    4: Move(RZigzag,CurSheet,SizeOf(CurSheet));
    5: Move(Stick,CurSheet,SizeOf(CurSheet));
    6: Move(Box,CurSheet,SizeOf(CurSheet));
  end;
  case FirstColor of
    0: NextColor:= clNavy;
    1: NextColor:= clSilver;
    2: NextColor:= clOlive;
    3: NextColor:= clGray;
    4: NextColor:= clBlue;
    5: NextColor:= clPurple;
    6: NextColor:= clAqua;
    7: NextColor:= clTeal;
    8: NextColor:= clWhite;
  end;
  for J:= 1 to MaxFigureSize-2 do
    for I:= 1 to MaxFigureSize do begin
      X1:= NextLeftOfs+(I-1)*NextBarWidth;
      X2:= X1+NextBarWidth;
      Y1:= NextTopOfs+(J-1)*NextBarHeight;
      Y2:= Y1+NextBarHeight;
      if CurSheet[J][I]>0 then begin
        NewRect:= Rect(X1+1,Y1+1,X2-1,Y2-1);
        pForm.Canvas.Brush.Color:= NextColor;
        pForm.Canvas.FillRect(NewRect);
        pForm.Canvas.Pen.Color:= clGray;
        pForm.Canvas.MoveTo(X1,Y1);
        pForm.Canvas.LineTo(X1,Y2-1);
        pForm.Canvas.LineTo(X2-1,Y2-1);
        pForm.Canvas.Pen.Color:= clWhite;
        pForm.Canvas.LineTo(X2-1,Y1);
        pForm.Canvas.LineTo(X1,Y1);
      end
      else begin   //foresight or clSilver
        pForm.Canvas.Brush.Color:= random(clblue);
        NewRect:= Rect(X1,Y1,X2,Y2);
        pForm.Canvas.FillRect(NewRect);
      end;
    end;
  MoveOld(GlassWS,OldGlassWS,SizeOf(OldGlassWS));
end;

function PutFigureIntoGlass(MoveDirect: TMoveDirect): Boolean;
var
  I,J: Byte;
begin
  result:= True;
  if (FigureY+FigureYSize > GlassHeight) and (MoveDirect=mdDown) then begin
    Dec(FigureY);
    result:= False;
    Exit;
  end else
    while (FigureX+FigureXSize > GlassWidth) and (MoveDirect=mdDown) do
       Dec(FigureX);
    for J:= 1 to FigureYSize do begin      //-1 anti Tetris !!
      for I:= 1 to FigureXSize do begin
        if (FigureWS[J][I] > 0) and
          (GlassWS[FigureY+J][FigureX+I]>0) then begin
          if (FigureY+J < 3) then begin
            result:= false;
            exit;
          end;  
          //writeln('glass debug :'+inttoStr(FigureY+J))
          result:= False;
          case MoveDirect of
            mdDown:  Dec(FigureY);
            mdRight: Dec(FigureX);
            mdLeft:  Inc(FigureX);
          end;
          Exit;
        end;
      end;
    end;
  for J:= 1 to FigureYSize do
    for I:= 1 to FigureXSize do
      if FigureWS[J][I] > 0 then
        GlassWS[FigureY+J][FigureX+I]:= FigureWS[J][I];
  RedrawSheet:= False;
  FormPaint(Self);
  RedrawSheet:= True;
end;

procedure ScanFillLines;
var
  I,J,K,L: byte;
begin
  ClearFigureIntoGlass;
  for J:= 1 to GlassHeight do begin
    K:= 0;
    for I:= 1 to GlassWidth do
      if GlassWS[J][I]>0 then Inc(K);
    if K = GlassWidth then begin   // if line is full
      for L:= J downto 1 do
        for I:= 1 to GlassWidth do
          if L>1 then GlassWS[L][I]:= GlassWS[L-1][I];
    end;
  end;
  PutFigureIntoGlass(FigureMove);
end;


procedure Timer1Timer(Sender: TObject);
var
  I,J: Byte;
begin
  if ReentTimer then Exit
    else ReentTimer:= True;
  if StrToInt(Label3.Caption)<>Level then Label3.Caption := IntToStr(Level);
  if StrToInt(Label4.Caption)<>Score then Label4.Caption := IntToStr(Score);
  if not FigureActive then begin
    GenerateNewFigure;
    if not PutFigureIntoGlass(FigureMove) then begin
   if MessageDlg('Another Game..my Flame?',mtConfirmation,[mbYes,mbNo],0)=mrYes
    then begin
      FillCharOldGlass(250);   //#255
      Timer1.Enabled:= False;
       //SpeedButton7.Enabled := False;
      ClearFigureIntoGlass;
      FigureActive:= False;
      pForm.KeyPreview:= true;
      pform.SetFocus;
      Level:= 1;
      Score:= 0;
      for J:= 1 to GlassHeight do
        for I:= 1 to GlassWidth do GlassWS[J][I]:= 0;
      RedrawSheet:= False;
      FormPaint(Self);
      RedrawSheet:= True;
      timer1.enabled:= True; 
    end 
     else pForm.close
     end; 
   FigureActive:= true; 
  end
  else begin
    ClearFigureIntoGlass;
    Inc(FigureY);
    if not PutFigureIntoGlass(FigureMove) then begin
      //image1.visible:=true;  //linux gag
      case FigureType of
        0: Score:= Score+10;
        1: Score:= Score+30;
        2: Score:= Score+30;
        3: Score:= Score+25;
        4: Score:= Score+25;
        5: Score:= Score+15;
        6: Score:= Score+20;
      end;
      if Score>300 then Level:= 2;
      if Score>700 then Level:= 3;
      if Score>1300 then Level:= 4;
      if Score>2000 then Level:= 5;
      if Score>3000 then Level:= 6;
      if Score>5000 then Level:= 7;
      Timer1.Interval:= Round((7.1-Level)*100);
      //timer1.interval:= 1000;
      FigureActive:= false; //if true then timertest
    end;
  end;
  ScanFillLines;
  ReentTimer:= False;
end;


//it was a subprocedure with rotate figure
procedure RotateFigureWorksheet(OldFigureCornet: TFigureCorner; CurSheet:
        TFigureWorksheet; OldFigureCorner: TFigureCorner);
var
  VertFlag, HorizFlag, K,I,J:  Byte;
begin
  FillCharWS(0);
  case FigureType of
    0: Move(Triada,FigureWS,SizeOf(FigureWS));
    1: Move(LCorner,FigureWS,SizeOf(FigureWS));
    2: Move(RCorner,FigureWS,SizeOf(FigureWS));
    3: Move(LZigzag,FigureWS,SizeOf(FigureWS));
    4: Move(RZigzag,FigureWS,SizeOf(FigureWS));
    5: Move(Stick,FigureWS,SizeOf(FigureWS));
    6: Move(Box,FigureWS,SizeOf(FigureWS));
  end;
  FillCharCS(0, curSheet); //!!
  for K:= 0 to Byte(FigureCorner) do begin
    for I:= 1 to MaxFigureSize do
      for J:= 1 to MaxFigureSize do
        CurSheet[J][I]:= FigureWS[MaxFigureSize-I+1][J];
    Move(CurSheet,FigureWS,SizeOf(FigureWS));
  end;
  SetFigureColor;
  HorizFlag:= 0;
  while HorizFlag=0 do begin
    for I:= 1 to MaxFigureSize do
      if FigureWS[1][I]>0 then HorizFlag:= 1;
    if HorizFlag=0 then begin
      for J:= 1 to MaxFigureSize-1 do
        for I:= 1 to MaxFigureSize do
          FigureWS[J][I]:= FigureWS[J+1][I];
      for J:= 1 to MaxFigureSize do
        FigureWS[MaxFigureSize][J]:= 0;
    end;
  end;
  VertFlag:= 0;
  while VertFlag=0 do begin
    for J:= 1 to MaxFigureSize do
      if FigureWS[J][1]>0 then VertFlag:= 1;
    if VertFlag=0 then begin
      for J:= 1 to MaxFigureSize do
        for I:= 1 to MaxFigureSize-1 do
          FigureWS[J][I]:= FigureWS[J][I+1];
      for J:= 1 to MaxFigureSize do
        FigureWS[J][MaxFigureSize]:= 0;
    end;
  end;
end;

procedure RotateFigure;
var
  OldFigureCornet, OldFigureCorner: TFigureCorner;
  CurSheet: TFigureWorksheet;
  figurecSet: TFigureCornerSet;
begin
  ClearFigureIntoGlass;
  OldFigureCorner:= FigureCorner;
  //if FigureCorner > fc00 then Dec(FigureCorner)
  figurecset:= [fc90, fc180, fc270]
  if FigureCorner in figurecset then Dec(FigureCorner)
    else FigureCorner:= fc270;
  RotateFigureWorksheet(oldfigurecornet, cursheet, oldfigurecorner);
  if not PutFigureIntoGlass(mdDown) then begin
    FigureCorner:= OldFigureCorner;
    RotateFigureWorksheet(oldfigurecornet, cursheet, oldfigurecorner);
    PutFigureIntoGlass(mdDown);
  end;
end;

//----------------------- button & key controls------------------------------

procedure CloseClick(Sender: TObject; var action: TCloseAction);
begin
  if Timer1 <> NIL then begin
    Timer1.enabled:= false;
    Timer1.Free;
    Timer1:= NIL;
  end;
  Writeln('Tetris closed and Free');
end;

procedure FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
begin
  {if ReentKeys then Exit
    else ReentKeys:= True;
  if not FigureActive then begin
    ReentKeys:= False;}
    //Exit;
  //end;
  writeln('debug'+Chr(Key)+' - '+IntToStr(Key));  //alternate J,K,L
  case Key of                                     //            M   for arrows!
   {$IFDEF LINUX}4096{$ELSE}27{$ENDIF} : pForm.close;  //4096 linux.....
   {$IFDEF LINUX}4115{$ELSE}38,75{$ENDIF} {Key_Up}:    RotateFigure;  //4115 
   {$IFDEF LINUX}4117{$ELSE}40,77{$ENDIF}{Key_Down},                 //4117
    32 {Key_Space}: begin    //VK_SPACE in win
                repeat
                  ClearFigureIntoGlass;
                  Inc(FigureY);
                until not PutFigureIntoGlass(mdDown);
                Inc(Score);
              end;
  {$IFDEF LINUX}4114{$ELSE}37,74{$ENDIF}{Key_Left}:
              if FigureX>0 then begin
                ClearFigureIntoGlass;
                Dec(FigureX);
                PutFigureIntoGlass(mdLeft);
              end;
 // {$IFDEF LINUX}4116{$ELSE}39,76{$ENDIF}{Key_Right}:
           39,76:
 
              if FigureX+FigureXSize<GlassWidth then begin  
                ClearFigureIntoGlass;
                Inc(FigureX);
                PutFigureIntoGlass(mdRight);
              end;
  end;
  //ReentKeys:= False;
end;

procedure BreakClick(Sender: TObject);
var state: Tshiftstate;
  keys: integer;
begin
  if Timer1.Enabled then begin
    Timer1.Enabled:= False;
    sbutton.caption:= 'Go On';
    //SpeedButton1.Enabled := False;
  end
  else begin
    Timer1.Enabled := True;
    sbutton.caption:= 'Pause Game';
    pForm.KeyPreview:= true;
    //pForm.onClick;
    //pForm.onKeyDown:= @FormKeyDown;
    pform.SetFocus;
    //figureActive:= true;
    //SpeedButton7.Enabled := True;
  end;
end;



procedure FormTCreate(Sender: TObject);
var label1, label2: TLabel;
   bevel1, bevel2, bevel4: TBevel;
begin
  FillCharOldGlass(250);
  SetFigures;
  cntr:= 0;
  RedrawSheet:= True;
  pform:= Tform.create(self); //constructors
  bevel1:= TBevel.create(pform)
  bevel1.parent:= pForm;
  label1:= TLabel.create(pform)
  label1.parent:= pForm;
  bevel2:= TBevel.create(pform)
  bevel2.parent:= pForm;
  bevel3:= TBevel.create(pform)
  bevel4:= TBevel.create(pform)
  bevel4.parent:= pForm;
  label2:= TLabel.create(pform)
  label2.parent:= pForm;
  label3:= TLabel.create(pform)
  label3.parent:= pForm;
  label4:= TLabel.create(pform)
  label4.parent:= pForm;
  sButton:= TButton.create(pform)
  timer1:= TTimer.create(pform);
  with pform do begin
    caption:= 'Tetris boX3';  
    BorderStyle:= bsDialog;
    Position:= poDefault;
    //onKeyPress:= @FormKeyPress
    onKeyDown:= @FormKeyDown;
    onPaint:= @FormPaint;
    onClose:= @CloseClick;
    color:= clTeal;
    KeyPreview:= true;
    show;
  end;  
  with SButton do begin
    parent:= pForm;
    caption:= 'Pause TBox'
    top:= 20;
    width:= 76;
    onclick:= @Breakclick;
  end;  
  with Bevel3 do begin
    parent:= pForm;
    Top:= TopOfs-FieldWidth;
    Left:= LeftOfs-FieldWidth;
    Width:= GlassWidth*BarWidth+FieldWidth*2;
    Height:= GlassHeight*BarHeight+FieldWidth*2;
  end;
  with Bevel4 do begin
     Top:= 82;
     Left:= (176);
     Height:= NextBarHeight*(MaxFigureSize-1)+10;
     Width:=NextBarWidth*MaxFigureSize+8;
  end;   

  pForm.ClientWidth:= Bevel3.Width+FieldWidth*3+100; 
  pForm.ClientHeight:= Bevel3.Height+FieldWidth*2;
  SButton.Left:= Bevel3.Width+FieldWidth*4;
  Label2.Left:= Bevel4.Left+FieldWidth-6;
  Label2.top:= Bevel4.Top+FieldWidth+55;
  label2.caption:= 'Level / Score: ';
  Bevel2.Left:= Label2.Left-8;
  Bevel2.Width:= bevel4.Width+30;
  Bevel2.Top:= Bevel4.Left+FieldWidth-20;
  Bevel2.Height:= Bevel4.Height+22;
  Label3.Left := Bevel4.Left+FieldWidth;
  Label3.top  := Bevel4.Top+FieldWidth+77;
  Label4.Left := Bevel4.Left+FieldWidth;
  Label4.top  := Bevel4.Top+FieldWidth+100;
  Label1.Left := Bevel4.Left+FieldWidth-8;
  Label1.top  := Bevel4.Top+FieldWidth+145;
  label1.caption:= 'Player: '+#13#10+GetUserName; //{$IFDEF LINUX}IndyGetHostName
  Bevel1.Left:= Label2.Left-8;
  Bevel1.Width:= bevel4.Width+30;
  Bevel1.Top:= Bevel4.Left+FieldWidth+50;
  Bevel1.Height:= Bevel4.Height-5;
  NextTopOfs:= 86;
  NextLeftOfs:= 180;
  Level:= 1;
  timer1.onTimer:= @Timer1Timer;
  Timer1.Interval:= 2000; //Timer1.Interval := Round((6.5-Level)*100);
  Score := 0;
  ReentTimer:= False;
  ReentKeys:= False;
  FigureActive:= False;
  Label3.Font.size:= 14;  //level
  Label4.font.size:= 14;  //score
  Label3.Font.color:= clRed;
  Label4.font.color:= clRed;  
  Label3.Caption:= '1';  //level
  Label4.Caption:= '0';  //score
  Randomize;
  FirstFigure:= Random(MaxFigureNumber);
  FirstColor:= Random(MaxFigureColor)+1;
  pForm.BorderStyle:= bsDialog;
end;

///////////////////////////////////////////////////////////////////////////////
//////////////////////// Picture Puzzle App ///////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
Type 
    TField2 = array[0..5] of String;
    TField1 = array[0..5] of TField2;
    TDir2 = array[1..2] of smallint;


Const FBOX = 4;
      QB = FBOX*FBOX;
      GPIC = 'examples\max_locomotion.bmp';

var
  frmMon: TForm;
  Image1: TImage;
  drG: TDrawGrid;
  frmsg: TStringGrid;
  stat: TStatusbar;
  panstep: TPanel;
  Progress: TProgressBar;
  picname: shortstring;
  Zug: integer;
  Field, zField: TField1;  //Feldbelegung, Zielfeld
  bArr: Array[1..QB+1] of TBitmap;
  dir: array[1..FBOX] of TDir2;
  
procedure initNavArray;
begin
  dir[1][1]:= 0;
  dir[1][2]:= -1;
  dir[2][1]:= 1;
  dir[2][2]:= 0;
  dir[3][1]:= 0;
  dir[3][2]:= 1;
  dir[4][1]:= -1;
  dir[4][2]:= 0;
 (*=(( 0,-1), //N
    ( 1, 0),  //O
    ( 0, 1),  //S
    (-1, 0)   //W *)
end;  

procedure CloseClickP(Sender: TObject; var action: TCloseAction); forward;
  
procedure loadImage;
var  aRect: TRect;
     bm: TBitMap;
begin
   bm:= TBitMap.Create;
   try
     //bm.LoadFromFile(ExePath+'examples\citymax.bmp');
     //picname:= ExePath+'examples\citymax.bmp'; //maxboxfrac.bmp
     picname:= ExePath+GPIC;
     bm.LoadFromFile(picname);
     //Image1.Picture.BitMap.LoadFromFile();
     aRect:= Rect(0,0,image1.Width,image1.Height);
     image1.Canvas.StretchDraw(aRect, bm);
   finally
     bm.Free;
   end;
end; 

procedure OpenPicture(var img: TImage);
var bm: TBitMap; aRect: TRect;
begin
  bm:= TBitMap.Create;
  with TOpenDialog.Create(self) do begin 
    Filter:= 'bitmap files (*.bmp)|*.BMP';
    InitialDir:= ExtractFilePath(Application.ExeName);
    if Execute then begin
      try
        bm.LoadFromFile(FileName);
        picname:= Filename;
      except
        showmessageBig('This is not a valid -------- BMP Picture!');
      end;
    end;
  end;  
  //Scale Bitmap bm at size of img1
  aRect:=Rect(0,0,image1.Width,image1.Height);
  image1.Canvas.StretchDraw(aRect, bm);
  bm.Free;
end;

procedure MakePuzzlePeaces;
//Erstellen der Teilquadrate und speichern in bArr
var
  i,bhg,bh,z,s,z1,s1,z2,s2: integer;
  r1,r2: TRect;
begin
    bhg:= image1.Picture.Width;
    bh:= bhg div FBOX;
    for i:= 1 to QB do begin //Größe der Images einstellen!
      bArr[i].Width:= bh;
      bArr[i].Height:= bh;
    end;
    //Images erstellen durch Kopieren aus dem Quellbild
    for i:= 1 to QB do begin
      //Zeile/Spalte des Rasters bestimmen
      z:=(i-1) div FBOX + 1; s:=(i-1) mod FBOX + 1;
      s1:=(s-1)*bh; z1:=(z-1)*bh;
      s2:=s*bh; z2:=z*bh;
      //Quadrate unter Berücksichtigung der Ränder definieren
      r1:=Rect(s1+1,z1+1,s2-1,z2-1); //Source
      r2:=Rect(1,1,bh-1,bh-1); //Destination
      with bArr[i].Canvas do begin
        Pen.Color:= RGB2TColor(100,100,100);
        Rectangle(0,0,bh,bh);
        CopyRect(r2,image1.Canvas,r1);
      end;
    end;
    //letztes Quadrat weißen //bArr[17]:= bArr[16]; //save last
    bArr[QB].Canvas.Brush.Color:= clWhite;
    bArr[QB].Canvas.FillRect(Rect(1,1,bh-1,bh-1));
end;  


procedure FinishedField;
//erzeugt die Zielbelegung auf zField
var w,z,s: smallint;
begin
  for z:= 0 to 5 do //Spielfeld löschen
    for s:= 0 to 5 do
      zField[s][z]:= '#'; //Randbelegung
  w:= 0;
  for z:= 1 to FBOX do
    for s:= 1 to FBOX do begin
      inc(w);
      zField[s][z]:= IntToStr(w);
    end;
  zField[FBOX][FBOX]:= ' ';
end;

procedure HideGridCursor(g: TStringGrid);
//Cursor aus dem StringGrid entfernen
var gr: TRect;//TGridRect;
begin
  with gr do begin
    Top:=-1; Left:=-1; Right:=-1; Bottom:=-1
  end; //g.Selection:= gr;
end;

procedure DrawField(f: TField1);
var
  z,s: integer;
begin
  for z:=1 to FBOX do
    for s:=1 to FBOX do begin
      frmsg.Cells[s-1,z-1]:= f[s][z];
    end;
  //Form1.panZug.Caption:=IntToStr(Zug);
  HideGridCursor(frmsg);
end;

function GetFreeDir(x,y: integer): integer;
//ermittelt die freie Richtung und gibt zurück:
//0...kein Nachbar frei; 1-4 für N/O/S/W
var
 d,fd: integer;
begin
  fd:= 0;
  for d:= 1 to FBOX do begin //check all directions
    if Field[x+dir[d][1]][y+dir[d][2]]=' ' then fd:= d;
  end;
  result:= fd;
end;

function HasFinished: boolean;
var
  finished: boolean;
  z,s: integer;
begin
  finished:=true;
  for z:=1 to FBOX do
    for s:=1 to FBOX do
      if Field[s][z]<>zField[s][z] then finished:= false;
  result:= finished;
end;

function RandomField: TField1;
var
  f0: TField1;
  f,f1: Array[1..QB] of string;
  free: Array[1..QB] of boolean;
  i,z,s,w: integer;
begin
  Randomize;
  for i:=1 to QB-1 do f[i]:= IntToStr(i);
  f[16]:=' ';
  for i:=1 to QB do free[i]:= true;
  w:=0;
  repeat //Zufallsbelegung in Linearfeld
    repeat
      z:= Random(QB)+1;
    until free[z];
    inc(w);
    f1[w]:= f[z];
    free[z]:= false;
  until w=QB;
  w:= 0;
  for z:=1 to FBOX do //take it
    for s:= 1 to FBOX do begin
      inc(w);
      f0[s][z]:=f1[w];
    end;
  Result:= f0;
end;

function maxSteps: integer;
//liefert die Anzahl der Entfernungs-Schritte zur Zielkonstellation
//mit der größtmöglichen Unordnung auf dem Feld
var z,s,sum: integer;
begin
  sum:=0;
  for z:=1 to 4 do
    for s:=1 to 4 do
      sum:=sum + max(z-1,4-z)+ max(s-1,4-s);
  result:= sum;
end;

function Steps(f: TField1): integer;
//liefert Schritte zur Zielkonstellation
//aus der aktuellen Belegung von f
var 
  s,z,x,y,w1,sum: integer;
  t: string;
begin
  sum:= 0;
  for z:=1 to 4 do begin
    for s:=1 to 4 do begin
      t:=f[s][z];
      if t=' ' then 
        w1:= 16 else //Zahl auf dem Feld
      w1:= StrToInt(t); 
      x:= round(abs((((w1-1) mod 4)+1)-s));
      y:= round(abs((((w1-1) div 4)+1)-z)); //Zielposition
      sum:= sum+x+y;
    end;
  end;
  result:= sum;
end;


//*********************** event handlers *********************************//
procedure btnNewPicClick(Sender: TObject);
begin
  //OpenPicture(img1); loadimage
  stat.SimpleText:= 'Welcome to PicPuzzle: '+ExtractFileName(picname)+' is loaded';
  drG.Visible:=false;
  MakePuzzlePeaces;
  FinishedField;
  Field:=zField;
  DrawField(zField);
  drG.Visible:=True;
  //btnNewGame.Enabled:=True;
  //btnCancel.Enabled:=True;
end;

procedure btnPictureLoad(Sender: TObject);
begin
  OpenPicture(image1);
  btnNewPicClick(Self);
end; 

procedure btnNewGameClick(Sender: TObject);
var p: real;
begin
  Field:=zField;
  Progress.Max:= maxSteps+20;
  Field:= zField;
  Field:= RandomField;
  Zug:= 0;
  p:= 100-Steps(Field)/MaxSteps*100;
  panStep.Caption:= formatFloat('0',p)+' %';
  Progress.Position:= round(p);
  drG.Repaint;
  DrawField(Field);
  HideGridCursor(frmsg);
  stat.SimpleText:='Game is running ...';
  //stat.Color:=$30809000;
  //btnNewPic.Enabled:=false;
end;

procedure btnCloseClick(Sender: TObject);
begin
  stat.SimpleText:= 'Closed Clicked';
  frmMon.Close;
end;

procedure CloseClickP(Sender: TObject; var action: TCloseAction);
var i: integer;
begin
   //if MessageDlg('Wanna Leave?',mtConfirmation,[mbYes, mbNo],0)= mrYes then begin
   //form1.Free; //bmp.Free;
   for i:= 1 to QB+1 do bArr[i].Free;
   action:= caFree;
   writeln('PicturePuzzle Free and Closer test finished');
   //end else
     //Action:= caNone;
end;

Function RGB(R,G,B: Byte): TColor;
Begin
  Result:= B Shl 16 Or G Shl 8 Or R;
End;

procedure drGClick(Sender: TObject);  //next step 
var  x,y,x1,y1,d: integer;
     p: single;
     w: String;
begin
  x:= drG.Col+1;
  y:= drG.Row+1;
  d:= GetFreeDir(x,y);
  if d>0 then begin //free neigbour cell
    x1:=x+dir[d][1];
    y1:=y+dir[d][2];
    w:= Field[x][y]; 
    Field[x][y]:= Field[x1][y1];
    Field[x1][y1]:= w;
    inc(Zug);
    p:= 100-Steps(Field)/MaxSteps*100;
    //writeln('debug '+floattostr(p)+' '+floattostr(steps(field)) );
    panStep.Caption:= 'Step: ' +inttoStr(zug)+'   '+formatFloat('0',p)+' %';
    Progress.Position:= round(p);
    DrawField(Field);
    drG.Repaint;
  end;
  if HasFinished then begin
    writeln('You won - End of picture game');
    stat.SimpleText:= 'PicturePuzzle Solved';
    //bArr[16].Canvas.Brush.color:= clred;
  end;
end;


procedure drGDrawCell(Sender: TObject; ACol, ARow: Integer;
                              Rect: TRect; State: TGridDrawState);
var nr: integer; t: string;      
begin
  with Sender {as TDrawGrid} do begin
    t:= Field[ACol+1][ARow+1];
    if t=' ' then nr:= QB else nr:= StrToInt(t);
    drg.Canvas.Draw(Rect.Left, Rect.Top, bArr[nr]);
  end;
end;

//*************************Form Create********************************//
procedure InitCreateForms;
var i: smallint;
    panImg, panR: TPanel;
begin
 // seq --> panel-image-drawgrid-bitmap
 for i:= 1 to QB+1 do bArr[i]:= TBitMap.Create;
 HideGridCursor(frmsg);
  //panimg1.DoubleBuffered:= true;
 frmMon:= TForm.Create(self);
 with frmMon do begin
   //FormStyle := fsStayOnTop;
   Position:= poScreenCenter;
   BorderIcons:= [biSystemMenu, biMinimize];
   BorderStyle:= bsSingle;
   PixelsPerInch:= 96;
   caption:='PascalPicturePuzzle of BITMAX';
   color:= clred;
   width:= 650;
   height:= 540;
   Show;
   onClose:= @CloseClickP;
 end;

 panImg:= TPanel.Create(frmMon)
   with panImg do begin
    parent:= frmMon;
    setBounds(8,8,451,451)
    BevelOuter:= bvLowered
    //DoubleBuffered:= true;
   end;  
 Image1:= TImage.create(frmMon);
 with Image1 do begin
   parent:= panImg;
   setbounds(1,1, 450,450);
   //show;
 end;
 drG:= TDrawGrid.Create(frmMon);
   with drG do begin
      parent:= panImg;
      Left:= 0; Top:= 0;
      Width:= 455; Height:= 455;
      Cursor:= crHandPoint;
      ColCount:= 4;
      DefaultColWidth:= 111;
      DefaultRowHeight:= 111
      FixedCols:= 0;
      RowCount:= 4;
      FixedRows:= 0;
      Options:= [goFixedVertLine,goFixedHorzLine,goVertLine,goHorzLine];
      ScrollBars:= ssNone;
      Visible:= False;
      OnClick:= @drGClick;
      OnDrawCell:= @drGDrawCell;
    end;
    PanR:= TPanel.create(frmMon);
    with PanR do begin
      parent:= frmMon;
      setBounds(472,9,155,450);
      BevelOuter:= bvLowered
      TabOrder:= 1
    end;
    with TBitBtn.Create(frmMon) do begin
      Parent:= frmMon;        
      SetBounds(488,30,121,30)        //30
      Caption:= 'Load Picture'
      Hint:= 'Load your own bitmap picture!';
      ShowHint:= true;
      glyph.LoadFromResourceName(getHINSTANCE,'CL_MPEJECT'); 
      OnClick:= @BtnPictureLoad;
    end;
    with TBitBtn.Create(frmMon) do begin
      Parent:= frmMon;        
      SetBounds(488,68,121,30)       //68
      glyph.LoadFromResourceName(getHINSTANCE,'CL_MPSTEP'); 
      Caption:= 'New Game'
      //Enabled:= False
      //TabOrder = 7
      OnClick:= @btnNewGameClick
    end;
    with TBitBtn.Create(frmMon) do begin
      Parent:= frmMon;        
      SetBounds(488,420,121,30)
      glyph.LoadFromResourceName(getHINSTANCE,'CL_MPSTOP'); 
      Caption:= 'Close'
      OnClick:= @btnCloseClick
    end;
    panstep:= TPanel.Create(frmMon); 
    with panstep do begin
      Parent:= frmMon;        
      SetBounds(488,120,121,25)
      BevelOuter:= bvLowered
      Caption:= '0 %'
      Color:= clyellow;//$30809000;
      //Color:= 8404992
    end;
   frmsg:= TStringGrid.Create(frmMon);
   with frmsg do begin
    //SetBounds(512,320,79,79)  
     parent:= frmMon;
     Left:= 512; Top:= 320;
     Width:= 79; Height:= 79;
     ColCount:= 4
     DefaultColWidth:= 18
     DefaultRowHeight:= 18
     FixedCols:= 0
     RowCount:= 4
     FixedRows:= 0
   end;
  with TJvAnalogClock.Create(frmMon) do begin 
    parent:= PanR;
    bevelwidth:= 0;
    colormin:= clblue;
    //timeoffSet:= -60;
    align:= alclient;
    ColorHr:= clRed;
    //WidthHandHr:= 1;
    ColorHandHr:= clRed;
    ColorHandMin:= clRed;
    setBounds(28,5,100,100);
    //centercol:= clyellow; //cldarkblue32; //clwebgold; 
    //centersize:= 8;
  end;  
   with TLabel.Create(frmMon) do begin
      Parent:= PanR;        
      SetBounds(18,140,50,18)
      Caption:= 'Progress:'
      bringtofront;
    end;
    with TLabel.Create(frmMon) do begin
      Parent:= PanR;        
      SetBounds(18,167,50,18)
      Caption:= 'Games:'
    end;
    with TLabel.Create(frmMon) do begin
      Parent:= PanR;        
      SetBounds(18,290,50,18)
      Caption:= 'Navigation:'
   end;
   stat:= TStatusbar.Create(FrmMon);
   with Stat do begin
     parent:= frmMon;
     stat.SimplePanel:= true;
   end;
   Progress:= TProgressBar.Create(frmMon);
   with progress do begin
     parent:= frmMon;
     Align:= alBottom;
     TabOrder:= 2;
     //step:= 10;
     Max:= maxSteps+20;
   end;
end; 

///////////////////////////////////////////////////////////////////////////////
//////////////////////// 4 Gewinnt App ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
{*****************************************************}
{ 4Gewinnt Game  "the fantastic four"                 }
{ RECHNER.INC: Include-File mit der implementierten   }
{              Strategieroutine für 4GEWINNT.PAS      }
{ --------------------------------------------------- }
{ Autor       : Max Kleiner T-Ask                     }
{ Lang        : Borland Pascal for Win  
  loc's= 616  : 1995 - 2012  remake for maXbox        }
{*****************************************************}

//Task: Set an event-handler for On_Maximize and On_Minimize to reDraw the Game!

Const { maximale Bewertung }
      Unendlich = 32000;
      { Wert einer Reihe wo schon drei Steine einer Farbe sind}
      Wert2 = 8;
      { Wert einer Reihe wo schon zwei Steine einer Farbe sind}
      Wert3 = 30;
      N                    = 6;       //N * M   row * col
      M                    = 7;       //col
      BLAU                 = 1;
      ROT                  = 10;
      BORDER               = 20;
      BSUM                 = 256;

 Type
      { Rechentiefe für die einzelnen Spielstärken }
      TRechentiefe = Array[0..3] Of Integer;
      TZeilenVektor = array[1..M] of Integer;    //Row inside
      TSpielMatrix = array[1..N] of TZeilenVektor;
  
      { Wert der Stein Position - Stone Position Value SPV }
      {PosWert : SpielMatrix = ((3, 4, 5, 7, 5, 4, 3),
                               ( 4, 6, 8,10, 8, 6, 4),
                               ( 5, 8,11,13,11, 8, 5),
                               ( 5, 8,11,13,11, 8, 5),
                               ( 4, 6, 8,10, 8, 6, 4),
                               ( 3, 4, 5, 7, 5, 4, 3));}
                               
 var  deepc: TRechentiefe;                           
      SM, SpM, p: TSpielMatrix;
      ZA, Count:  TZeilenVektor;
      Drei_Rot, Drei_Blau, Ende, Equal, compute,
                      Sieg_Rot, Sieg_Blau, ChangeColor: Boolean;
      RWert: Array[0..40] of Integer;
      CompStart, Best, Delta, StX, StY, L1, Color: Integer;
      Abbruch: Boolean;    
      ipForm: TForm;   // _4Gewinnt: TVierGewinnt;
      Grad: Byte;
      iScore: Longint;

 
procedure WMRechner; forward;

procedure initMatrix;
begin
  deepc[0]:= 4;   deepc[1]:= 4;
  deepc[2]:= 5;   deepc[3]:= 6;
  
  //ZeilenVektor = (4,3,5,2,6,7,1);
  ZA[1]:= 4; ZA[2]:= 3; ZA[3]:= 5;
  ZA[4]:= 2; ZA[5]:= 6; ZA[6]:= 7; ZA[7]:= 1;

  p[1][1]:=3; p[1][2]:=4; p[1][3]:=5;  p[1][4]:=7;  p[1][5]:=5;  p[1][6]:=4; p[1][7]:=3;
  p[2][1]:=4; p[2][2]:=6; p[2][3]:=8;  p[2][4]:=10; p[2][5]:=8;  p[2][6]:=6; p[2][7]:=4;
  p[3][1]:=5; p[3][2]:=8; p[3][3]:=11; p[3][4]:=13; p[3][5]:=11; p[3][6]:=8; p[3][7]:=5;
  p[4][1]:=5; p[4][2]:=8; p[4][3]:=11; p[4][4]:=13; p[4][5]:=11; p[4][6]:=8; p[4][7]:=5;
  p[5][1]:=4; p[5][2]:=6; p[5][3]:=8;  p[5][4]:=10; p[5][5]:=8;  p[5][6]:=6; p[5][7]:=4;
  p[6][1]:=3; p[6][2]:=4; p[6][3]:=5;  p[6][4]:=7;  p[6][5]:=5;  p[6][6]:=4; p[6][7]:=3;
end;

Procedure T4GwWindow_Anfaenger;   //cm prototype 1995!
Begin
  {MyMenu:= GetMenu(HWindow);
  CheckMenuItem(MyMenu,cm_Anfaenger+Grad,
                mf_ByCommand+mf_Unchecked);
  Grad:= 0;}
End;


Function Auswertung(stufe: integer; rs: byte): integer;
var BW: integer;
Begin
  Drei_Rot:= rS=30;
  Drei_Blau:= rS=3;
  If rS>1 Then
    If rS=40 Then Begin
      result:= -30000-Stufe;
      If Stufe=100 Then
        result:= -Unendlich;
      Ende:= True;
    End Else
    If rS=4 Then Begin
      result:= 30000+Stufe;
      If Stufe=100 Then
        result:= Unendlich;
      Ende:= True;
    End Else
      BW:= BW + RWert[rS];
     //Inc(BW,RWert[S]);
End;

{-----------------------------------------------------}
{*****************************************************}
{ T4GwWindow.Rechner: Reaktion auf Meldung wm_rechner }
{                     In dieser Routine wird der Zug  }
{                     für den Computer mit Hilfe      }
{                     Minimaxstrategie und AlphaBeta- }
{                     Abschneidung ermittelt.         }
{*****************************************************}
{*****************************************************}
{ Mit Hilfe dieser Funktion wird die jeweilige Spiel- }
{ stellung bewertet.                                  }
{*****************************************************}

Function Bewertung(Stufe: Integer): Integer;
Var BW, S, i, j, k, Help: Integer;
  {-------------------------------------------------}
  { Hilfsprozedur zur Auswertung der Spielstellung  }
  {-------------------------------------------------}
Begin
  BW:= 0;
  {-------------------------------------------------}
  { Bewertungskriterium 1:                          }
  {   Werte der einzelnen Spielsteinpositionen      }
  {-------------------------------------------------}
  For j:= 1 To M Do
    For i:= 1 To Count[j] Do Begin
      If SM[i][j]=1 Then
        BW:= BW+P[i][j];
      If SM[i][j]=10 Then
        BW:= BW-P[i][j];
    End;
  {-------------------------------------------------}
  { Bewertungskriterium 2:                          }
  {   Bewertung der jeweiligen Zweier-, Dreier- und }
  {   Viererreihen der Spielstellung                }
  {-------------------------------------------------}
  Ende:= False;

  {-------- senkrechte Reihen --------}
  For j:= 1 To M Do Begin
    Help:= Count[j];
    If Help>3 Then Help:= 3;
    For i:= 1 To Help Do Begin
      S:= SM[i][j]+SM[i+1][j]+SM[i+2][j]+SM[i+3][j];
      result:= Auswertung(stufe,S);
      If Ende Then Exit;
      If Drei_Rot Then
        For k:= 0 To 3 Do
          If SM[i+k][j]=0 Then
            If i+k And 1=CompStart Then
              BW:= BW-RWert[3];
              //Dec(BW,RWert[3]);
      If Drei_Blau Then
        For k:= 0 To 3 Do
          If SM[i+k][j]=0 Then
            If i+k And 1=1-CompStart Then
              BW:= BW + RWert[3];
              //Inc(BW,RWert[3]);
    End; //for
  End; //for

  {-------- waagrechte Reihen --------}
  For j:= 1 To M-3 Do
    For i:= 1 To N Do Begin
      S:= SM[i][j]+SM[i][j+1]+SM[i][j+2]+SM[i][j+3];
      result:= Auswertung(stufe,S);
      If Ende Then Exit;
      If Drei_Rot And (j>1) Then
        If j And 1=CompStart Then
          BW:= BW-3*RWert[3];
          //Dec(BW,3*RWert[3]);
      If Drei_Blau And (j>1) Then
        If j And 1=1-CompStart Then
          BW:= BW + 3*RWert[3];
          //Inc(BW,3*RWert[3]);
    End;
  {-------- diagonale Reihen --------}
  For i:= 1 To N-3 Do
    For j:= 1 To M-3 Do Begin
      S:= SM[i][j]+SM[i+1][j+1]+SM[i+2][j+2]+SM[i+3][j+3];
      result:= Auswertung(stufe,S);
      If Ende Then Exit;
      If Drei_Rot Then
        For k:=0 To 3 Do
          If SM[i+k][j+k]=0 Then
            If i+k And 1=CompStart Then
              BW:= BW - 2*RWert[3];
              //Dec(BW,2*RWert[3]);
      If Drei_Blau Then
        For k:=0 To 3 Do
          If SM[i+k][j+k]=0 Then
            If i+k And 1=1-CompStart Then
              BW:= BW-2*RWert[3];
              //Inc(BW,2*RWert[3]);
      S:= SM[i+3][j]+SM[i+2][j+1]+SM[i+1][j+2]+SM[i][j+3];
      result:= Auswertung(stufe,S);
      If Ende Then Exit;
      If Drei_Rot Then
        For k:=0 To 3 Do
          If SM[i+3-k][j+k]=0 Then
            If i+3-k And 1=CompStart Then
              BW:= BW-2*RWert[3];
      If Drei_Blau Then
        For k:= 0 To 3 Do
          If SM[i+3-k][j+k]=0 Then
            If i+3-k And 1=1-CompStart Then
              BW:= BW+2*RWert[3];
    End; //for
  result:= BW;
End;

{*****************************************************}
{ Ermittlung des besten Zuges für den Computer mit    }
{ Hilfe der MiniMax-Strategie und dem AlphaBetaCut    }
{ Diese rekursive Funktion liefert schließlich den    }
{ Wert der Spielstellung zurück. Der beste Spielzug   }
{ ist dann in der Variable Bester abgelegt.           }
{*****************************************************}

Function MiniMax(Wert,Tiefe,Alpha: Integer): Integer;
Var i,j, Help, Zug, Beta: Integer;
             AlphaBetaCut: Boolean;
Begin
  If Not Abbruch Then Begin
    If (Abs(Bewertung(Tiefe+1))>=29000) OR
       (Count[1]+Count[2]+Count[3]+Count[4]+
        Count[5]+Count[6]+Count[7]>= 42) Then
      result:= Bewertung(Tiefe+1)
    Else Begin
      {While PeekMessage(HMsg,HWindow,0,0,pm_Remove) Do
        If (HMsg.Message=wm_SysCommand) And
           (HMsg.WParam=sc_Close) Then Abbruch:=True
        Else while Application.ProcessMesages do
         //Abbruch:= true; }
      If Wert=1 Then
        Beta:= -Unendlich
      Else
        Beta:= Unendlich;
      Zug:= 0;
      AlphaBetaCut:=False;
      If Tiefe>0 Then Begin
        For i:= 1 To M Do Begin
          j:= ZA[i];
          If (Count[j]<N) AND NOT AlphaBetaCut Then Begin
            Inc(Count[j]);
            SM[Count[j]][j]:= Wert;
            If Tiefe>1 Then
              Help:= MiniMax(Blau+Rot-Wert,Tiefe-1,Beta)
            Else
              Help:= Bewertung(Tiefe);
            SM[Count[j]][j]:= 0;
            Dec(Count[j]);
            If Wert=Blau Then Begin
              If Help>Beta Then Begin
                Beta:= Help;
                Zug:= j;
              End;
              If Beta>Alpha Then
                AlphaBetaCut:=True;
            End
            Else Begin
              If Help<Beta Then Begin
                Beta:= Help;
                Zug:= j;
              End;
              If Beta<Alpha Then
                AlphaBetaCut:= True;
            End;
          End; //If
        End; //For
        result:= Beta;
      End //If
      Else result:= Bewertung(Tiefe+1);
      ipForm.Canvas.TextOut(3, BORDER+1, 'Think Level: '+intToStr(Tiefe));
    End;
   Best:= Zug;
  End;
End;

{**************************************************************}
{ Hilfsfunktion zur Bestimmung, ob das Spiel noch weiter geht  }
{**************************************************************}
Function SpielEnde: Boolean;
Begin
  result:= True;
  If Bewertung(100)<=-Unendlich Then
    Sieg_Rot:= True
  Else
    If Bewertung(100)>=Unendlich Then
      Sieg_Blau:= True
  Else
    If Count[1]+Count[2]+Count[3]+Count[4]+
         Count[5]+Count[6]+Count[7]= N*M Then
           Equal:= True
    Else
      result:= False;
End;

/////from main game form
Function FarbWert(W: Word): TColorRef;  //TColor?
Begin
  Case W Of
    0: result:= RGB2TColor($BF,$BF,$BF);
    1: result:= RGB2TColor($00,$00,$00);
    2: result:= RGB2TColor($FF,$FF,$FF);
    3: result:= RGB2TColor($FF,$00,$ff);
    4: result:= RGB2TColor($00,$00,$00);
    5: result:= RGB2TColor($00,$00,$FF);
    6: result:= RGB2TColor($F7,$00,$00);
    7: result:= RGB2TColor($7F,$7F,$7F);
  End;
End;


Procedure Reset;
Var i,j: Integer;
Begin
  compute:= False;
  Sieg_Rot:= False;
  Sieg_Blau:= False;
  Equal:= False;
  For i:= 1 To N Do
    For j:= 1 To M Do SpM[i][j]:= 0;
  For j:= 1 To M Do Count[j]:= 0;
  Delta:= 0;
End;


Procedure WM_SetzeStein(wparam, lparam: integer);
Var //DC: HDC;
    XPos, YPos, X, Y: Integer;
Begin
  Y:= 7-wParam Mod BSUM;
  X:= wParam Div BSUM;
  XPos:= StX+(X-1)*L1+2;
  YPos:= StY+(Y-1)*L1+2;
  //DC:=GetDC(HWindow);
    if changeColor then 
      ipForm.Canvas.brush.Color:= FarbWert(lparam+2)
    else
      ipForm.Canvas.brush.Color:= FarbWert(lparam+color);
   //SelectObject(DC,Brush);
   ipForm.Canvas.Ellipse(XPos,Ypos,Xpos+L1-3,Ypos+L1-3);
   //ipForm.Canvas.TextOut(xpos,ypos,inttostr(p[y][x])); //debug the values
   //ReleaseDC(HWindow,DC);
End;

//********************** Set the Game Board Form *****************************     
Procedure Spielfeld;
Var NRect: TRect;
    Breite, Hoehe, i: Integer;
Begin
  //ipForm.canvas.GetClientRect(HWindow,Rect);
  //DC:=GetDC(HWindow);
  with ipForm.Canvas do begin
    brush.color:= FarbWert(0+color);
    NRect:= Rect(0,0,ipForm.width-BORDER,ipForm.height-(2*BORDER));
    FillRect(NRect);
    Breite:= (NRect.Right-BORDER) Div M;
    Hoehe:= (NRect.Bottom-(2*BORDER)) Div N;
    If Breite>Hoehe Then L1:= Hoehe Else L1:= Breite;
    Brush.color:= FarbWert(3+color);
    StX:= (NRect.Right-L1*M) Div 2;
    StY:= (NRect.Bottom-L1*N) Div 2;
    Rectangle(StX,StY,L1*M+StX+1,L1*N+StY+1);
    For i:= 1 To M-1 Do Begin
      MoveTo(L1*i+StX,StY);
      LineTo(L1*i+StX,StY+L1*N);
    End;
    For i:= 1 To N-1 Do Begin
      MoveTo(StX,L1*i+StY);
      LineTo(L1*M+StX,L1*i+StY);
    End;
  End; //with  
  //Sbutton.top:= ipForm.height-4*BORDER; debug
  //ReleaseDC(HWindow,DC);
End;

Procedure Gewonnen;
Var mRect: TRect; GMsg: PChar;
Begin
  GMsg:='';
  If Sieg_Rot Then GMsg:='  Wow Gratulation to win!!';
  If Sieg_Blau Then GMsg:='  Sorry, You lost!';
  If Equal Then GMsg:='  Same for two ';
  If Sieg_Rot Or Sieg_Blau Or Equal Then Begin
    //GetClientRect(HWindow,Rect);
    mRect.Bottom:= BORDER;
    //Showmessage(GMsg);  //debug
    ipForm.Canvas.TextOut(3, mrect.bottom-BORDER+5, GMsg);
  End;
End;


//**************************** Event Handler ******************************
Procedure aWM_Paint(Sender: TObject);
Var i, j: Word;
Begin
  Color:= 4;
  Spielfeld;
  For i:= 1 To M Do
    For j:= 1 To Count[i] Do Begin
      If SpM[j][i]=Rot Then 
         WM_Setzestein(i*BSUM+j,2);
      If SpM[j][i]=Blau Then
         WM_Setzestein(i*BSUM+j,1);
    End;
  Gewonnen;
End;

procedure FormCloseClick(Sender: TObject; var Action: TCloseAction);
begin
  //myImage.Free;
  Writeln('4Gewinnt Form Closed at: '+ TimeToStr(Time));
  //pFrm.Free;
  Abbruch:= True;
  Screen.Cursor:= crDefault;
  Action:= caFree;
end;

     
//Procedure WMMouseMove;
procedure GewinntMouseMove(Sender: TObject; Shift: TShiftState; X,Y: Integer);
Var XPos, X1: Integer;
    Help1, Help2: Integer;
begin
  If Not compute Then Help1:= crArrow
    Else Help1:= crHourglass;
  If Not compute Then Help2:= crCross  //idc_cross
    Else Help2:= crHourglass;
  XPos:= X;
  If (XPos>StX) AND (XPos<StX+M*L1) AND NOT
     (Sieg_Rot OR Sieg_Blau Or Equal) Then
     Begin
       X1:=(XPos-StX) Div L1+1;     //shows possible move
       If X1>7 Then X1:= 7;
       If X1<1 Then X1:= 1;
       If Count[X1]<N Then Screen.Cursor:= Help2
         Else Screen.Cursor:= help1   //SetCursor(LoadCursor(0,Help1));
     End
  Else Screen.Cursor:= help1;
End;

//Procedure T4GwWindow.WMLButtonDown;
procedure MouseDownLeft(sender: TObject; Button: TMouseButton; 
                          Shift: TShiftState; X, Y: Integer);
Var XPos, X1, cntint: Word;
Begin
  XPos:= X;  
  If (XPos>StX) AND (XPos<StX+M*L1) AND NOT
    (Sieg_Rot OR Sieg_Blau OR Equal) Then
  Begin
    X1:= (XPos-StX) Div L1+1;
    If X1> M Then X1:= M;
    If X1< 1 Then X1:= 1;
    If Count[X1] < N Then Begin
      Inc(Count[X1]);
      If Count[X1]= N Then Inc(Delta);
      cntint:= Count[X1]
      SpM[cntint][X1]:= Rot;
      WM_Setzestein(X1*BSUM+Count[X1],2);
      WMRechner; //Bewertung, Auswertung(1);
    End;
  End;
End;
    

Procedure InitGame;
Begin
  //TWindow.Init(NIL,AName);
  //Attr.Menu:=LoadMenu(HInstance,'MENU');
  Grad:= 1;         //levels 0 - 3;  3 as Expert
  CompStart:= 1;
  changeColor:= false;
  Reset;
End;

procedure iButtonReset(sender: TObject);
begin
  InitGame;
  Spielfeld;
end;  

procedure EChangeColor(sender: TObject);
begin
  changeColor:= NOT changeColor;
end; 

procedure EChangeLevel(sender: TObject);
begin
  Grad:= 3;  //highest level 
end;  


procedure iFormTCreate(Sender: TObject);
//var label1: TLabel; bevel1,bevel2: TBevel;  for future expansion
var mi, mi1, mi2: TMenuItem;
    mt: TMainMenu; 
    sbutton: TButton;
begin
  //SetFigures;
  //RedrawSheet:= True;
  {bevel1:= TBevel.create(ipForm)
  bevel1.parent:= ipForm;
  bevel2:= TBevel.create(ipForm)
  bevel2.parent:= ipForm;
  label1:= TLabel.create(ipForm)
  label1.parent:= ipForm;}

  ipForm:= TForm.Create(self);   //constructors
  sButton:= TButton.Create(ipForm)
  with ipform do begin
    caption:= '4Gewinnt GameBox 2012';  
    //BorderStyle:= bsDialog;
    Position:= poScreenCenter;
    onMouseDown:= @MouseDownLeft;
    onMouseMove:= @GewinntMouseMove;
    onPaint:= @aWM_Paint;
    onClose:= @FormCloseClick;
    //KeyPreview:= true;
    ClientWidth:= ipform.Width+150; 
    ClientHeight:= ipform.height+150;
    Show;
  end;  
  with SButton do begin
    parent:= ipform;
    caption:= 'Reset'
    top:= ipform.height-4*BORDER-5;
    width:= 4*BORDER;
    onclick:= @iButtonReset;
  end; 
  mt:= TMainMenu.Create(ipform)
  with mt do begin
   //parent:= frmMon;
  end;  
  mi:= TMenuItem.Create(mt)
  mi1:= TMenuItem.Create(mt)
  mi2:= TMenuItem.Create(mt)
  with mi do begin
    //parent:= frmMon;
    Caption:='New Game';
    Name:='ITEM';
    mt.Items.Add(mi);   
    OnClick:= @iButtonReset;
  end;
  with mi1 do begin
    //parent:= frmMon;
    Caption:='Change Color';
    mt.Items.Add(mi1) ;
    OnClick:= @EChangeColor
  end;
  with mi2 do begin
    //parent:= frmMon;
    Caption:='High Level';
    mt.Items.Add(mi2);
    OnClick:= @EChangeLevel;
  end;
  Spielfeld;
  //Grad:= 1;
  iScore:= 0;
end;

{*****************************************************}
{      Hauptteil der Methode T4GwWindow.Rechner       }
{*****************************************************}
//Procedure T4GwWindow_Rechner;

procedure WMRechner;
var i,j: Integer;   // from Rechner
begin
  For i:=0 To 40 Do RWert[i]:= 0;
  RWert[3]:= Wert3;
  RWert[30]:= -Wert3;
  RWert[2]:= Wert2;
  RWert[20]:= -Wert2;
  SM:= SpM;
    {for I:= 1 to N do
      for j:= 1 to M do SM[i][j]:= SpM[i][j];}
  If Not SpielEnde Then Begin
    Screen.Cursor:= crHourglass;//SetCursor(LoadCursor(0,idc_wait));
    compute:= True;
    Abbruch:= False;
    MiniMax(Blau, deepc[Grad]+Delta,Unendlich);
    If Abbruch Then Showmessage('PostQuitMessage(0) or Game Closed')
    Else
    If (Count[Best]<N) AND (Best>0) Then Begin
      Inc(Count[Best]);
      If (Count[Best]=N) AND (Grad>0) Then
        Inc(Delta);
      SpM[Count[Best]][Best]:= Blau;
      WM_Setzestein(Best*BSUM+Count[Best],Blau);
      SM:= SpM;  //!
    End; //If
  End;
  SpielEnde;
  Gewonnen;  //SendMessage(HWindow,wm_gewonnen,0,0);
  compute:= False;
  //SetCursor(LoadCursor(0,idc_arrow));
  Screen.Cursor:= crArrow;
end;

Procedure InitComputerStart;
Begin
  Reset;
  CompStart:= 1;
  WMRechner;
End;

///////////////////////////////////////////////////////////////////////////////
//////////////////////// Memory Picture App ///////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

{ 
  Project  : maXbox Memory Game
  Unit Name: maXGame 185_memorymax2.txt
  Purpose  : Find all the 2 same Picture  
  Date  : 03/02/2011  -  22:54:56 , loc's = 2250
  History  : translate and integrate from delphi to mX3
           : include linking stringGrid and drawGrid 
  ToDo     : timer with statistic of 4 players and stop scrolling
 }          
// *********************************
// array is 5 * 8 = 40  (0..4)*(0..7)
// pictures are 37 files

const TotalPictures = 37;
      CROW = 4;
      CCOL = 7;
      MAXFOUND = 20;
      MAXMEM = 40;
      DECK = 'deck2.bmp';
      EMPTYCARD = 'empty.bmp';
      FILE_NAME = 'memory3.ini';     
      RESPATH ='examples\images\';         //path to memory --> examples
      
type  TMap = array[0..CROW] of integer;     
      TDisplay = array[0..CROW] of integer;     
      TShowCard = array[0..CROW] of integer;     
var  
    Bmp: TBitmap;
    Map: array[0..CCOL] of TMap;
    Display: array[0..CCOL] of TDisplay;
    ShowCard: array[0..CCOL] of TShowCard;
    FirstShot, AllCards, Play: Boolean;
    mForm: TForm;
    shotsLbl: TLabel;
    DrawGrid1: TDrawGrid;  
    StGames, StShots, StSeconds, StScore,
    Seconds, Shots, aascore, Founds, FSValue,
    Col1, Row1, Col2, Row2, Turn: integer;
    MIni: TIniFile;
    Imagefile, DeckColor, Wow, Name1, Name2: String;
    TopName, TopScore, TopSeconds, TopShots: Array[1..5] of String;

{procedure Exit1Click(Sender: TObject);
begin
  Close;
end;}

procedure ShowAllCards1Click(Sender: TObject);
var i,j : integer;
begin
  for i:= 0 to CCOL do
   for j:= 0 to CROW do
    ShowCard[i][j]:= 1;
  AllCards:= True;
  Play:= True;
  DrawGrid1.Repaint;
end;

procedure New1Click(Sender: TObject);
var i,j,k,num,maxc,r: Integer;
    CanProceed: Boolean;
    a: array [1..MAXFOUND] of Integer;
    c,d: array [1..MAXMEM] of Integer;
begin
  Seconds:= 0;
  Shots:= 0;
  Founds:= 0;
  aascore:= 0;
  {TimeLabel.Caption:= 'Seconds: 0';
   aascoreLabel.Caption:= 'aascore: 0';}
  ShotsLbl.Caption:= 'Total Hits: 0';
  FirstShot:= True;
  AllCards:= False;
  Play:= True;
  for i:= 0 to CCOL do
  for j:= 0 to CROW do begin
    Display[i][j]:= 1;
    ShowCard[i][j]:= 0;
  end;
  DrawGrid1.Repaint;
  //creation of array of cards:
  //step 1 - random selection of 25 cards from the total
  for j:= 1 to MAXFOUND do begin
    repeat
      num:= Random(TotalPictures)+1;
      CanProceed:= True;
      for i:= 1 to j do
        if a[i]= num then begin
          CanProceed:= False;
          Break; //exit the loop
        end;
    until CanProceed;
   a[j]:= num;
  end;
  //step 2 - creation of a 40 cards array
  for i:= 1 to MAXFOUND do begin
    c[i]:= a[i];
    c[i+MAXFOUND]:= a[i];
  end;
  // step 3 - random sort of the array
  maxc:= MAXMEM;
  for i:= 1 to MAXMEM do begin
    r:= random(maxc)+1;
    d[i]:= c[r];
    for k:= r to (maxc-1)  // moving back c[] elements
      do c[k]:= c[k+1];
    Dec(maxc);
  end;
  // step 4 - creation of a two-dimension array (Map)
  // d[k] has each number from two same number pair
  k:= 1;
  for i:= 0 to CCOL do
    for j:= 0 to CROW do begin
      Map[i][j]:= d[k];
      write(inttostr(d[k])+' ')
      Inc(k);
    end;
end;


procedure DrawGrid1MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var Col, Row: Integer;
begin
  DrawGrid1.MouseToCell(X, Y, Col, Row);
  // if left button is pressed on an active card
  if (Button = mbLeft) and (Display[Col][Row] = 1) and Play then begin
    ShowCard[Col][Row]:= 1;
    // second shot
    if (not FirstShot) and ((Col<>Col1) or (Row<>Row1))then begin
      Play:= False;
      Row2:= Row;
      Col2:= Col;
      FirstShot:= True;
      // same cards
      if Map[Col][Row] = FSValue then begin
        Inc(Founds);
        // end of game
        if Founds = MAXFOUND then begin
          Inc(Shots);
          ShotsLbl.Caption:= 'Total hits: '+IntToStr(Shots);
          PlaySound(ExePath+RESPATH+'bonus.wav',0,1);
          ShowMessage('End of mgame!'+#13+'aascore: '+IntToStr(Shots));
          // statistics
          Inc(StGames);
          Play:= true;
          StScore:= StScore+aascore;
          StShots:= StShots+Shots;
          Display[Col1][Row1]:= 0;
          Display[Col2][Row2]:= 0;
        end;
        Dec(Turn);
       PlaySound(ExePath+RESPATH+'tick.wav',0,1);
      end;
    end
    // first shot
    else begin
    // fsvalue to check a hit
      FSValue:= Map[Col][Row];
      Col1:= Col;
      Row1:= Row;
      FirstShot:= False;
    end;
  end
  // if right button is pressed after 2nd shot
  else if (Button=mbRight) and FirstShot and (not Play) and not AllCards then begin
    Inc(Shots);
    Play:= true;
    ShotsLbl.Caption:= 'Total hits: '+IntToStr(Shots);
    //test of all cards
    ShowCard[Col1][Row1]:= 0;
    ShowCard[Col2][Row2]:= 0;
    // when hit then dont show the two cards
    if Map[Col1][Row1] = Map[Col2][Row2] then begin
      Display[Col1][Row1]:= 0;
      Display[Col2][Row2]:= 0;
    end;
  end;
  DrawGrid1.Repaint;
end;


procedure DrawGrid1DrawCell(Sender: TObject; Col, Row: Integer;
  Rect: TRect; State: TGridDrawState);
begin
  // drawing the correct card...
  if Display[Col][Row] = 1 then begin
    if ShowCard[Col][Row] = 1 then begin
        Imagefile:= ('bmp' + IntToStr(Map[Col][Row])+'.bmp');
      bmp.loadfromFile(ExePath+RESPATH+Imagefile)
    end else
     Bmp.loadfromFile(ExePath+RESPATH+DECK)
  end
  //...or no card.
  else 
    Bmp.loadfromFile(ExePath+RESPATH+EMPTYCARD);
  DrawGrid1.Canvas.Draw(Rect.Left, Rect.Top, Bmp);
end;


procedure FormClose(Sender: TObject; var Action: TCloseAction);
var i: integer;
begin
  Bmp.Free;
  DrawGrid1.Free;
  with MIni do begin
    WriteString('Stat', 'StGames', IntToStr(StGames));
    WriteString('Stat', 'StShots', IntToStr(StShots));
    WriteString('Stat', 'StSeconds', IntToStr(StSeconds));
    WriteString('Stat', 'StScore', IntToStr(StScore));
    WriteString('Deck','Current', DeckColor);
    for i:= 1 to 5 do begin
      WriteString('Best players','TopName'+IntToStr(i),TopName[i]);
      WriteString('Best players','TopScore'+IntToStr(i),TopScore[i]);
      WriteString('Best players','TopSeconds'+IntToStr(i),TopSeconds[i]);
      WriteString('Best players','TopShots'+IntToStr(i),TopShots[i]);
    end;
    WriteString('Best max players','Wow',Wow);
    Free;
  end;
end;


procedure FormCreate(Sender: TObject);
var i: integer;
    file_path: string;
begin
  // INI file
  //GetMem(WinDir, 144);
  //GetWindowsDirectory(WinDir, 144);
  //StrCat(WinDir, '\Memory.ini');
  if not FileExists(FILE_NAME) then begin
    AssignFileWrite(memo2.text, FILE_NAME);
  end;
  file_path:= extractFilePath(application.ExeName) +FILE_NAME;
  MIni:= TIniFile.Create(file_path);
  with MIni do begin
    // statistics vars
    StGames:= StrToInt(ReadString('Stat','StGames','0'));
    StScore:= StrToInt(ReadString('Stat','StScore','0'));
    StShots:= StrToInt(ReadString('Stat','StShots','0'));
    StSeconds:= StrToInt(ReadString('Stat','StSeconds','0'));
    DeckColor:= ReadString('Deck','Current','Blue');
    for i:= 1 to 5 do begin
      TopName[i]:= ReadString('Best players','TopName'+IntToStr(i),'Noname');
      TopScore[i]:= ReadString('Best players','TopScore'+IntToStr(i),'0');
      TopSeconds[i]:= ReadString('Best players','TopSeconds'+IntToStr(i),'0');
      TopShots[i]:= ReadString('Best players','TopShots'+IntToStr(i),'0');
    end;
    Wow:= ReadString('Best players','Wow','I like Super Memory!');
  end;
  //FreeMem(WinDir, 144);
  //startup initializations
  Randomize;
  Bmp:= TBitmap.Create;
  mForm:= TForm.create(self);
  shotsLbl:= TLabel.create(mForm);
  with mForm do begin
    //FormStyle:= fsStayOnTop;
    Position:= poScreenCenter;
    color:= clred;
    Caption:= 'MemoryMax in maXbox3: open left, close right mouse click';
    Width:= 900;
    Height:= 650;
    BorderStyle:= bsDialog;
    onClose:= @FormClose;
    Show
  end;
  with shotsLbl do begin
    parent:= mForm;
    setbounds(30,600,180,20);
    font.size:= 12;
    font.color:= clyellow;
    caption:= 'hits:';
  end;  
  drawGrid1:= TDrawGrid.Create(self);
  drawGrid1.parent:= mForm;
  with drawGrid1 do begin
    defaultcolwidth:= 104;
    defaultrowheight:= 104;
    height:= 560;
    width:= 900;       //1094
    colcount:= CCOL+1;  //buggg solved!!!
    rowcount:= CROW+8;
    top:= 20;
    borderStyle:= bsNone;
    GridLineWidth:= 8;
    scrollbars:= false;
    ondrawcell:= @DrawGrid1DrawCell;
    onMouseUp:= @DrawGrid1MouseUp;
  end;
  New1Click(Self);
end;

procedure TetrisMsgHandler(var Msg: TMsg; var Handled: Boolean);
var
  ActiveControl: TWinControl;
  key : word;
begin
  if (Msg.message = WM_KEYDOWN) then
    begin
      ActiveControl := Screen.ActiveControl;
      // if the active control inherits from TButton, intercept the key.
      // add other controls as fit your needs 
      //if not ActiveControl.InheritsFrom(TButton)
        //then Exit;
      key := Msg.wParam;
      Handled := true;
      case Key of // intercept the wanted keys
        VK_DOWN : ; // doStuff
        VK_UP : ; // doStuff
        VK_LEFT : ; // doStuff
        VK_RIGHT : ; // doStuff
        else Handled := false;
      end;
   end;
end;

 
//main of four Games
begin
//**************************** mX3 Game Series 4 *******************************
  //loadPForm();
  ProcessMessagesOFF;
  
   //Memory
  FormCreate(self)
 //ShowAllCards1Click(self)
 
  //Picture Puzzle
  InitNavArray;
  InitCreateForms;
  loadImage;    //default
  btnNewPicClick(Self);
  
  //4 Gewinnt
  initMatrix;
  initGame;
  iFormTCreate(self);
  WMRechner;
  
  //Tetris
  FormTCreate(self);
  //Application.OnMessage:= @TetrisMsgHandler;

  PrintF('DiskSize: %d DiskFree: %d',[disksize(3) div 1024
                        , diskfree(3) div 1024]);

  //initPuzzle();
  //testVerify
end.
//
         ____    ___   _      ____    _   _   _
        |  _ \  |  _| | |    |  _ \  | | | | | |
        | | . | | |_  | |    | |_| | | |_| | | |
        | | | | |  _| | |    |  __/  |  _  | | |          
        | |_. | | |_  | |__  | |     | | | | | |                      
        |____/  |___| |____| |_|     |_| |_| |_| 
          

TestSequence:
    RedrawSheet := False;
    SetFigures;
    GenerateNewFigure;
    putfigureintoGlass(mddown);
    //Timer1.Enabled := True;
    FormPaint(Self);
    RedrawSheet := True;

// Reset Procedure

procedure SpeedButton7Click(Sender: TObject);
var
  I,J: Byte;
begin
  Timer1.Enabled := False;
  ClearFigureIntoGlass;
  FigureActive := False;
  Level := 1;
  iscore := 0;
  for I := 1 to GlassHeight do
    for J := 1 to GlassWidth do GlassWS[I,J] := 0;
  RedrawSheet := False;
  FormPaint(Self);
  RedrawSheet := True;
  Timer1.Enabled := True;
end;


//The Delphi function StrToInt for string-to-integer conversions generates an exception if the given string does not represent a valid integer. Examples: StrToInt('ABC') or StrToInt('1.5'). That's a nice thing for the automatic validation of user input: if you try to convert an invalid value that was entered, such as into an Edit box, then Delphi automatically displays an error message.

But sometimes you don't want this behaviour, especially when you want to convert several strings into integer numbers, such as the stuff entered in a bunch of Edit boxes, or the strings of a StringGrid, a ListBox,... Then it would be annoying to show an error message for every conversion that goes wrong -- imagine 100 error messages, and each time the user has to click a button to close the dialog window :p

If you use StrToIntDef (string-to-integer-default) instead, you'll never get an exception. If the string is invalid, then this function will return the default value that you provided. Example: StrToIntDef('ABC', 0) returns 0.

Here's a simple source code example, using a TEdit and TLabel components:

    The user has to enter the desired amounts of products into several edit boxes. After clicking a button, the amounts are displayed in labels. But if an amount entered is invalid, then act as if 0 was entered:

procedure TForm1.Button1Click(Sender: TObject);
var
  N: integer;
begin
  N := StrToIntDef(EditApples.Text, 0); // if invalid, result is 0
  LabelApples.Caption := IntToStr(N);
  N := StrToIntDef(EditPears.Text, 0);
  LabelPears.Caption := IntToStr(N);
  N := StrToIntDef(EditOranges.Text, 0);
  LabelOranges.Caption := IntToStr(N);

  // and so on...
end;


Note that FillChar fills the buffer with Byte values now, and no longer with Char values. A beter named function is FillMemory, defined in the Windows unit:

   procedure FillMemory(Destination: Pointer; Length: DWORD; Fill: Byte);
   begin
     FillChar(Destination^, Length, Fill);
   end;
   
TShiftState = set of (ssShift, ssAlt, ssCtrl,
    ssLeft, ssRight, ssMiddle, ssDouble);} 
    
    
OnKeyDown - called when any key on the keyboard is pressed.
OnKeyUp - called when any key on the keyboard is released.
OnKeyPress - called when a key corresponding to an ASCII character is pressed.
     
Problem:
The KEYDOWN event does not get fired for the left/right arrow keys.
When placed on a form with more than one other control, the left and right
 arrow keys move the focus, instead of firing an event.

Solution:
You need to handle WM_GETDLGCODE to tell Windows
what keyboard messages you want to process.

Hi,
Having problem with focus in wpf. Textcontrol lost focus after show a messagebox in keydown event handler and cannot set focus back.Tried textControl.Focus() and Keyboard.Focus(textControl), none of them worked.
Anyone knows how to fix it?
 Specifies whether the form should receive keyboard events before the active control.

If KeyPreview is true, keyboard events occur on the form before they occur on the active control. (The active control is specified by the ActiveControl property.)

If KeyPreview is false, keyboard events occur only on the active control.

Navigation keys (Tab, BackTab, the arrow keys, and so on) are unaffected by KeyPreview because they do not generate keyboard events. Similarly, when a button has focus or when its Default property is true, the Enter key is unaffected by KeyPreview because it does not generate a keyboard events.

KeyPreview is false by default. 

       
----code_cleared_checked----