Program FunctionFun_Truth;

//#net>D1.40DNS: 192.168.1.1; local IPs: fe80::102b:66c2:9557:7a93%10,fe80::39cb:cc4a:b4e7:9e03%20,fe80::25d2:cdb2:b4d2:1291%21,192.168.1.40,192.168.25.1,192.168.18.1; local IP: 192.168.1.401,2001:0:9d38:6abd:1416:333f:43c2:271a; local IP: 192.168.1.40
//TODO: just missing a filestream mime file; search and get one
//TODO: Refactor boolean shorter #locs:407

{uses
  SysUtils,
  Classes;}
  
Const fstreamname = 'streamtest.txt';  
 
var
  fs: TFileStream;
  v: byte;
  vs: string;
  vsf: double;
  i: integer;
  start: LongWord;

function StripString(st: String; CharsToStrip: String): String;
var
  i: Integer;
begin
  result:= '';
  for i:= 1 to Length(st) do begin
    if Pos(st[i], CharsToStrip) = 0 then
      result:= result + st[i];
  end;
end;
 
  
procedure fileStreamOne;
begin
  //fs := TFileStream.Create(&#39;C:\test.txt&#39;, fmOpenWrite);
  //fs:= TFileStream.Create(Exepath+'examples\firstdemo22.txt', fmOpenWrite or fmCreate);
  fs:= TFileStream.Create(Exepath+'examples\firstdemo.txt', fmOpenWrite);
  vs:= '656';
  v:= 64;
  vsf:= 12.3;
  try
    fs.Seek(0, soBeginning);
    fs.WriteBuffer(vs, SizeOf(vs));
    //fs.ReadBufferInt(v, SizeOf(v));
    //fs.WriteBufferInt(v, SizeOf(v));
    //fs.WriteBufferInt(6,1);
    //fs.WriteBufferFloat(vsf,4);
    fs.WriteInt(v,2);
  finally
    fs.Free;
  end;
end;

procedure fileStreamByte;
var I: Integer;
    Buff: Byte;
    FileS: TFilestream;  
begin

Files:= TFileStream.Create(Exepath+'examples\firstdemoBYTE.txt', fmCreate);
try
  //files.Seek(0, soBeginning);
  for I := 0 to 299 do begin
    Buff:= Random(255);
    //FileS.WriteBufferInt(Buff,1);
    FileS.WriteInt(Buff,1);
    end;
  finally
    FileS.Free;
  end;
end;   

//TODO: However, since the file is opened only in write mode (fmOpenWrite), if you try to add fs.ReadBuffer(v, SizeOf(v)); you will have an exception 'Stream Read Error' raised.


//How about the time difference if you use fmOpenReadWrite or fmOpenWrite whichever makes no difference?

procedure fileStreamTwo;
begin
  start := GetTickCount;
  fs := TFileStream.Create('C:\test.txt', fmOpenWrite or fmCreate);
  v := 65;
  try
    fs.Seek(0, soBeginning);
    for i := 0 to 10000000 do begin
      fs.WriteBufferInt(v, SizeOf(v));
    end;
  finally
    fs.Free;
  end;
  Writeln(IntToStr(GetTickCount - start));
  start := GetTickCount;
  fs := TFileStream.Create('C:\test.txt', fmOpenReadWrite or fmCreate);
  v := 65;
  try
    fs.Seek(0, soBeginning);
    for i := 0 to 10000000 do begin
      fs.WriteBufferInt(v, SizeOf(v));
    end;
  finally
    fs.Free;
  end;
  Writeln(IntToStr(GetTickCount - start));
  //Readln; 
end;  

function FileToStringStep(const AFilename: string;
                                 StartPos: Integer; EndPos: Integer): string;
var
  FileStream : TFileStream;
  wlCount: Integer;
begin
  if FileExists(AFilename) then begin
    if StartPos < 0 then
      StartPos := 0;
    FileStream:= TFileStream.Create(AFilename, fmOpenRead or fmShareDenyWrite);
    try
      if (EndPos <= StartPos) or (EndPos > FileStream.Size) then
        EndPos := FileStream.Size;
      wlCount := EndPos - StartPos;
      if FileStream.Size > StartPos then begin
        SetLength(Result, wlCount);
        //FileStream.Seek(StartPos, soFromBeginning);
        FileStream.Seek(StartPos, soBeginning);
        //FileStream.Read(Result[1], wlCount);
        FileStream.Read(Result, wlCount);
      end;
    finally
      FileStream.Free;
    end;
  end
  else
    Result:= '';
    //MessagePlainText
    //MessageHtml_Attach
    ForceDecodeHeader
    
end;

//The timing is roughly the same (but using fmOpenWrite if you intend no read might be a slightly bit faster). 


function IdHttp_DownloadFile(aSrcUrlFile,aDestFile: String; const OnWorkEvent: TWorkEvent): Boolean;
var
  Http: TIdHTTP;
  MS: TMemoryStream;
begin
  Result := false;
  Http := TIdHTTP.Create(nil);
  try
    MS := TMemoryStream.Create;
    try
      //if Assigned(OnWorkEvent) then
        //Http.OnWork := OnWorkEvent;
      Http.Get1(aSrcUrlFile, MS);
      MS.SaveToFile(aDestFile);
      Result := true;
    finally
      MS.Free;
    end;
  finally
    Http.Free;
  end;
end;


function IsNetworkConnected2: Boolean;
begin
  if GetSystemMetrics(SM_NETWORK) and $01 = $01 then
  begin
    Result := True;
  end
  else
  begin
    Result := False;
  end;
end;

//To Refactor:
function IsNetworkConnected3: Boolean;
begin
  result:= GetSystemMetrics(SM_NETWORK) and $01 = $01
end;

function IsInternetConnected2: Boolean;
begin
  Result:= InternetGetConnectedState(0, 0);      //of wininet
end;

function IsCOMConnected2: Boolean;
begin
  result:= getComports.Count > 0;
end;

procedure PlayMediaUniversal;
var wmp: OLEVariant; 
 //Maybe you'll be more comfortable with automation.
begin
   wmp:= CreateOleObject('WMPlayer.OCX');
   //wmp.OpenPlayer(Exepath+'examples\maxbox.wav');
   if ISInternetOn then begin
     wmp.URL:= 'http://www.softwareschule.ch/download/airmaxloop3.mp3';
     wmp.OpenPlayer(wmp.URL);
   end else
     wmp.OpenPlayer(Exepath+'examples\maxbox.wav');
  //wmp.controls.play;
end; 

const   BufferSize1 = 1024; 
 
function GetInetFile (const fileURL, FileName: String): boolean;
 var   hSession, hURL: HInternet;   Buffer: array[1..BufferSize] of Byte;   BufferLen1: DWORD;   f: File;  sAppName: string; begin  result:= false;  sAppName:= ExtractFileName(Application.ExeName) ; //Function InternetOpen(lpszAgent:PChar;dwAccessType:DWORD;lpszProxy,
//lpszProxBypass:PChar;dwFlags:DWORD):HINTERNET;
//15165: 
 InternetOpen(pchar(sAppName),INTERNET_OPEN_TYPE_PRECONFIG,'0','0',0);
 hSession:= InternetOpen(PChar(sAppName),INTERNET_OPEN_TYPE_PRECONFIG,'0','0',0); 
 { hSession:= InternetOpen(sAppName,INTERNET_OPEN_TYPE_PRECONFIG, nil, nil, 0) ; 
  try   
 hURL := InternetOpenURL(hSession, PChar(fileURL), nil, 0, 0, 0) ;   try    AssignFile(f, FileName) ;    Rewrite(f,1) ;    repeat     InternetReadFile(hURL, @Buffer, SizeOf(Buffer), BufferLen) ;     BlockWrite(f, Buffer, BufferLen)    until BufferLen = 0;    CloseFile(f) ;    result := True;   finally    InternetCloseHandle(hURL)   end  finally   InternetCloseHandle(hSession)  end} end;

//Note: In order to provide some vi

//-----------------------------------------------------}
function Str2Comp(MyString: string): Comp;
var
  ErrCode: Integer;
  Temp: Comp;
begin
  If Mystring[0] = #0 then result:= 0
  else begin
    //Val(Mystring, Temp, ErrCode);
    //StrtoInt
    Temp:= StrToIntDef(myString,0);  //// if invalid, result is 0
    if ErrCode = 0 then
      result:= temp
    else
      result:= 0;
  end;
end;


function Str2CompBetter(MyString: string): Comp;
var
  ErrCode: Integer;
  Temp: Comp;
begin
  If Mystring[1] = #0 then result:= 0
  else begin
    //Val(Mystring, Temp, ErrCode);
    //StrtoInt
    Temp:= StrToIntDef(myString,0);  //// if invalid, result is 0
    if ErrCode <> 0 then
      result:= temp
    else
      result:= 0;
  end;
end;


{----------------------------------------------------
       Name: Str2Pennies function
Declaration: Str2Pennies(MyString: string)
       Unit: MathBox
       Code: N
       Date: 02/17/94	
Description: Converts a String to a Comp
-----------------------------------------------------}
function Str2PenniesX(S: String): Comp;
 var
  C: Comp;
  i: Integer;
 begin
    if S[1] = '$' then Delete(S, 1, 1);
    i:= Pos('.', S);
    if i = Length(S) then begin   { Is last character a period? }
      Delete(S, i, 1);
      S:= S + '00';
    end else
      if i <> 0 then begin        { Some pennies?               }
        Delete(S, i, 1);
        if i = (Length(S)) then   { Only one char after decimal?}
          S:= S + '0'
      end else
        S:= S + '00';            { No decimal, no pennies       }
    C:= Str2CompBetter(S);
    result:= C;
end;

procedure wwStrMathBoxTest;
var hURL: HInternet;
begin
 //strBreakApart(s: string; delimeter: string; parts: TStrings);
 //strGetToken(s: string; delimeter: string; var APos: integer): string;
 //strStripPreceding(var s: string; delimeter: strCharSet);
 //strStripTrailing(var s: string; delimeter: strCharSet);
 //strStripWhiteSpace(var s: string);
 //strRemoveChar(str: string; removeChar: char): string;
 //strReplaceChar(str: string; removeChar, replaceChar: char): string;
 //strReplaceCharWithStr(str: string; removeChar: char;replaceStr: string): string;
 //wwEqualStr(s1, s2: string): boolean;
 //strCount(s: string; delimeter: char): integer;
  writeln(inttoStr(strCount(FileToString(exepath+'firstdemo.txt'),'z')));
  //function CountOfChar(const Ch: Char; const S: string): Integer;
  writeln(inttoStr(CountOfChar('z',FileToString(exepath+'firstdemo.txt'))));
 
 //strWhiteSpace : strCharSet;
 //wwExtractFileNameOnly(const FileName: string): string;
 //wwGetWord(s: string; var APos: integer; Options: TwwGetWordOptions;
                   //DelimSet: strCharSet): string;
 //strTrailing(s: string; delimeter: char): string;
 //strPreceding(s: string; delimeter: char): string;
 //strReplace(s, Find, Replace: string): string;
  //cwMaxPages
  //THTTPServer
  //StripString
 // mxArcCos( x : Real) : Real');
 //mxArcSin( x : Real) : Real');
 //Comp2Str( N : Comp) : String');
 //Int2StrPad0( N : LongInt; Len : Integer) : String');
 //Int2Str( N : LongInt) : String');
 //mxIsEqual( R1, R2 : Double) : Boolean');
 //LogXY( x, y : Real) : Real');
 //Pennies2Dollars( C : Comp) : String');
 //mxPower( X : Integer; Y : Integer) : Real');
 //Real2Str( N : Real; Width, Places : integer) : String');
 //mxStr2Comp( MyString : string) : Comp');
 //mxStr2Pennies( S : String) : Comp');
 //Str2Real( MyString : string) : Real');
 //XToTheY( x, y : Real) : Real');
     //Str2Pennies
   writeln('mXVersion: '+version);  
   writeln('mXVersion: '+mbversion);
   //Function InternetCloseHandle( hInet : HINTERNET) : BOOL'); 
   //InternetOpenURL(hURl, '127.0.0.1', '0', 0, 0, 0)
   hURL:= InternetOpenURL(hURL, '127.0.0.1', '0', 0, 0, 0) 
   InternetCloseHandle(hURL);
end;



var adyn: TDynCardinalArray;
    mymime: TMimeChar;

begin
 //wwScanDate
   //loadMimeForm;
   fileStreamOne;
   OpenDoc(Exepath+'examples\firstdemo22.txt');
   writeln(FileToStringStep(exepath+'firstdemo.txt',0,200));
   //fileStreamByte;
   //OpenDoc(Exepath+'examples\firstdemoBYTE.txt');
   writeln('Is Network Connected1 '+BooleanToString(IsNetworkConnected));
   writeln('Is Network Connected2 '+BooleanToString(IsNetworkConnected2));
   writeln('Is Network Connected3 '+BooleanToString(IsNetworkConnected3));
   writeln('Is Internet Connected1 '+BooleanToString(IsInternetConnected));
   writeln('Is Internet Connected2 '+BooleanToString(IsInternetConnected2));
   writeln('Is COM Port Available1 '+BooleanToString(IsCOMConnected));
   writeln('Is COM Port Available2 '+BooleanToString(IsCOMConnected2));
  
   maxForm1.color:= clSilver;
   
    adyn:= PrimeFactors(1270);
    for i:= 0 to length(adyn)-1 do 
      write(inttostr(adyn[i])+' ');
    for i:= 0 to length(PrimeFactors(20))-1 do 
      writeln(inttostr(adyn[i]));
    //299792458
    writeln(floattoStr(MetersPerLightSecond));
    writeln(floattoStr(1/ (MetersPerLightSecond / 2000)));
    writeln(floattoStr((2000 /MetersPerLightSecond)));
    printF('light speed of 2000 meters %.14f',[2000 /MetersPerLightSecond]);
    printF('light speed test back %.14f',
                  [(2000 /MetersPerLightSecond)*-(1-MetersPerLightSecond/2000)]);
    printF('light speed test back %.14f',
                  [(2000 /MetersPerLightSecond)+
                    (2000 /MetersPerLightSecond)*-(1-MetersPerLightSecond/2000)]);
 
    //TJvMemoryTable
    //TJvObjectStrings
   //PlayMediaUniversal;
   //TDBLookupCombo
   //TDBLookupList
   //TDBLookup
    // THotspot
      //TPrintGrid
      //sTDBCtrlGrid
    //TColumn
     // TDBGridColumns
       //TBookmarkList
    //TCustomDBGrid
      //TDBGrid
      //TQueryDescription
      //strCharSet
    
    writeln(GetIDFromCP(mymime));
 
    mymime:= GetCurCP;
    writeln(GetIDFromCP(mymime));
    writeln(GetIDFromCP(getCurCP));
    writeln('GetDomainName1: '+GetDomainName);
    writeln('GetDomainName2: '+GetDomainName2);
    wwStrMathBoxTest;
    writeln(inttoStr(mxStr2Pennies('$234.34')))
    writeln(inttoStr(Str2PenniesX('$234.34')))
        
 
End.  

Doc:
//maxform1

http://www.cryer.co.uk/brian/delphi/wininet.htm
------------------------------

  memo1 and memo2 is keyword!  and maxform1 is main OpenTools API window
  
  The File Open modes are defined in SysUtils.pas as below.

  
  {$IFDEF MSWINDOWS}
  fmOpenRead       = $0000;
  fmOpenWrite      = $0001;
  fmOpenReadWrite  = $0002;
 
  fmShareCompat    = $0000 platform; // DOS compatibility mode is not portable
  fmShareExclusive = $0010;
  fmShareDenyWrite = $0020;
  fmShareDenyRead  = $0030 platform; // write-only not supported on all platforms
  fmShareDenyNone  = $0040;
{$ENDIF}

We can see that the fmOpenReadWrite is not as the same as fmOpenRead or fmOpenWrite.

The fmShareExclusive specifies that the file cannot be read or write by other processes. 
The fmShareDenyWrite specifies that the file can by read but not write by other processes. 
The fmShareDenyRead specifies that the file can by write but not read by other processes. 
The fmShareDenyNone specifies that the file can by read or write (no limitation) by other processes

If you specify the fmCreate, the file will always be cleared as empty if created or always exists. In this case, if you specify fmCreate or fmOpenWrite, it is actually the same a fmCreate or fmOpenReadWrite, in such case, you can use ReadBuffer to read the data you have written before (or zero if it has not been written by WriteBuffer).


 Urknall: Erster direkter Beweis für kosmologische Inflation
Meldung vorlesen und MP3-Download

Offenbar ist es gelungen, erstmals direkte Beweise für die kurzzeitige überlichtschnelle Expansion des Universums nach dem Urknall zu finden. Den Nachweis für diese sogenannte Inflation fanden Forscher in der kosmischen Hintergrundstrahlung.

Astronomen ist es mithilfe von Radioteleskopen am Südpol offenbar gelungen, erstmals direkte Beweise für die sogenannte kosmologische Inflation nachzuweisen. Dabei handelt es sich um eine überlichtschnelle Expansion des Universums in einem äußerst kurzen Zeitraum direkt nach dem Urknall, die in Bruchteilen einer Sekunde stattfand.

Die bislang nur in der Theorie beschriebene Inflation erklärt einige Probleme, die sich aus der Beschreibung des Urknalls ergeben hatten, etwa die große Gleichförmigkeit unseres Universums. Nun konnte sie experimentell bestätigt und dabei erstmals auch Bilder sogenannter Gravitationswellen gemacht werden. Die Ergebnisse bestätigen außerdem die enge Verbindung zwischen der Quantenmechanik und der Relativitätstheorie.


 Lazarus-IDE für Pascal und Object Pascal in Version 1.2 veröffentlicht

Die freie Entwicklungsumgebung enthält im ersten größeren Release nach etwa anderthalb Jahren unter anderem einen Makro-Recorder, einen verbesserten Debugger und überarbeiteten Compiler-Optionen.

Version 1.2 der integrierten Entwicklungsumgebung Lazarus steht zum Download bereit. Sie ist zum Rapid Application Development (RAD) mit Pascal und Object Pascal gedacht und zu Delphi kompatibel, während andere Pascal-IDEs sich eher an Turbo Pascal anlehnen. Intern kommt der Free-Pascal-Compiler zum Einsatz.

object Form1: TForm1
  Left = 249
  Top = 130
  Width = 672
  Height = 480
  Caption = 'Form1'
  Font.Charset = DEFAULT_CHARSET
  Font.Color = clWindowText
  Font.Height = -13
  Font.Name = 'MS Sans Serif'
  Font.Style = []
  OnCreate = FormCreate
  OnDestroy = FormDestroy
  PixelsPerInch = 120
  TextHeight = 16
  object Label1: TLabel
    Left = 8
    Top = 56
    Width = 47
    Height = 16
    Caption = 'Part-list:'
  end
  object Label2: TLabel
    Left = 8
    Top = 192
    Width = 61
    Height = 16
    Caption = 'RAW part:'
  end
  object Edit1: TEdit
    Left = 8
    Top = 8
    Width = 553
    Height = 24
    TabOrder = 0
    Text = 'filename'
  end
  object Button1: TButton
    Left = 576
    Top = 8
    Width = 75
    Height = 25
    Caption = 'Load'
    TabOrder = 1
    OnClick = Button1Click
  end
  object Memo1: TMemo
    Left = 8
    Top = 208
    Width = 641
    Height = 193
    ScrollBars = ssBoth
    TabOrder = 2
  end
  object Button2: TButton
    Left = 8
    Top = 416
    Width = 641
    Height = 25
    Caption = 
      'save selected decoded part to file (default filename is '#39'mimedem' +
      'o.txt'#39')'
    TabOrder = 3
    OnClick = Button2Click
  end
  object TreeView1: TTreeView
    Left = 8
    Top = 72
    Width = 641
    Height = 113
    ReadOnly = True
    Indent = 19
    OnChange = TreeView1Change
    TabOrder = 4
  end
end
----Simple Browser started----


http://sourceforge.net/projects/maxbox/files/maxbox3clx.tar.gz/download
SHA1 
15fa2216f84f11433123c2d87cb264fa2e82c466


review

Professor Dr. Nikolaus Wirth - Niklaus


process using. By the way the script you get all this is:
http://www.softwareschule.ch/examples/440_DL
L_Tutor2.txt

function
stdcall external
( : ): ;
;
xFoobox param Integer Integer
Foobox
'mytools.dll' name
' ';

This first script (project)  440_DLL_Tutor2 - script


When you call a DLL written in C or C++,
you have to use the stdcall or cdecl convention.
External 'GetVersionExA@kernel32.dll cdecl';  cdecl


