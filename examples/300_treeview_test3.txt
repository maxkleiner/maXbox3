{***************************************************************
 * Project  : System Graphic Function Overview
 * App Name : 300_treeview_animation tester, loc's = 875 
 * Purpose  : Demonstrates outline treeview in a tree
 * Date     : 09/12/2012  -  17:07
 * History  : convert outline VCL to maXbox Nov 2011
 *          : system save demo for mX3.9.2, not finished yet!!
            : animates a sprite cursor, if XP then ProcessMessagesOFF;
 ****************************************************************}

Program Treeview3_tester3;

{@BOOL WINAPI MessageBeep(
  __in  UINT uType  );}
//TThreadFunction = function(P: Pointer): Longint; stdcall;
//Procedure ExecuteThread(afunc: TThreadFunction; var thrOK: boolean);
{The main parts of a TreeView are nodes (TTreeNodes), which are a collection of type node (TTreeNode). TTreeNodes are seen as items property of a TreeView, within items are the individual nodes which are of type TTreeNode. A node can be accessed as follows:               
      MyTreeNode := TreeView1.Items[1]; }




function MessageBoxTimeOut(hWnd: HWND; lpText: PChar; lpCaption: PChar; uType: UINT;
                wLanguageId: WORD; dwMilliseconds: DWORD): Integer;
             external 'MessageBoxTimeoutA@user32.dll stdcall';
  
procedure CloseClick(Sender: TObject; var action: TCloseAction); forward;
  
Const
  BACKMAP = 'examples\images\bmp47.bmp';
  //BACKMAP = 'examples\images\bmp33.bmp';
  BITMAP1 = 'examples\images\empty.bmp';
  BITMAP2 = 'examples\images\empty.bmp';
  //BITMAP1 = 'examples\images\bmp21.bmp';  //try another combinations
  //BITMAP2 = 'examples\images\bmp29.bmp';
  //BITMAP2 = 'examples\images\bmp33.bmp';
  SAVEPATH = 'examples\treeview_300.txt';
  AExponent = 4;
  ANIMATEDELAY = 6;
  
type
  TByteArr = array of byte;
  
var
  except_state, execute_state: string;  
  mytimestamp: TDateTime;
  osType: TIdWin32Type;
  bfrm: TForm;
  FMask, FPic, FPicled, FPicRed, FPicGreen, FStorage: TBitMap;
  FNewRect: TRect; 
  FOldRect: tRect; //make foldrect local!
  FirstTime: boolean;
  tv1,tv2: TTreeView;
  mt: ttoolwindow;
  mtd: ttooldockform;
  distX, distY, glx,gly, step, pct: float;
  endX, endY, beginX, beginY: integer;
  //mtt: TToken;
  // mxt: TAtom;
  //aint: TIncome;    fjfj  ddd

procedure getMaxBoxIni;
var Ini: TIniFile;   
begin
  Ini:= TIniFile.Create(ExePath+'maxboxdef.ini');
  try
    except_state:= Ini.ReadString('Form', 'EXCEPTIONLOG','');
    execute_state:= Ini.ReadString('Form', 'EXECUTESHELL','');
  finally
    writeln('inifile sysdata test: '+(except_state)+ ' '+(execute_state))
    ini.Free;
  end;
end;

procedure TJvFormAutoSize_Resize(Sender: TObject);
var
  WidthRatio, HeightRatio: Double;
  CompIndex: Integer;
  FForm: TForm;
    FActive: Boolean;
      FOldWidth: Integer;
    FOldHeight: Integer;
  FResize: TNotifyEvent;
begin
  if FForm = nil then
    FForm := GetParentForm(Application.Owner as TControl) as TForm;
  if FActive and (FForm <> nil) then begin
    // (p3) this code is slightly dangerous: no sanity checks -
    // values can become really large or really small
    if (FOldWidth <> 0) and (FOldHeight <> 0) then begin
      WidthRatio := FForm.Width / FOldWidth;
      HeightRatio := FForm.Height / FOldHeight;
      for CompIndex := 0 to FForm.ComponentCount - 1 do begin
        if FForm.Components[CompIndex] is TControl then begin
          with FForm.Components[CompIndex] {as TControl} do begin
            if not (FForm.Components[CompIndex] is TButton) then begin
              fform.Width := Round(fform.Width * WidthRatio);
              fform.Height := Round(fform.Height * HeightRatio);
            end;
            fform.Left:= Round(fform.Left * WidthRatio);
            fform.Top:= Round(fform.Top * HeightRatio);
          end;
        end;
      end;
    end;
    FOldWidth := FForm.Width;
    FOldHeight := FForm.Height;
  end;
  if FResize<> NIL then
    FResize(Sender);
end;




procedure FormDrawBitmap(const fname: String; const x,y: Integer; acanvas: TCanvas);
var aBmp: TBitmap;
begin
  if not FileExists(Fname) then begin
    ShowMessage('The big bitmap ' + Fname + ' was not found!');
    Exit;
  end;
  aBmp:= TBitmap.Create;
  try
    aBmp.LoadFromFile(Fname);
    //aCanvas.Draw(x,y, aBmp);
    aCanvas.StretchDraw(Rect(0,0,bfrm.width, bfrm.height), aBmp);
  finally
    aBmp.Free;
  end;
end; 

procedure BitmapFormCreate(Sender: TObject);
begin
  FMask:= TBitMap.Create;
  FMask.LoadFromFile(exepath+BITMAP2);
  //FMask.LoadFromFile(exepath+'examples\citymax.bmp');
  FPic:= TBitMap.Create;
  FPic.LoadFromFile(exepath+BITMAP1);
  FPicled:= TBitMap.Create;
  FPicRed:= TBitMap.Create;
  FPicGreen:= TBitMap.Create;
    
  FPicled.LoadFromFile(Exepath+'\examples\images\yellow1.bmp');
  FPicRed.LoadFromFile(Exepath+'\examples\images\red1.bmp');
  FPicGreen.LoadFromFile(Exepath+'\examples\images\green1.bmp');
  
  FStorage:= TBitMap.Create;
  FStorage.Width:= FPic.Width;
  FStorage.Height:= FPic.Height;
  Screen.Cursor:= crCross;//loadCursor(hinstance,'Pan_All'); //crCross;
end;  

function getBitMapObject2(mappath: string): TBitmap;
begin
  result:= TBitmap.Create;
  try 
    result.LoadFromFile(mappath);
  finally
    //result.Free;
  end;  
end;  

function FindRootNode(ACaption: String; ATreeView: TTreeView): TTreeNode; 
var LCount, i: Integer; 
begin 
  result := nil; 
  LCount := 0;
  //atreeview.items.count-1 do  
  for i:= 1 to atreeview.items.count-1 do 
  result.getNextsibling;
  result.MoveTo(TTreeNode(atreeview), naAddChild);
  while (LCount < ATreeView.Items.Count) and (result = nil) do begin 
    if (ATreeView.Items.Item[LCount].Text = ACaption) and (ATreeView.Items.Item[LCount].Parent = nil) then 
      result := ATreeView.Items.Item[LCount]; 
    inc(LCount); 
  end; 
end;

function FindRootNode2(ACaption: String; ATreeView: TTreeView): TTreeNode; 
var LCount: Integer; 
begin 
  result := nil; 
  LCount := 0; 
  while (LCount < ATreeView.Items.Count) and (result = nil) do begin 
    if (ATreeView.Items.Item[LCount].Text = ACaption)
       and (ATreeView.Items.Item[LCount].Parent = nil) then 
      result:= ATreeView.Items.Item[LCount]; 
    inc(LCount); 
  end; 
end;

procedure FindRootCall;
var LDestNode: TTreeNode; 
    TreeView1: TTReeView;
begin 
  LDestNode := FindRootNode('category', TreeView1); 
  if LDestNode <> nil then begin 
    TreeView1.Items.AddChild(LDestNode, 'node1'); 
    TreeView1.Items.AddChild(LDestNode, 'node2'); 
  end; 
end;

procedure AddRootNode;
var LDestNode: TTreeNode; 
    TreeView1: TTReeView;
    Node : TTreeNode;
begin 
//function TTreeNodes.Add(Sibling: TTreeNode; const S: string): TTreeNode;
   Node:=TreeView1.Items.Add(nil,'My Root Node') ;
   Node.ImageIndex:=0;//now you can change any  property of the node
  
  {LDestNode := FindRootNode('category', TreeView1); 
  if LDestNode <> nil then begin 
    TreeView1.Items.AddChild(LDestNode, 'node1'); 
    TreeView1.Items.AddChild(LDestNode, 'node2'); 
  end;}
  //in this case we add a child node in the current selected node.
  if TreeView1.Selected= nil then exit;       
       Node:=TreeView1.Items.AddChild(TreeView1.Selected,'My Child Node') ;
       Node.ImageIndex:=0;//now you can change any property of the node 
end;


procedure ADDManyNodes;
Var
  Node : TTreeNode;
  i    : Integer;
  TreeView1: TTReeView;
  
begin
  TreeView1.Items.BeginUpdate;
  try
   for i:=1 to 100 do begin
     Node:=TreeView1.Items.Add(nil,'My Root Node '+IntToStr(i)) ;
     Node.ImageIndex:=0;
   end;
  finally
    TreeView1.Items.EndUpdate;
  end;
end;

procedure TForm1_FormCloseQuery(
    Sender: TObject; 
    var CanClose: Boolean);
begin
  case MessageDlg('Save tree items to XML?', 
                   mtConfirmation, 
                   [mbYes, mbNo, mbCancel], 0) of
    mrYes:
      writeln('Tree2XML(tree)'); 
    mrNo:
      CanClose := True;
    mrCancel:
      CanClose := False;
  end;
end;


procedure TForm1_CreateTree(Sender: TObject; TreeView1: TTreeView);

var
  MyTreeNode1, MyTreeNode2 ,myTreeNode3, myTreeNode4: TTreeNode;
  //TreeView1: TTreeView;
begin

  //myTreenode1:= TTreenode.create(TreeView1.items);
  //mytreenode1.parent:= TreeView1.items;
  //myTreenode2:= TTreenode.create(TreeView1.items);

with TreeView1.Items do begin
    Clear; { remove any existing nodes }
    MyTreeNode1 := Add(nil, 'RootTreeNode1'); { Add a root node }
    { Add a child node to the node just added }
    AddChild(MyTreeNode1,'ChildNode1');
    
    {Add another root node}
    MyTreeNode2 := Add(MyTreeNode1, 'RootTreeNode2');
    {Give MyTreeNode2 to a child }
    AddChild(MyTreeNode2,'ChildNode2');
    
    MyTreeNode3 := Add(MyTreeNode2, 'RootTreeNode3');
    {Give MyTreeNode2 to a child }
    AddChild(MyTreeNode3,'ChildNode3');
    
    MyTreeNode2:= Add(MyTreeNode3, 'RootTreeNode4');
    AddChild(MyTreeNode2,'ChildNode2');
    
    
    {Change MyTreeNode2 to ChildNode2 }
    { and add a child node to it}
    MyTreeNode2 := TreeView1.Items[3];
    AddChild(MyTreeNode2,'ChildNode2a');
    
    {Add another child to ChildNode2, after ChildNode2a }
    Add(MyTreeNode2,'ChildNode2b');
    Add(MyTreeNode2,'ChildNode2c');
    
    {add another root node}
    Add(MyTreeNode1, 'RootTreeNode3');
    
    end;
    Treeview1.FullExpand;
end;

//To delete the selected node...
procedure TForm1_DeleteTView(Sender: TObject; TreeView1: TTreeView);
begin
  TreeView1.Selected.Delete; //Delete the selected node
end;

//to insert the selected node
procedure TForm1_InsertTView(Sender: TObject; TreeView1: TTreeView);
begin
  TreeView1.items.Insert(TreeView1.Selected,'Another Child'); //Insert a child in the level of the selected node ...
//if you want to edit the text of the selected node just make a click on the text, edit it and then make another click. Easy !
  //TreeView1.Items.AddObject(nil,Pages[i].Caption,Pages[i]) ;
end; 

//The following code shows how to select a node which was stored in the above snippet

procedure TfrmTrees_cmdGoToNodeClick(Sender: TObject; TreeView1: TTreeView);
var
  iNodeID   : integer;
  FoundNode : TTreeNode;
  iIndex    : Integer ;
  HTreeItemList: TListBox;
  
begin
  iIndex := HTreeItemList.ItemIndex ;
  if iIndex = -1 then
    exit ;
  iNodeID := StrToIntDef(HTreeItemList.Items.Strings[iIndex],0) ;
  if(  iNodeID = 0  ) then
    exit;
  //FoundNode := TreeView1.Items.GetNode(HTreeItem(iNodeID));
  if(FoundNode <> nil) then begin
    FoundNode.Selected := true;
    TreeView1.SetFocus ;
  end ;
end;






//********************************Event Handler*****************************//
procedure BtnAddClick(Sender: TObject);
  var
   sText : shortstring;
   idx: integer;
begin
      {If nothing is selected}
   if(tv1.selected = NIL) then begin
         {Does a root node already exist? if( tv_eg1.Items.Count = 0 )}
    tv1.Selectioncount;
    tv1.Select(nil,[])
    tv1.Selected.Selected:=false;
    //end;
    with tv1.Selected do
      //if HasItems then Expand;
      //tv1.items[1].addchild
      if(tv1.Items[tv1.selected].item[tv1.selected].text = '') then begin
            {Add the root node}
         with tv1 do begin
           //idx:= items.addchild(0,'Root');
           idx:= items.Addchild(0,'Root');
           Showlines:= true;
           //sorttype
           //items.item[1]:= items[idx];
            //debugln('tv_eg1.Selected=',DbgS(tv_eg1.Selected));
         end;
      end else begin
            {There is a root, so user must first select a node}
         //MessageBeep(  -1  );
         ShowMessage(  'Select a parent node'  );
         Exit;
      end;
   end 
   else begin
         {Get a name for the new node}
      sText:= 'New xnode';
      InputQuery('New Node',  'Caption ?', sText  );
         {Add the node as a child of the selected node}
     //with tv1.items[tv1.SelectedItem] do
      //if HasItems then Expand;
    {with tv1[tv1.SelectedItem] do
      if HasItems then Expand;
      with tv1 do begin
      idx:= selecteditem  //itemindex
         AddChild(idx,sText);
         FullExpand;
      end;}
   end;
end;

procedure TForm1_Button1Click(Sender: TObject);
var panel1: TPanel;
begin
 with Panel1 do begin
   BevelInner:= bvLowered;
   BevelOuter:= bvRaised;
   if BevelWidth = 0 then
     BevelWidth := 2
   else
   BevelWidth := 0;
  end;
end;

procedure RemoveClick(Sender: TObject);
var idx: integer;
begin
  {Make sure somthing is selected, before trying to delete it}
   if(tv1.Selected.Selected) then begin
      //MessageBeep(  -1  );
      ShowMessage('Nothing selected'  );
      Exit;
   end;
      {Dont allow user to delete the root node}
  // if(tv1.SelectedItem = 1) then begin
   if(tv1.Selected.level = 1) then begin
  
      //MessageBeep(  -1  );
      ShowMessage('Cant delete the root node!');
      Exit;
   end;
      {Delete the node}
     with tv1 do begin
       idx:= selected  //itemindex
       //Delete(idx);
       FullExpand;
     end;   
   //tv1.SelectedItem.Delete;
end;

procedure CloseClick(Sender: TObject; var action: TCloseAction);
begin
  FMask.Free;
  FPic.Free;
  FPicled.Free;
  FPicRed.Free;
  FPicGreen.Free;
  
  FStorage.Free;
  action:= caFree;
  Screen.Cursor:= crDefault;
  writeln('Outline Form being closed');
end;

procedure CloseButtonClick(Sender: TObject);
begin
  bfrm.Close; //calls close click
end;

procedure ClickTestButton(Sender: TObject);
begin
  //tv1.SaveToFile(SAVEPATH);
  //SaveCanvas2(bfrm.Canvas, Exepath+SAVEPATH);
  //if sender
  writeln(objectToStr(sender)+' has been hit at: '+Exepath+SAVEPATH);
  writeln(objectToString(sender)+' has been hit at: '+Exepath+SAVEPATH);
  if sender is TTreeview then
   writeln('tv2 hit test at '+tv2.selected.text);
end;

procedure ClickTestButton2(Sender: TObject);
begin
  //tv1.SaveToFile(SAVEPATH);
  //SaveCanvas2(bfrm.Canvas, Exepath+SAVEPATH);
  writeln('Outline has been hit at: '+Exepath+SAVEPATH);
end;

procedure DblClickButton(Sender: TObject);
begin
  tv1.SaveToFile(SAVEPATH);
  //SaveCanvas2(bfrm.Canvas, Exepath+SAVEPATH);
  writeln('Outline being stored at: '+Exepath+SAVEPATH);
  bfrm.canvas.draw(300,200, getbitmapObject2(Exepath+'\examples\citymax.bmp'));
  
end;

procedure drawE(abeginx, abeginy, endx, endy: integer); 
{   fill(0, 2);
  rect(0, 0, width, height);
  pct += step;
  if (pct < 1.0) {
    x = beginX + (pct * distX);
    y = beginY + (pow(pct, exponent) * distY);  }
  //fill(255);  //ellipse(x, y, 20, 20);
var i: integer;  
begin
  pct:= 0.0;
  distX:= endX - beginX;
  distY:= endY - beginY;
  for i:= 1 to 100 do begin
  pct:= pct+ step;
  if (pct < 1.0) then begin
    glx:= beginX + (pct * distX);
    gly:= beginY + (power(pct, AExponent) * distY);
  end;
  //  bfrm.repaint;
  //bfrm.canvas.draw(round(x),round(y), fpic);
  bfrm.canvas.draw(round(glx)-20,round(gly-20),fPicLed);
    // BitBlt(FStorage.Canvas.Handle,0,0, FPic.Width, FPic.Height,
              // bfrm.Canvas.Handle, round(x), round(y), SRCCOPY);
  delay(ANIMATEDELAY);
  end;
end;  


procedure drawE2(abeginx, abeginy, endx, endy: integer); 
var i: integer;  
begin
  pct:= 0.0;
  distX:= endX - beginX;
  distY:= endY - beginY;
  for i:= 1 to 100 do begin
  pct:= pct+ step;
  if (pct < 1.0) then begin
    glx:= beginX + (pct * distX);
    gly:= beginY + (power(pct, AExponent+5) * distY);
  end;
  bfrm.canvas.draw(round(glx)-20,round(gly-20), fPicRed);
  delay(ANIMATEDELAY);
  end;
end;  

procedure setup(); 
{ size(640, 360); noStroke();
  distX = endX - beginX;
  distY = endY - beginY; }
begin
  beginX:= 20;  // Initial x-coordinate
  beginY:= 20;  // Initial y-coordinate
  endX:= 570;   // Final x-coordinate
  endY:= 320;   // Final y-coordinate
  glx:= 20.0;        // Current x-coordinate
  gly:= 20.0;        // Current y-coordinate
  step:= 0.01;    // Size of each step along the path  100 steps
  pct:= 0.0;      // Percentage traveled (0.0 to 1.0)
  distX:= endX - beginX;
  distY:= endY - beginY;
end;


procedure FormMouseDown(sender: TObject; Button: TMouseButton; 
                                Shift: TShiftState; vX, vY: Integer);
begin
  BitBlt(FStorage.Canvas.Handle,0,0, FPic.Width, FPic.Height,
               bfrm.Canvas.Handle, FNewRect.Left, FNewRect.Top, SRCCOPY);
  pct:= 0.0;
  beginX:= round(glx);
  beginY:= round(gly);
  endX:= vX;     //mouseX
  endY:= vY;
  
  bfrm.repaint;
  //FormDrawBitmap(Exepath+BACKMAP,10,10, bfrm.canvas);
  drawE(beginx,beginy, endx,endy);
  drawE2(beginx,beginy, endx,endy);
  
end;

procedure FormMouseMove(Sender: TObject; Shift: TShiftState; X,Y: Integer);
//const FirstTime: boolean = True;
//var FOldRect: TRect;     //makes a blur and zoom effect
begin
  //firsttime:= true;   //move tester
  { 1) Restore Form1: copy storage onto Form1 at its old location }
  //FOldRect:= Rect(280, 200, X , Y);
  if FirstTime then FirstTime:= False
    else BitBlt(bfrm.Canvas.Handle, FOldRect.Left, FOldRect.Top,
     FPic.Width,FPic.Height, FStorage.Canvas.Handle,0,0,SRCCOPY);
  { save old location }
  FNewRect:= Rect(X, Y, X + FPic.Width, Y + FPic.Height);
  FOldRect:= FNewRect;
  { 2) Save copy of Form1: copy rectangle from Form1 to storage at new location.}
  BitBlt(FStorage.Canvas.Handle,0,0, FPic.Width, FPic.Height,
         bfrm.Canvas.Handle, FNewRect.Left, FNewRect.Top,  SRCCOPY);
  { 3) copy the image to Form1 using SRCINVERT }
  BitBlt(bfrm.Canvas.Handle, FNewRect.Left, FNewRect.Top, FPic.Width, FPic.Height,
         FPic.Canvas.Handle,0,0, SRCAND);
end;



//********************************Form Builder*****************************//
procedure InitBitmapForm;
var
  RootNode: TTreeNode;
  idx: integer; 
   myc: TCollection;   
   //images: TCustomImagelist;
 
begin
 Setup;
 bfrm:= TForm.create(self);
  //mt.free;  in on close
 with bfrm do begin
   //FormStyle := fsStayOnTop;
   Position:= poScreenCenter;
   caption:='Outline TreeView Demo - DblClick to Save Outline';
   color:= clwhite;
   width:= 750;
   height:= 670;
   //canvas.Pen.mode:= pmNotXor;
   onMouseMove:= @FormMouseMove;
   onMouseDown:= @FormMouseDown;
   onDblClick:= @DblClickButton;
   onclick:= @clicktestbutton;
   onClose:=  @CloseClick;
   //canvas.brush.bitmap.loadfromfile(Exepath+backmap);
   Show;
   //canvas.draw(300,200, getbitmapObject2(Exepath+'\examples\citymax.bmp'));
   //Show;
 end;

  tv1:= TTreeView.Create(NIL);
  with tv1 do begin
   parent:= bfrm;
   Loadfromfile(ExePath+SAVEPATH);
  setbounds(5,170,160, 160);
   writeln(inttostr(width));
   FullExpand;
   //Items[2].addchild('','');
   //color
    onclick:= @clicktestbutton;
    //images.getBitmap(0,getBitmap2(Exepath+BITMAP2));
   //onclick
   //images
  end; 
 
  tv2:= TTreeView.Create(NIL);
  with tv2 do begin
   parent:= bfrm;
   //Loadfromfile(ExePath+SAVEPATH);
  setbounds(450,170,200, 340);
   writeln(inttostr(width));
   FullExpand;
   //Items[2].addchild('','');
   //color
    onclick:= @clicktestbutton;
    //images.getBitmap(0,getBitmap2(Exepath+BITMAP2));
   //onclick
   //images
 
  end; 
 
  //writeln('tv2 hit at '+tv2.selected.text);
 
  TForm1_CreateTree(self, tv2);
  //tv2.Free;
 
  
 (* with TStatusPanel.create(self) do begin
  //parent
    width:= 200;
    alignment:= alleft;
  end;*)
 
 with TBitBtn.create(bfrm) do begin
   parent:= bfrm;
   setbounds(550,530,150,55)
   font.size:= 12;
   glyph.LoadFromResourceName(HINSTANCE,'CL_MPSTOP');
   mXButton(05,05,width, height,12,12,handle);
   caption:= '&Close App';
   onClick:= @closeButtonClick;
 end;
 with TBitBtn.Create(bfrm) do begin
   Parent:= bfrm;
   setbounds(230,530,150, 55);
   caption:= 'A&dd Node';
   font.size:= 12;
   glyph.LoadFromResourceName(getHINSTANCE,'CL_MPNEXT');
   mXButton(05,05,width, height,12,12,handle);
   onClick:= @BtnAddClick;
 end;
 with TBitBtn.Create(bfrm) do begin
   Parent:= bfrm;
   setbounds(390,530,150, 55);
   caption:= '&Delete Node';
   font.size:= 12;
   glyph.LoadFromResourceName(getHINSTANCE,'CL_MPPREV');
   mXButton(05,05,width, height,12,12,handle);
   onClick:= @RemoveClick;
 end;
 FirstTime:= true;
 
  with TStatusPanel.create(NIL) do begin
  //parent
    width:= 200;
    text:= 'status panel';
    alignment:= alleft;
  end;
  
  with TStatusBar.create(bfrm) do begin
    parent:= bfrm;
    simplepanel:= true;
    color:= clyellow;
    //align:= alleft;
    showhint:= true;
    hint:= 'this is box';
    //simpletext.font.size:= 12;
    simpletext:= 'this is status bar';
    //visible:= true;
    //width:= 200;
    //alignment:= alleft;
    //onclick:= 
  end;
  
  with TRichEdit.Create(bfrm) do begin
    parent:= bfrm;
    clear;
    setbounds(5,350,220,160);
    //findtext
    wordwrap:= true;
    color:= clteal;
    font.size:= 12;
    //Loadfromfile(ExePath+SAVEPATH);
    //PlainText
    scrollbars:= true;
    Lines.Add('This is {b super} real');
    Lines.LoadfromFile(ExePath+SAVEPATH);
    with SelAttributes do begin
      Color:= clGreen;
      Height:= 10;
      Style:= [fsBold]; // b
    end;
    //print
    //onclick
    //SetBounds
    ///align
    wanttabs:= true;
    onclick:= @clicktestbutton;
      //ondblclick
    //free;
  end;
end; 

procedure PrintList(Value: TStringList);
var
  I, Line, Pagenum: Integer;
begin
  //let's print
  //if Assigned(FOnBeginPrint) then
    //FOnBeginPrint(Self);
  line := 0;
  Printer.BeginDoc;
  Pagenum := 1;
  for I := 0 to Value.Count - 1 do begin
    //if Assigned(FOnProgress) then
      //FOnProgress(Self, I + 1, Value.Count);
    Line := Line + Printer.Canvas.TextHeight(Value[I]);
    if Line + Printer.Canvas.TextHeight(Value[I]) > Printer.PageHeight then begin
      Line := Printer.Canvas.TextHeight(Value[I]);
      Printer.NewPage;
      Inc(PageNum);
      //if Assigned(FOnNextPage) then
        //FOnNextPage(Self, PageNum);
    end;
    Printer.Canvas.TextOut(0, Line, Value[I]);
  end;
  Printer.EndDoc;
  //if Assigned(FOnFinishedPrint) then
    //FOnFinishedPrint(Self);
end;

  function maxcalcfunc(a: extended): extended;
  begin
    result:= cotan(a);
  end;  
  
function TimeStampInterval(StartStamp, EndStamp: TDateTime): integer;
var
  days: Integer;
  hour, min, s, ms: Word;
begin
  days := Trunc(EndStamp - StartStamp); // whole days
  DecodeTime(EndStamp - StartStamp, hour, min, s, ms);
  result := (((days * 24 + hour) * 60 + min) * 60 + s) * 1000 + ms;
end;

 
 var    myus: TUserfunction;
        aobj: TObject;
        //mylog: TFoLog;
        bitstyle: TBitmapstyle;
        UserSpaceAvail, TotalSpaceAvail, DiskSize: Comp; {disk size}

begin   //main of animationbox
   //InifileRead;
   ProcessMessagesON;
   getMaxBoxIni;
   writeln('Thread ID :'+intToStr(CurrentThreadID))
   writeln('Process ID :'+intToStr(CurrentProcessID))
   writeln('machine name is: '+getHostName)
   writeln('user name is: '+getUserName)
   osType:= Win32Type;
   writeln('OS Type is: '+intToStr(ord(osType)));
   mytimestamp:= GetFileCreationTime(exepath+'maxbox3.exe')
   writeln(DateTimeToStr(mytimestamp)+' for maXbox3 file')
   //SearchAndOpenDoc(ExtractFilePath(ParamStr(0))+'docs\maxbox_starter16.pdf')
   //ExecuteCommand('cmd','/k dir *.*')
   BitmapFormCreate(self);
   InitBitmapForm;
   //FormDrawBitmap(Exepath+BACKMAP,10,10, bfrm.canvas);
   
   //bfrm.canvas.brush.bitmap.loadfromfile(Exepath+backmap);
   //bfrm.canvas.draw(300,200, getbitmapObject(Exepath+backmap));
   
    //Form1.Canvas.Brush.Bitmap := Bitmap;
    //Form1.Canvas.FillRect(Rect(0,0,100,100));
   //abmap:= getbitmapObject(Exepath+backmap);
   //GrayscaleBitmap(abmap);
   //bfrm.canvas.brush.bitmap:= abmap;

   bfrm.canvas.brush.bitmap:= getbitmapObject(Exepath+backmap);
   bfrm.Canvas.FillRect(Rect(400,300,100,100));
 
   //bfrm.canvas.top:= 200;
   //bfrm.canvas.brush.bitmap.width:= 300;
   //FormDrawBitmap(BITMAP2,540,10, bfrm.canvas);
   CurrencyFormat;
   //VarComplexToPolar
   //CheckSynchronize
    if isMultiThread then writeln('multi');
    //maXbox
    myus:= @maxcalcfunc;
    
    with TJvMathParser.create do begin
      //registeruserfunction('maxcalcfunc', myus);
      execute('4+6')
      Free;
    end; 
    
    //TObject.instancesize
    with TPersistent.Create do begin
      //cleanupinstance;
      //classname
      writeln(getnamepath);
      Free;
    end;
  
    with TComport.Create(self) do begin
      //cleanupinstance;
      //classname
      open;
      writeln('com handle '+inttostr(handle));
      codepage;
      buffer;
      writeln('of com port '+getnamepath);
      if connected then writeln(' com connect');
      close;
      Free;
    end;
  
    aobj:= TObject.Create;
    freeandnil2(aobj);
    //RIRegister_StGenLog_Routines
    //Function HexifyBlock( var Buffer, BufferSize : Integer) : string');
    //HexifyBlock( var Buffer, BufferSize : Integer) : string');
    //maxform1.CB1SCList.color:= clred;
    maxform1.mxNavigator.color:= clyellow;
    
    //JvFormLog
    with TJvLogFile.Create(self) do begin
      add('first','second','third');
     //parent:= bfrm;
     //showlog('maxbox');
     free;
    end;
    bitstyle:= bsCentered;
    //printimage(getbitmapObject(Exepath+backmap),bscentered); 
    writeln(inttostr(vk_back))
    writeln(inttostr(vk_F1))
    //formatmasktext
    //MaskGetMaskSave
    GetEnvironmentInfo;
    //FindFilesDlg(StartIn: string; SpecialFolder: TJvSpecialFolder; UseFolder: Boolean): Boolean;
    //FindFilesDlg(Exepath, sfPrograms, true);
    //getrandomstring
    //copyfile
    //CreateTempFile
    
    {DeleteVolumeLabel}
//function DeleteVolumeLabel(Drive : AnsiChar) : Cardinal;
{-Deletes an existing volume label on Drive. Returns 0 for success,
  or OS error code.}
   //DeleteVolumeLabel(Drive : AnsiChar) : Cardinal;

{EnumerateDirectories}
//procedure EnumerateDirectories(const StartDir : AnsiString; FL : TStrings; {!!.02}
  //                             SubDirs : Boolean;
    //                           IncludeItem : TIncludeItemFunc);
{-Retrieves the complete path name of directories on requested file
  system path.}
  //EnumerateDirectories
  
  writeln('DriveDelim= '+DriveDelim) 

{EnumerateFiles}
//procedure EnumerateFiles(const StartDir : AnsiString; FL : TStrings;   {!!.02}
  //                       SubDirs : Boolean;
    //                     IncludeItem : TIncludeItemFunc);
{-Retrieves the complete path name of files in a requested file system path.}

  //EnumerateFiles
{FileHandlesLeft}
 //FileHandlesLeft(MaxHandles : Cardinal) : Cardinal;
{-Return the number of available file handles.}

{FileMatchesMask}
   //FileMatchesMask(const FileName, FileMask : AnsiString ) : Boolean;
{-see if FileName matches FileMask}

{FileTimeToStDateTime}
  //FileTimeToStDateTime(FileTime : LongInt) : TStDateTimeRec;
{-Converts a DOS date-time value to TStDate and TStTime values.}

{FindNthSlash}
  //FindNthSlash( const Path : AnsiString; n : Integer ) : Integer;
{ return the position of the character just before the nth slash }
  writeln('FindNthSlash '+inttostr(FindNthSlash(Exepath, 9)));

{FlushOsBuffers}
   //FlushOsBuffers(Handle : Integer) : Boolean;
{-Flush the OS buffers for the specified file handle.}

{GetCurrentUser}
  //GetCurrentUser : AnsiString;
{-Obtains current logged in username}

{GetDiskClass}
 //GetDiskClass(Drive : AnsiChar) : DiskClass;
{-Return the disk class for the specified drive.}
{GetDiskInfo}
  //GetDiskInfo(Drive : AnsiChar; var ClustersAvailable, TotalClusters,
    //                 BytesPerSector, SectorsPerCluster : Cardinal) : Boolean;
{-Return technical information about the specified drive.}
{GetDiskSpace}
 //GetDiskSpace(Drive : AnsiChar;
   //               var UserSpaceAvail  : Comp;           {space available to user}
     //             var TotalSpaceAvail : Comp;           {total space available}
       //           var DiskSize        : Comp) : Boolean;{disk size}
{-Return space information about the drive.}

 if GetDiskSpace('C',UserSpaceAvail,TotalSpaceAvail,DiskSize) then
     printF('UserSpaceAvail: %d TotalSpaceAvail: %d DiskSize: %d',
         [UserSpaceAvail div 1024,TotalSpaceAvail div 1024,DiskSize div 1024]);
{

{GetFileCreateDate}
 //GetFileCreateDate(const FileName : AnsiString) :
  //TDateTime;
{-Obtains file system time of file creation.}

{GetFileLastAccess}
 //StGetFileLastAccess(const FileName : AnsiString) :
  //TDateTime;
{-Obtains file system time of last file access.}

{GetFileLastModify}
 //GetFileLastModify(const FileName : AnsiString) :
  //TDateTime;
{-Obtains file system time of last file modification.}

{GetHomeFolder}
 //GetHomeFolder(aForceSlash : Boolean) : AnsiString;
{-Obtains the "Home Folder" for the current user}

{$IFNDEF CBuilder}
{GetLongPath}
 //GetLongPath(const APath : AnsiString) : AnsiString;
{-Returns the long filename version of a provided path.}
{$ENDIF}

{GetMachineName}
  //GetMachineName : AnsiString;
{-Returns the "Machine Name" for the current computer }
  //gethostname
{GetMediaID}
  //GetMediaID(Drive : AnsiChar; var MediaIDRec : MediaIDType) : Cardinal;
{-Get the media information (Volume Label, Serial Number) for the specified drive}

{GetParentFolder}
 //GetParentFolder(const APath : AnsiString; aForceSlash : Boolean) : AnsiString;
{-return the parent directory for the provided directory }

{GetShortPath}
 //GetShortPath(const APath : AnsiString) : AnsiString;
{-Returns the short filename version of a provided path.}

{GetSystemFolder}
 //GetSystemFolder(aForceSlash : Boolean) : AnsiString;
{-Returns the path to the Windows "System" folder".)

{GetTempFolder}
 //GetTempFolder(aForceSlash : boolean) : AnsiString;
{-Returns the path to the system temporary folder.}

{GetWindowsFolder}
 //StGetWindowsFolder(aForceSlash : boolean) : AnsiString;
{-Returns the path to the main "Windows" folder.}

{GetWorkingFolder}
 //GetWorkingFolder(aForceSlash : boolean) : AnsiString;
{-Returns the current working directory.}

{GlobalDateTimeToLocal}
 //GlobalDateTimeToLocal(const UTC: TStDateTimeRec; MinOffset: Integer): TStDateTimeRec; {!!.02}
{-adjusts a global date/time (UTC) to the local date/time}

{IsDirectory}
 //StIsDirectory(const DirName : AnsiString) : Boolean;
{-Return True if DirName is a directory.}
{IsDirectoryEmpty}
 //IsDirectoryEmpty(const S : AnsiString) : Integer;
{-checks if there are any entries in the directory}
{IsDriveReady}
 //IsDriveReady(Drive : AnsiChar) : Boolean;
{-determine if requested drive is accessible }
{IsFile}
 //IsFile(const FileName : AnsiString) : Boolean;
{-Determines if the provided path specifies a file.}
{IsFileArchive}
 //IsFileArchive(const S : AnsiString) : Integer;
{-checks if file's archive attribute is set}
{IsFileHidden}
 //IsFileHidden(const S : AnsiString) : Integer;
{-checks if file's hidden attribute is set}
{IsFileReadOnly}
  //IsFileReadOnly(const S : AnsiString) : Integer;
{-checks if file's readonly attribute is set}
{IsFileSystem}
 //IsFileSystem(const S : AnsiString) : Integer;
{-checks if file's system attribute is set}
{LocalDateTimeToGlobal}
 //LocalDateTimeToGlobal(const DT1: TStDateTimeRec; MinOffset: Integer): TStDateTimeRec; {!!.02}
{-adjusts a local date/time to the global (UTC) date/time}
{ReadVolumeLabel}
 //ReadVolumeLabel(var VolName : AnsiString; Drive : AnsiChar) : Cardinal;
{-Get the volume label for the specified drive.}
{SameFile}
 //SameFile(const FilePath1, FilePath2 : AnsiString; var ErrorCode : Integer) : Boolean;
{-Return True if FilePath1 and FilePath2 refer to the same physical file.}
{SetMediaID} {!!!! does not work on NT/2000 !!!!}
 //SetMediaID(Drive : AnsiChar; var MediaIDRec : MediaIDType) : Cardinal;
{-Set the media ID record for the specified drive.}

{SplitPath}
 //SplitPath(const APath : AnsiString; Parts : TStrings);
{-Splits the provided path into its component sub-paths}

{StDateTimeToFileTime}
 //StDateTimeToFileTime(const FileTime : TStDateTimeRec) : LongInt;  {!!.02}
{-Converts an TStDate and TStTime to a DOS date-time value.}
{StDateTimeToUnixTime}
 //StDateTimeToUnixTime(const DT1 : TStDateTimeRec) : Longint;   {!!.02}
{-converts a TStDateTimeRec to a time in Unix base (1970)}
{UnixTimeToStDateTime}
 //UnixTimeToStDateTime(UnixTime : Longint) : TStDateTimeRec;
{-converts a time in Unix base (1970) to a TStDateTimeRec}

{ValidDrive}
 //ValidDrive(Drive : AnsiChar) : Boolean;
{-Determine if the drive is a valid drive.}

{WriteVolumeLabel}
 //WriteVolumeLabel(const VolName : AnsiString; Drive : AnsiChar) : Cardinal;
{-Sets the volume label for the specified drive.}
  //DataSetSortedSearch

End.   

------------------------------------------------
Windows crashed again. I am the Blue Screen of Death. No one hears your screams.
Three things are certain: Death, taxes, and lost data. Guess which has occurred.
There is no place like 127.0.0.1 

http://en.wikipedia.org/wiki/Sneakers_%281992_film%29

with WebOutline.Outline.Items do
  begin
    {The following example code for adding nodes came from the Delphi 7 Help
     for TTreeView. Apologies for lack of imagination.}

    Clear; { remove any existing nodes }
    MyTreeNode1:= Add(nil,ExtendFakeData('RootTreeNode0'));{ Add a root node }
    { Add a child node to the node just added }
    AddChild(MyTreeNode1,ExtendFakeData('ChildNode0'));

    {Add another root node}
    MyTreeNode2 := Add(MyTreeNode1, ExtendFakeData('RootTreeNode1'));
    {add a child }
    AddChild(MyTreeNode2,ExtendFakeData('ChildNode1'));

    {Reuse MyTreeNode2}
    { and add a child node to it}
    MyTreeNode2 := WebOutline.Outline.Items[3];
    AddChild(MyTreeNode2,ExtendFakeData('ChildNode1a'));

    {Add a sibling}
    Add(MyTreeNode2,ExtendFakeData('ChildNode1b'));

    {add another root node}
    Add(MyTreeNode1, ExtendFakeData('RootTreeNode2'));
  end;
end;

procedure RotateBitmap(var htmpBitmapDC: TBitmap; var lWidth : Longint;
                  var lHeight : Longint; lRadians : real; origmap: TBitmap);
var
         I,J : Longint;               // loop counter
         //htmpBitmapDC : Longint;    // DC of the new bitmap
         lSine,lCosine : extended;          // sine,cosine used in rotation
         X1,X2,X3,Y1,Y2,Y3 : Longint;     // used in calculating new bitmap dimensions
         lMinX,lMaxX,lMinY,lMaxY: Longint;  
         lNewWidth,lNewHeight : Longint;  // width of new bitmap
         lSrcX,lSrcY  : Longint;   // x,y pixel coord we are blitting from the source image
         myrect: TRect;
begin
   // create a compatible DC from the one just brought
   // compute the sine/cosinse of the radians used to // rotate this image
    //tbmpDC:= tbmp.handle;
   lSine := Sin(lRadians);
   lCosine := Cos(lRadians);
   // compute the size of the new bitmap being created
   X1 := Round(-lHeight * lSine);
   Y1 := Round(lHeight * lCosine);
   X2 := Round(lWidth * lCosine - lHeight * lSine);
   Y2 := Round(lHeight * lCosine + lWidth * lSine);
   X3 := Round(lWidth * lCosine);
   Y3 := Round(lWidth * lSine);
   // figure out the max/min size of the new bitmap
   lMinX := Min(0, Min(X1, Min(X2, X3)));
   lMinY := Min(0, Min(Y1, Min(Y2, Y3)));
   lMaxX := Max(X1, Max(X2, X3));
   lMaxY := Max(Y1, Max(Y2, Y3));
   // set the new bitmap width/height
   lNewWidth:= lMaxX - lMinX;
   lNewHeight:= lMaxY - lMinY;
   // create a new bitmap based upon the new width/height of the // rotated bitmap
   //hNewBitmap := CreateCompatibleBitmap(hBitmapDC, lNewWidth, lNewHeight);
   htmpBitmapDC.height:= lNewHeight;
   htmpBitmapDC.width:= lNewWidth;
   //myRect:= Rect(0,0,lwidth,lheight); 
   //bfrm.Canvas.BrushCopy(MyRect, Image1.Picture.Bitmap, MyRect, clred);
   For I:= 0 To lNewWidth do begin
     For J:= 0 To lNewHeight do begin
       lSrcX:= Round((J + lMinX) * lCosine + (I + lMinY) * lSine);
       lSrcY:= Round((I + lMinY) * lCosine - (J + lMinX) * lSine);
       If (lSrcX >= 0) And (lSrcX <= lWidth) And
          (lSrcY >= 0) And (lSrcY <= lHeight) Then begin
         BitBlt(htmpBitmapDC.canvas.handle,J,I,lnewheight,lnewwidth,origmap.canvas.handle, lSrcX,lSrcY, SRCCOPY);
        end;
     end;
  end;
  //Image1.Refresh; 
  lWidth:= htmpBitmapDC.width;
  lHeight:= htmpBitmapDC.height;
End;
      
procedure TForm1_RotateTest2(Sender: TObject);
var
 lRadians: real;
 tbmpDC, H,W, Degrees: longint;
 mybitmap: TBitmap;
 MyRect: TRect;
begin
  mybitmap:= TBitmap.create;
  mybitmap.loadfromfile(exepath+'examples\citymax.bmp')
  image1.width:= mybitmap.width;
  image1.height:= mybitmap.height;
  //Image1.Picture.BitMap.PixelFormat:= pf24bit; 
  Image1.Picture.BitMap:= mybitmap;
  //mybitmap.Free;
  Degrees:= 45;
  lRadians:= PI * Degrees / 180;
  W:= Image1.Picture.Width;
  H:= Image1.Picture.Height;
  //W:= Image1.Width;
  //H:= Image1.Height;
  mybitmap:= TBitmap.create;
  RotateBitmap(mybitmap, W, H, lRadians, Image1.Picture.Bitmap);
  myRect:= Rect(0,0,W,H); 
  //bfrm.Canvas.CopyRect(MyOther,mybitmap.Canvas,MyRect);
  Image1.Width:= W;
  Image1.Height:= H;
  Image1.Picture.Bitmap.Width:= W;
  Image1.Picture.Bitmap.Height:= H;
  //Image1.Picture.bitmap:= mybitmap;
  BitBlt(Image1.Picture.Bitmap.Canvas.Handle,0,0,W,H,mybitmap.canvas.handle,0,0,SRCCopy);
  //bfrm.Canvas.BrushCopy(MyRect, Image1.Picture.Bitmap, MyRect, clRed);
  //for j:= 1 to image1.height do
    //image1.Picture.Bitmap.Canvas.pixels[j,j]:= clred; //test line
  mybitmap.Free;
  Image1.Refresh; 
end;



procedure CurrencyFormat;
var fSettings: TFormatSettings;
begin
  GetLocaleFormatSettings(LOCALE_SYSTEM_DEFAULT, fSettings);
  writeln(fsettings.timeAMString);
  writeln(fsettings.longDateFormat);
  writeln(fsettings.shortDateFormat);
    //writeln(currtostrF
  writeln('currtostrFS 1234.56 formats with setting as = '+
             CurrToStrFS(1234.5678989, ffCurrency, 4, fSettings));
             writeln(FloatToStrF(1234.5678989, ffCurrency, 6, 6));
  writeln('currtostrFS and back as = '+
             CurrToStrFS(strToCurr('1234.5678989'), ffCurrency, 4, fSettings));
end; 

procedure maxcalc_demo;
begin
  printF('this is %.6f',[maXcalc('ln(2)+fact(388)+2!')]); 
  printF('this is %.6f',[maXcalc('(4!)^(3!)')]); 
  printF('this is %.6f',[maXcalc('4!+4!')]); 
  printF('this is %.6f',[maXcalc('log(22)')]); 
  printF('this is logN %.6f',[maXcalc('2%256')]);
  writeln('ln(e): '+floattostr(maXcalc('ln(e)')))
  writeln(floattostr(maXcalc('e+10^6')))
  printF('addition theorem %.18f ',[maXcalc('sin(2.5/2)')])
  printF('addition theorem %.18f ',[maXcalc('sqrt(1/2*(1-cos(2.5)))')])
  printF('addition theorem2 %22.18f ',[maXcalc('cos(2.5/2)')])
  printF('addition theorem2 %22.18f ',[maXcalc('sqrt(1/2*(1+cos(2.5)))')])
  maXcalcF('2%256+2^10');
end; 

50000  = 0.693137180659968
100000 = 0.693142180584982
500000 = 0.693146180561005
10^6   = 0.693146680560255
5*10^6 = 0.693147080560068
50*10^6= 0.693147170560399    //Runtime: 0:28:22.422
ln(2)  = 0.693147180559945

(* zeta:= 0;
     for i:= 1 to 50000 do 
       if i mod 2 = 0 then
         zeta:= zeta - 1/i else
         zeta:= zeta + 1/i;
       writeln('harmonic alternate to ln(2): '+floattostr(zeta))  
       writeln(floattostr(maxcalc('ln(2)')))
       writeln(floattostr(ln2))    *)
   

type
  //PThreadSortArray = ^TThreadSortArray;
  //TThreadSortArray = array[0..MaxInt div SizeOf(Integer) - 1] of Integer;
  TSortArray =  array[1..ARRSIZE] of Integer;


  TSortThread = class(TThread)
  strict private
    FBox: TPaintBox;
    //FSortArray: PThreadSortArray;
    FSortArray: TSortArray;
    FSize: Integer;
    FA, FB, FI, FJ: Integer;
    Fbolthslowmotion: boolean;
    procedure DoVisualSwap;
    procedure Setbolthslowmotion(const Value: boolean);
  protected
    procedure Execute; override;
    procedure VisualSwap(A, B, I, J: Integer);
    procedure Sort(var A: array of Integer); virtual; abstract;
  public
    constructor Create(Box: TPaintBox; var SortArray: TSortArray);
    property  bolTHslowmotion: boolean read Fbolthslowmotion write Setbolthslowmotion;

  end;


procedure SIRegister_TThreadSortForm(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TForm', 'TThreadSortForm') do
  with CL.AddClassN(CL.FindClass('TForm'),'TThreadSortForm') do
  begin
    RegisterProperty('BubbleSortBox', 'TPaintBox', iptrw);
    RegisterProperty('SelectionSortBox', 'TPaintBox', iptrw);
    RegisterProperty('QuickSortBox', 'TPaintBox', iptrw);
    RegisterProperty('Bevel1', 'TBevel', iptrw);
    RegisterProperty('Bevel2', 'TBevel', iptrw);
    RegisterProperty('Bevel3', 'TBevel', iptrw);
    RegisterProperty('StartBtn', 'TButton', iptrw);
    RegisterProperty('Label1', 'TLabel', iptrw);
    RegisterProperty('Label2', 'TLabel', iptrw);
    RegisterProperty('Label3', 'TLabel', iptrw);
    RegisterProperty('BitBtn1slowmotion', 'TBitBtn', iptrw);
    RegisterMethod('Procedure StartBtnClick( Sender : TObject)');
    RegisterMethod('Procedure BubbleSortBoxPaint( Sender : TObject)');
    RegisterMethod('Procedure SelectionSortBoxPaint( Sender : TObject)');
    RegisterMethod('Procedure QuickSortBoxPaint( Sender : TObject)');
    RegisterMethod('Procedure FormCreate( Sender : TObject)');
    RegisterMethod('Procedure FormDestroy( Sender : TObject)');
    RegisterMethod('Procedure FormKeyPress( Sender: TObject; var Key: Char)');
    RegisterMethod('Procedure BitBtn1slowmotionClick( Sender : TObject)');
    RegisterMethod('Procedure ThreadDone( Sender : TObject)');
    RegisterProperty('mouse', 'boolean', iptrw);
  end;
end;




***********************************Thread Class *****************************
  TThread = class
  private
{$IFDEF MSWINDOWS}
    FHandle: THandle;
    FThreadID: THandle;
{$ENDIF}
{$IFDEF LINUX}
    // ** FThreadID is not THandle in Linux **
    FThreadID: Cardinal;
    FCreateSuspendedSem: TSemaphore;
    FInitialSuspendDone: Boolean;
{$ENDIF}
    FCreateSuspended: Boolean;
    FTerminated: Boolean;
    FSuspended: Boolean;
    FFreeOnTerminate: Boolean;
    FFinished: Boolean;
    FReturnValue: Integer;
    FOnTerminate: TNotifyEvent;
    FSynchronize: TSynchronizeRecord;
    FFatalException: TObject;
    procedure CallOnTerminate;
    class procedure Synchronize(ASyncRec: PSynchronizeRecord; QueueEvent: Boolean = False); overload;
{$IFDEF MSWINDOWS}
    function GetPriority: TThreadPriority;
    procedure SetPriority(Value: TThreadPriority);
{$ENDIF}
{$IFDEF LINUX}
    // ** Priority is an Integer value in Linux
    function GetPriority: Integer;
    procedure SetPriority(Value: Integer);
    function GetPolicy: Integer;
    procedure SetPolicy(Value: Integer);
{$ENDIF}
    procedure SetSuspended(Value: Boolean);
  protected
    procedure CheckThreadError(ErrCode: Integer); overload;
    procedure CheckThreadError(Success: Boolean); overload;
    procedure DoTerminate; virtual;
    procedure Execute; virtual; abstract;
    procedure Queue(AMethod: TThreadMethod); overload;
    procedure Synchronize(AMethod: TThreadMethod); overload;
    property ReturnValue: Integer read FReturnValue write FReturnValue;
    property Terminated: Boolean read FTerminated;
  public
    constructor Create(CreateSuspended: Boolean);
    destructor Destroy; override;
    procedure AfterConstruction; override;
    procedure Resume;
    procedure Suspend;
    procedure Terminate;
    function WaitFor: LongWord;
    class procedure Queue(AThread: TThread; AMethod: TThreadMethod); overload;
    class procedure RemoveQueuedEvents(AThread: TThread; AMethod: TThreadMethod);
    class procedure StaticQueue(AThread: TThread; AMethod: TThreadMethod);
    class procedure Synchronize(AThread: TThread; AMethod: TThreadMethod); overload;
    class procedure StaticSynchronize(AThread: TThread; AMethod: TThreadMethod);
    property FatalException: TObject read FFatalException;
    property FreeOnTerminate: Boolean read FFreeOnTerminate write FFreeOnTerminate;
{$IFDEF MSWINDOWS}
    property Handle: THandle read FHandle;
    property Priority: TThreadPriority read GetPriority write SetPriority;
{$ENDIF}
{$IFDEF LINUX}
    // ** Priority is an Integer **
    property Priority: Integer read GetPriority write SetPriority;
    property Policy: Integer read GetPolicy write SetPolicy;
{$ENDIF}
    property Suspended: Boolean read FSuspended write SetSuspended;
{$IFDEF MSWINDOWS}
    property ThreadID: THandle read FThreadID;
{$ENDIF}
{$IFDEF LINUX}
    // ** ThreadId is Cardinal **
    property ThreadID: Cardinal read FThreadID;
{$ENDIF}
    property OnTerminate: TNotifyEvent read FOnTerminate write FOnTerminate;
  end;
  
  
8 Tipps für die richtige Business-Software-Auswahl!

Die Auswahl einer Business Software lässt verschiedene Lösungswege zu, selten gibt es ein klares “Falsch”. Einige abenteuerliche Ansätze die geradewegs und unbeirrbar zu den bekannten Projektschwierigkeiten führen, sollte man aber vermeiden. Unsere 8 Tipps für die Auswahl der Business-Software-Lösung helfen Ihnen, die richtige Lösung sowie den passenden Software-Partner zu finden:

    Ganzes Angebot!
    Gehen Sie von der ganzen Angebotspalette aus und entscheiden Sie sich nicht zu schnell für einen Anbieter.
    Prozesse!
    Analysieren Sie zuerst die Prozesse und definieren Sie dann die funktionale Abdeckung der Anforderungen.
    Zukunft!
    Versuchen Sie auch die Anpassungen des Systems an zukünftige Bedürfnisse abzuschätzen.
    Potenzial des Partners!
    Beurteilen Sie das Potenzial des Systemlieferanten.
    Referenzen!
    Besuchen Sie Referenzkunden mit ähnlichen Anforderungen. Verlassen Sie sich nicht einfach auf Aussagen von Kollegen und Partnern.
    Drum prüfe wer sich bindet?
    Hinter der evaluierten Lösung stehen immer auch Menschen mit denen Sie in den nächsten zehn Jahren zu tun haben. Beziehen Sie daher Aspekte wie «Sympathie und Chemie» in die Überlegungen ein.
    Ressourcen!
    Nehmen Sie sich Zeit! Die Einführung eines ERP-Systems braucht Zeit und das Management muss voll und ganz hinter dem Projekt stehen und die nötigen Ressourcen dazu freigeben.
    Schulung, Schulung, Schulung!
    Und ganz wichtig: Unterschätzen Sie nicht die Anwender-Schulung. Sie ist wichtig und braucht Zeit!

 
http://www.hitekdev.com/delphi/BITMAPANIMATION.html

void draw() 
{
  fill(0, 2);
  rect(0, 0, width, height);
  pct += step;
  if (pct < 1.0) {
    x = beginX + (pct * distX);
    y = beginY + (pow(pct, exponent) * distY);
  }
  fill(255);
  ellipse(x, y, 20, 20);
}

function FindRootNode(ACaption: String; ATreeView: TTreeView): TTreeNode; 
var LCount: Integer; 
begin 
  result := nil; 
  LCount := 0; 
  while (LCount < ATreeView.Items.Count) and (result = nil) do 
  begin 
    if (ATreeView.Items.Item[LCount].Text = ACaption) and (ATreeView.Items.Item[LCount].Parent = nil) then 
      result := ATreeView.Items.Item[LCount]; 
    inc(LCount); 
  end; 
end;

...

var LDestNode: TTreeNode; 
begin 
  LDestNode := FindRootNode('category', TreeView1); 
  if LDestNode <> nil then 
  begin 
    TreeView1.Items.AddChild(LDestNode, 'node1'); 
    TreeView1.Items.AddChild(LDestNode, 'node2'); 
  end; 
end;

Loading TTreeView items from XML
Once we have the XML representation of the tree view items, we can use it to populate the tree view. When the application starts, the XML2Tree procedure is called to construct the tree. The tree parameter is a reference to a TTreeView component we are populating; the XMLDoc parameter points to a TXMLDocument component. In this case we are using the TXMLDocument component dropped on a form.

procedure XML2Tree(
          tree   : TTreeView; 
          XMLDoc : TXMLDocument);
var
  iNode : IXMLNode;

  procedure ProcessNode(
        Node : IXMLNode; 
        tn   : TTreeNode);
  var
    cNode : IXMLNode;
  begin
    if Node = nil then Exit;
    with Node do
    begin
      tn := tree.Items.AddChild(tn, Attributes['text']);
      tn.ImageIndex := Integer(Attributes['imageIndex']);
      tn.StateIndex := Integer(Attributes['stateIndex']);
    end;


    cNode := Node.ChildNodes.First;
    while cNode <> nil do
    begin
      ProcessNode(cNode, tn);
      cNode := cNode.NextSibling;
    end;
  end; (*ProcessNode*)
begin
  tree.Items.Clear;
  XMLDoc.FileName := ChangeFileExt(ParamStr(0),'.XML');
  XMLDoc.Active := True;

  iNode := XMLDoc.DocumentElement.ChildNodes.First;

  while iNode <> nil do
  begin
    ProcessNode(iNode,nil);
    iNode := iNode.NextSibling;
  end;

  XMLDoc.Active := False;
end;


http://jedi.grizzlydev.com/www/art_usingtreeviews.html

In modern times, a configuration file has to be an XML standard so you want to parse that file to get the elements from corresponding nodes. 
Answer:


First you have to import the Type library. This will create a wrapper class for that component and all you have to do is to name it in uses in your unit. 
I used msxml.dll(Version 2.0) to install the XML parsing components in the IDE through the Import Type Library option. 
See for more details: 

Importing XML DOM Parser in Delphi /ID 2021 


Second we produce a simple XML file like a configuration file: 
(Name the file myconfig.xml) 
(Strange things happen (cause the xml interpreter in d3k-editor) with a well-formed file after submit the article, so I had to cancel first tags between databases and databases ) 
please download the file: http://max.kleiner.com/myconfig.xml 
****************************************************************************** 
----Simple Browser started----