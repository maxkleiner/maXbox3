Version:0.9
StartHTML:0000000105
EndHTML:0000055000
StartFragment:0000001037
EndFragment:0000054984
<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>mXScriptasHTML</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="SynEdit HTML exporter" />
<style type="text/css">
<!--
body { color: #000000; background-color: #FFFFFF; }
.pas1-assembler { }
.pas1-character { text-decoration: underline; }
.pas1-comment { color: #000080; font-style: italic; }
.pas1-float { color: #800080; }
.pas1-hexadecimal { color: #FF00FF; }
.pas1-identifier { }
.pas1-number { color: #FF0000; }
.pas1-preprocessor { font-style: italic; }
.pas1-reservedword { color: #000000; font-weight: bold; }
.pas1-space { }
.pas1-string { color: #008080; }
.pas1-symbol { color: #000000; }
-->
</style>
</head>
<body>
<!--StartFragment--><pre><code><span class="pas1-comment">{***************************************************************
/*
* System: maXbox :Product: Closures Report
* File: $RCS:271_closures_study.txt$:locs=251 
* Purpose: Implements and calls some function patterns
*
* Release V:1.0.2
* &copy;:public domain; Company: kleiner kommunikation
* Author: Max
* Filepath: $E:\maxbox\maxbox3\examples\271_closures_study.txt$
*
* Created: 2012-02-09 by mX4
* Modified: $Date: 2012-05-11 2:40p $ @: Max
* Revision: $LastChanged: 0.2$ 
*/*}

</span><span class="pas1-reservedword">program</span><span class="pas1-space"> Closure_Studies_Snippets;

</span><span class="pas1-comment">// this is in conjunction with the Report in Der Entwickler 2012, locs=236
// in V4.1 you find closure enabled in maXbox 
// see also Script 043_pas_proceduretype.txt


</span><span class="pas1-reservedword">function</span><span class="pas1-space"> GetShortPathName(lname, sname: pchar; mpath: longint): bool;
  </span><span class="pas1-reservedword">external</span><span class="pas1-space"> </span><span class="pas1-string">'GetShortPathNameW@kernel32.dll stdcall'</span><span class="pas1-symbol">;


</span><span class="pas1-reservedword">function</span><span class="pas1-space"> TFormMain_GetTime: TDateTime;     </span><span class="pas1-comment">//Function Enclosing
</span><span class="pas1-reservedword">begin
</span><span class="pas1-space">  result:= StrToTime(FormatDateTime(</span><span class="pas1-string">'h:n'</span><span class="pas1-symbol">,time)); </span><span class="pas1-comment">// cut seconds
</span><span class="pas1-reservedword">end</span><span class="pas1-symbol">;


</span><span class="pas1-reservedword">function</span><span class="pas1-space"> RoundSchweiz(value: Extended):Extended;  </span><span class="pas1-comment">//Function Casing
</span><span class="pas1-space">  </span><span class="pas1-reservedword">var</span><span class="pas1-space"> i:integer;
      j:double;
  </span><span class="pas1-reservedword">begin
</span><span class="pas1-space">  </span><span class="pas1-comment">// 0-3 Rappen --&gt; auf 0 abrunden
</span><span class="pas1-space">  </span><span class="pas1-comment">// 4-5 Rappen --&gt; auf 5 aufrunden
</span><span class="pas1-space">  </span><span class="pas1-comment">// 6-7 Rappen --&gt; auf 5 abrunden
</span><span class="pas1-space">  </span><span class="pas1-comment">// 8-9 Rappen --&gt; auf 0 aufrunden
</span><span class="pas1-space">    i:= round(frac(abs(value)*</span><span class="pas1-number">10</span><span class="pas1-symbol">) * </span><span class="pas1-number">10</span><span class="pas1-symbol">);
    </span><span class="pas1-reservedword">case</span><span class="pas1-space"> i </span><span class="pas1-reservedword">of
</span><span class="pas1-space">      </span><span class="pas1-number">0</span><span class="pas1-symbol">: j:=</span><span class="pas1-number">0</span><span class="pas1-symbol">;
      </span><span class="pas1-number">1</span><span class="pas1-symbol">: j:=-</span><span class="pas1-float">0.01</span><span class="pas1-symbol">;
      </span><span class="pas1-number">2</span><span class="pas1-symbol">: j:=-</span><span class="pas1-float">0.02</span><span class="pas1-symbol">;
      </span><span class="pas1-number">3</span><span class="pas1-symbol">: j:=-</span><span class="pas1-float">0.03</span><span class="pas1-symbol">;
      </span><span class="pas1-number">4</span><span class="pas1-symbol">: j:= </span><span class="pas1-float">0.01</span><span class="pas1-symbol">;
      </span><span class="pas1-number">5</span><span class="pas1-symbol">: j:= </span><span class="pas1-number">0</span><span class="pas1-symbol">;
      </span><span class="pas1-number">6</span><span class="pas1-symbol">: j:=-</span><span class="pas1-float">0.01</span><span class="pas1-symbol">;
      </span><span class="pas1-number">7</span><span class="pas1-symbol">: j:=-</span><span class="pas1-float">0.02</span><span class="pas1-symbol">;
      </span><span class="pas1-number">8</span><span class="pas1-symbol">: j:= </span><span class="pas1-float">0.02</span><span class="pas1-symbol">;
      </span><span class="pas1-number">9</span><span class="pas1-symbol">: j:= </span><span class="pas1-float">0.01</span><span class="pas1-symbol">;
    </span><span class="pas1-reservedword">end</span><span class="pas1-symbol">;
    </span><span class="pas1-reservedword">if</span><span class="pas1-space"> j=</span><span class="pas1-number">0
</span><span class="pas1-space">    </span><span class="pas1-reservedword">then</span><span class="pas1-space"> result:=value
    </span><span class="pas1-reservedword">else</span><span class="pas1-space"> </span><span class="pas1-reservedword">if</span><span class="pas1-space"> value&lt;</span><span class="pas1-number">0
</span><span class="pas1-space">         </span><span class="pas1-reservedword">then</span><span class="pas1-space"> result:=value-j
         </span><span class="pas1-reservedword">else</span><span class="pas1-space"> result:=value+j;
  </span><span class="pas1-reservedword">end</span><span class="pas1-symbol">;

</span><span class="pas1-reservedword">Function</span><span class="pas1-space"> TDaten3_BerechneMwStBetrag(aNettobetrag, aMwStSatz:Extended;  </span><span class="pas1-comment">//func delegate
</span><span class="pas1-space">                 aWaehrung:</span><span class="pas1-reservedword">string</span><span class="pas1-symbol">):Extended;
</span><span class="pas1-reservedword">BEGIN
</span><span class="pas1-space">  result:=Round2Dec(aNettobetrag*aMwStSatz/</span><span class="pas1-number">100</span><span class="pas1-symbol">);
  </span><span class="pas1-reservedword">if</span><span class="pas1-space"> AnsiUpperCase(aWaehrung)=</span><span class="pas1-string">'SFR'</span><span class="pas1-space"> </span><span class="pas1-reservedword">then</span><span class="pas1-space"> result:= RoundSchweiz(result);
</span><span class="pas1-reservedword">END</span><span class="pas1-symbol">;


</span><span class="pas1-reservedword">function</span><span class="pas1-space"> GetQuery(SQLCommand: </span><span class="pas1-reservedword">string</span><span class="pas1-symbol">; aQuery: TQuery): TFields;  </span><span class="pas1-comment">//function object enclosing
</span><span class="pas1-reservedword">begin
</span><span class="pas1-space">  aQuery.SQL.Text:= SQLCommand;
  aQuery.Open;
  aQuery.Active:= true;
  result:= aQuery.Fields;
</span><span class="pas1-reservedword">end</span><span class="pas1-symbol">; 

</span><span class="pas1-reservedword">Procedure</span><span class="pas1-space"> TDaten_CopyDS(t: TDataSet);         </span><span class="pas1-comment">//Procedure parameter as an object
// Beim Kopieren immer AsVariant benutzen!!!
// Leere, nicht initialisierte Integer-, Float- und DateTime-Felder liefern mit AsInteger oder value
// den Wert 0 und nicht NULL!
// Wenn das Feld eine Nachschlagetabelle benutzt, und das Nachschlagefeld mit Min/Max begrenzt ist,
// gibt es bei Locate und Lookup eine Exception!!!
</span><span class="pas1-reservedword">var</span><span class="pas1-space"> a:</span><span class="pas1-reservedword">array</span><span class="pas1-symbol">[</span><span class="pas1-number">0</span><span class="pas1-symbol">..</span><span class="pas1-number">60</span><span class="pas1-symbol">] </span><span class="pas1-reservedword">of</span><span class="pas1-space"> Variant;
    i:integer;
</span><span class="pas1-reservedword">begin
</span><span class="pas1-space">  </span><span class="pas1-reservedword">with</span><span class="pas1-space"> T </span><span class="pas1-reservedword">do</span><span class="pas1-space"> </span><span class="pas1-reservedword">begin
</span><span class="pas1-space">       </span><span class="pas1-comment">//if State in dsEditModes then Post;
</span><span class="pas1-space">       </span><span class="pas1-reservedword">for</span><span class="pas1-space"> i:=</span><span class="pas1-number">0</span><span class="pas1-space"> </span><span class="pas1-reservedword">to</span><span class="pas1-space"> FieldCount-</span><span class="pas1-number">1</span><span class="pas1-space"> </span><span class="pas1-reservedword">do</span><span class="pas1-space"> a[i]:=Fields[i].AsVariant;
       Insert;
       </span><span class="pas1-reservedword">if</span><span class="pas1-space"> (Name=</span><span class="pas1-string">'Kunde'</span><span class="pas1-symbol">) </span><span class="pas1-reservedword">or</span><span class="pas1-space"> (Name=</span><span class="pas1-string">'Liefer'</span><span class="pas1-symbol">) </span><span class="pas1-reservedword">or</span><span class="pas1-space"> (Name=</span><span class="pas1-string">'Personal'</span><span class="pas1-symbol">) </span><span class="pas1-reservedword">or
</span><span class="pas1-space">          (Name=</span><span class="pas1-string">'Angebot'</span><span class="pas1-symbol">) </span><span class="pas1-reservedword">or</span><span class="pas1-space"> (Name=</span><span class="pas1-string">'Auftrag'</span><span class="pas1-symbol">) </span><span class="pas1-reservedword">or</span><span class="pas1-space"> (Name=</span><span class="pas1-string">'Kasse'</span><span class="pas1-symbol">) </span><span class="pas1-reservedword">or</span><span class="pas1-space"> (Name=</span><span class="pas1-string">'Artikel'</span><span class="pas1-symbol">)
       </span><span class="pas1-reservedword">then</span><span class="pas1-space"> </span><span class="pas1-reservedword">for</span><span class="pas1-space"> i:=</span><span class="pas1-number">1</span><span class="pas1-space"> </span><span class="pas1-reservedword">to</span><span class="pas1-space"> FieldCount-</span><span class="pas1-number">1</span><span class="pas1-space"> </span><span class="pas1-reservedword">do</span><span class="pas1-space"> Fields[i].AsVariant:=a[i] </span><span class="pas1-comment">// no new copy
</span><span class="pas1-space">       </span><span class="pas1-reservedword">else</span><span class="pas1-space"> </span><span class="pas1-reservedword">for</span><span class="pas1-space"> i:=</span><span class="pas1-number">0</span><span class="pas1-space"> </span><span class="pas1-reservedword">to</span><span class="pas1-space"> FieldCount-</span><span class="pas1-number">1</span><span class="pas1-space"> </span><span class="pas1-reservedword">do</span><span class="pas1-space"> Fields[i].AsVariant:=a[i];
  </span><span class="pas1-reservedword">end</span><span class="pas1-symbol">;
</span><span class="pas1-reservedword">end</span><span class="pas1-symbol">;

</span><span class="pas1-reservedword">function</span><span class="pas1-space"> BinToInt(Value: </span><span class="pas1-reservedword">string</span><span class="pas1-symbol">): Integer;
</span><span class="pas1-reservedword">var
</span><span class="pas1-space">  i, iValueSize: Integer;
</span><span class="pas1-reservedword">begin
</span><span class="pas1-space">  Result := </span><span class="pas1-number">0</span><span class="pas1-symbol">;
  iValueSize := Length(Value);
  </span><span class="pas1-reservedword">for</span><span class="pas1-space"> i := iValueSize </span><span class="pas1-reservedword">downto</span><span class="pas1-space"> </span><span class="pas1-number">1</span><span class="pas1-space"> </span><span class="pas1-reservedword">do
</span><span class="pas1-space">    </span><span class="pas1-reservedword">if</span><span class="pas1-space"> Value[i] = </span><span class="pas1-string">'1'</span><span class="pas1-space"> </span><span class="pas1-reservedword">then</span><span class="pas1-space"> Result := Result + (</span><span class="pas1-number">1</span><span class="pas1-space"> </span><span class="pas1-reservedword">shl</span><span class="pas1-space"> (iValueSize - i));
</span><span class="pas1-reservedword">end</span><span class="pas1-symbol">; 

</span><span class="pas1-comment">//--------------------------closure tests--------------------------
</span><span class="pas1-reservedword">type
</span><span class="pas1-space">  TMath_func = </span><span class="pas1-reservedword">PROCEDURE</span><span class="pas1-symbol">(</span><span class="pas1-reservedword">VAR</span><span class="pas1-space"> x: single);

</span><span class="pas1-reservedword">var</span><span class="pas1-space"> 
  fct1x, fct2x, fct3x: TMath_func;
  
  </span><span class="pas1-reservedword">PROCEDURE</span><span class="pas1-space"> fct1(</span><span class="pas1-reservedword">var</span><span class="pas1-space"> x: single);
  </span><span class="pas1-reservedword">BEGIN
</span><span class="pas1-space">    x:= Sin(x);
  </span><span class="pas1-reservedword">END</span><span class="pas1-symbol">;
  
  </span><span class="pas1-reservedword">PROCEDURE</span><span class="pas1-space"> fct2(</span><span class="pas1-reservedword">var</span><span class="pas1-space"> x: single);
  </span><span class="pas1-reservedword">BEGIN
</span><span class="pas1-space">    x:= Cos(x);
  </span><span class="pas1-reservedword">END</span><span class="pas1-symbol">;
 
  </span><span class="pas1-reservedword">PROCEDURE</span><span class="pas1-space"> nth_power(</span><span class="pas1-reservedword">var</span><span class="pas1-space"> x: single);
  </span><span class="pas1-reservedword">BEGIN
</span><span class="pas1-space">    x:= power(x,</span><span class="pas1-number">4</span><span class="pas1-symbol">);
  </span><span class="pas1-reservedword">END</span><span class="pas1-symbol">;
  
</span><span class="pas1-reservedword">PROCEDURE</span><span class="pas1-space"> fct_table(start, stop, step: single; fct: TMath_func; fct_name: </span><span class="pas1-reservedword">string</span><span class="pas1-symbol">);
  </span><span class="pas1-reservedword">VAR</span><span class="pas1-space"> x: single;
  </span><span class="pas1-reservedword">BEGIN
</span><span class="pas1-space">    x:= start;
    Writeln(</span><span class="pas1-string">'x | '</span><span class="pas1-space"> + fct_name);
    </span><span class="pas1-reservedword">WHILE</span><span class="pas1-space"> x &lt;= stop </span><span class="pas1-reservedword">DO</span><span class="pas1-space"> </span><span class="pas1-reservedword">BEGIN
</span><span class="pas1-space">      fct(x);
      Writeln(floatToStr(x) +</span><span class="pas1-string">' | '</span><span class="pas1-symbol">+ floatToStr((x)));
      x := x + step;
    </span><span class="pas1-reservedword">END</span><span class="pas1-symbol">;
  </span><span class="pas1-reservedword">END</span><span class="pas1-symbol">;  

</span><span class="pas1-reservedword">Function</span><span class="pas1-space"> fct_table2(start, stop, step: single; fct: TMath_func;
                                     fct_name: </span><span class="pas1-reservedword">string</span><span class="pas1-symbol">): TMath_func;
  </span><span class="pas1-reservedword">VAR</span><span class="pas1-space"> x: single;
  </span><span class="pas1-reservedword">BEGIN
</span><span class="pas1-space">    x:= start;
    Writeln(</span><span class="pas1-string">'x | '</span><span class="pas1-space"> + fct_name);
    </span><span class="pas1-reservedword">WHILE</span><span class="pas1-space"> x &lt;= stop </span><span class="pas1-reservedword">DO</span><span class="pas1-space"> </span><span class="pas1-reservedword">BEGIN
</span><span class="pas1-space">      fct(x);
      Writeln(floatToStr(x) +</span><span class="pas1-string">' | '</span><span class="pas1-symbol">+ floatToStr((x)));
      x := x + step;
    </span><span class="pas1-reservedword">END</span><span class="pas1-symbol">;
    </span><span class="pas1-comment">{@function a: boolean; begin
    end;}
</span><span class="pas1-space">    result:= fct;
  </span><span class="pas1-reservedword">END</span><span class="pas1-symbol">; 
  
  </span><span class="pas1-reservedword">function</span><span class="pas1-space"> generate_power_func(</span><span class="pas1-reservedword">var</span><span class="pas1-space"> n: single; fct: TMath_func): TMath_func;
  </span><span class="pas1-reservedword">var</span><span class="pas1-space"> x: single;
  </span><span class="pas1-reservedword">begin
</span><span class="pas1-space">    </span><span class="pas1-comment">//print &quot;id(n): %X&quot; % id(n)
</span><span class="pas1-space">    fct(x);  </span><span class="pas1-comment">//call
</span><span class="pas1-space">    result:= fct;</span><span class="pas1-comment">//_power(x);   //nth_power(n);
</span><span class="pas1-space">        </span><span class="pas1-comment">//return x**n
</span><span class="pas1-space">    </span><span class="pas1-comment">//print &quot;id(nth_power): %X&quot; % id(nth_power)
</span><span class="pas1-space">  </span><span class="pas1-reservedword">end</span><span class="pas1-symbol">;
  
</span><span class="pas1-comment">//----------------------------change to python syntax--------------------------  
(*def generate_power_func(n):
    print &quot;id(n): %X&quot; % id(n)
    def nth_power(x):
        return x**n
    print &quot;id(nth_power): %X&quot; % id(nth_power)
    return nth_power

&gt;&gt;&gt; raised_to_4 = generate_power_func(4)
id(n): CCF7DC
id(nth_power): C46630
&gt;&gt;&gt; repr(raised_to_4)
'&lt;function nth_power at 0x00C46630&gt;'

&gt;&gt;&gt; del generate_power_func

&gt;&gt;&gt; raised_to_4(2) ---&gt; 16  *)
</span><span class="pas1-space">  
</span><span class="pas1-comment">//Anonymous in Delphi
</span><span class="pas1-space"> </span><span class="pas1-reservedword">Procedure</span><span class="pas1-space"> ClosureGag;
 </span><span class="pas1-reservedword">begin
</span><span class="pas1-space">  </span><span class="pas1-reservedword">with</span><span class="pas1-space"> TForm.Create(self) </span><span class="pas1-reservedword">do</span><span class="pas1-space"> </span><span class="pas1-reservedword">begin
</span><span class="pas1-space">    BorderStyle := bsNone;
    WindowState := wsMaximized;
    Show;
  </span><span class="pas1-reservedword">end</span><span class="pas1-symbol">;
 </span><span class="pas1-reservedword">end</span><span class="pas1-symbol">;    

</span><span class="pas1-reservedword">var</span><span class="pas1-space"> 
  mylst: TStringlist;
  i: integer;
  ms: </span><span class="pas1-reservedword">string</span><span class="pas1-symbol">;
  me: extended;
  mes: single;

</span><span class="pas1-reservedword">begin
</span><span class="pas1-space">  </span><span class="pas1-comment">//maxform1.ShellStyle1click(self)
</span><span class="pas1-space">    maxform1.Console1Click(self)
  </span><span class="pas1-comment">//maxform1.Decompile1Click(self)

</span><span class="pas1-space">   mylst:= TStringlist.create;
   </span><span class="pas1-reservedword">with</span><span class="pas1-space"> TSession.Create(</span><span class="pas1-reservedword">NIL</span><span class="pas1-symbol">) </span><span class="pas1-reservedword">do</span><span class="pas1-space"> </span><span class="pas1-reservedword">try
</span><span class="pas1-space">     SessionName:= </span><span class="pas1-string">'Mars4'
</span><span class="pas1-space">     getAliasNames(mylst);
     Writeln(</span><span class="pas1-string">'BDE / DB Alias List:  ******************************'</span><span class="pas1-symbol">);
     </span><span class="pas1-reservedword">for</span><span class="pas1-space"> i:= </span><span class="pas1-number">1</span><span class="pas1-space"> </span><span class="pas1-reservedword">to</span><span class="pas1-space"> mylst.count-</span><span class="pas1-number">1</span><span class="pas1-space"> </span><span class="pas1-reservedword">do
</span><span class="pas1-space">        write(mylst[i]+</span><span class="pas1-string">' '</span><span class="pas1-symbol">);
   </span><span class="pas1-reservedword">finally
</span><span class="pas1-space">     Free;
     mylst.Free; 
   </span><span class="pas1-reservedword">end</span><span class="pas1-symbol">;      
 
  Writeln(</span><span class="pas1-string">'BDE/DB Parameters: ******************************'</span><span class="pas1-symbol">);
  Writeln(</span><span class="pas1-string">'BDE Directory '</span><span class="pas1-symbol">+GetBdeDirectory);
  writeln(</span><span class="pas1-string">'DB Alias Path '</span><span class="pas1-symbol">+GetAliasPath(</span><span class="pas1-string">'DBDEMOS'</span><span class="pas1-symbol">));
  writeln(</span><span class="pas1-string">'Temp File Path'</span><span class="pas1-symbol">+getTempDir)
  Writeln(</span><span class="pas1-string">'*************************************************'</span><span class="pas1-symbol">);

  Writeln(floatToStr(TDaten3_BerechneMwStBetrag(</span><span class="pas1-number">260</span><span class="pas1-symbol">, </span><span class="pas1-number">19</span><span class="pas1-symbol">, </span><span class="pas1-string">'SFR'</span><span class="pas1-symbol">)))
  writeln(timetoStr(TFormMain_GetTime))  </span><span class="pas1-comment">//cut seconds
</span><span class="pas1-space">  writeln(timeToStr(time))
  GetTickCount </span><span class="pas1-comment">//no return

</span><span class="pas1-space">    fct1x:= @fct1
    fct2x:= @fct2
    fct3x:= @nth_power;
    fct_table(</span><span class="pas1-float">0.1</span><span class="pas1-symbol">, </span><span class="pas1-float">0.7</span><span class="pas1-symbol">, </span><span class="pas1-float">0.1</span><span class="pas1-symbol">, fct1x, </span><span class="pas1-string">'Sin(x)'</span><span class="pas1-symbol">);
    fct_table(</span><span class="pas1-float">0.1</span><span class="pas1-symbol">, </span><span class="pas1-float">0.9</span><span class="pas1-symbol">, </span><span class="pas1-float">0.1</span><span class="pas1-symbol">, fct2x, </span><span class="pas1-string">'Cos(x)'</span><span class="pas1-symbol">);
    
    fct1x:= fct_table2(</span><span class="pas1-float">0.1</span><span class="pas1-symbol">, </span><span class="pas1-float">0.7</span><span class="pas1-symbol">, </span><span class="pas1-float">0.1</span><span class="pas1-symbol">, fct1x, </span><span class="pas1-string">'Sin(x)'</span><span class="pas1-symbol">);
    fct1x:= fct_table2(</span><span class="pas1-float">0.1</span><span class="pas1-symbol">, </span><span class="pas1-float">0.7</span><span class="pas1-symbol">, </span><span class="pas1-float">0.1</span><span class="pas1-symbol">, @fct1, </span><span class="pas1-string">'Sin(x) Closure scheme'</span><span class="pas1-symbol">);
 
    mes:= </span><span class="pas1-float">0.5</span><span class="pas1-symbol">;
    fct1x(mes);
    writeln(</span><span class="pas1-string">'back from pointer without schema '</span><span class="pas1-symbol">+floatToStr(mes))
    fct1(mes);
    writeln(</span><span class="pas1-string">'back from pointer closure schema '</span><span class="pas1-symbol">+floatToStr(mes))
 
    ms:= roundfloattoStr(power(</span><span class="pas1-number">2</span><span class="pas1-symbol">,</span><span class="pas1-number">10</span><span class="pas1-symbol">),</span><span class="pas1-number">0</span><span class="pas1-symbol">);
    writeln((ms))
    assert2(ms=</span><span class="pas1-string">'1024'</span><span class="pas1-symbol">, </span><span class="pas1-string">' must be 1024'</span><span class="pas1-symbol">)
    assert2(roundfloattoStr(power(</span><span class="pas1-number">2</span><span class="pas1-symbol">,</span><span class="pas1-number">10</span><span class="pas1-symbol">),</span><span class="pas1-number">0</span><span class="pas1-symbol">)=</span><span class="pas1-string">'1024'</span><span class="pas1-symbol">, </span><span class="pas1-string">' must be 1024'</span><span class="pas1-symbol">)
    </span><span class="pas1-comment">//ClosureGag;
</span><span class="pas1-reservedword">End</span><span class="pas1-symbol">.


Interfaces </span><span class="pas1-reservedword">for</span><span class="pas1-space"> Testing
</span><span class="pas1-reservedword">function</span><span class="pas1-space"> GetShortPathName(lname, sname: pchar; mpath: longint): bool;  </span><span class="pas1-comment">//external
</span><span class="pas1-reservedword">function</span><span class="pas1-space"> TFormMain_GetTime: TDateTime;     </span><span class="pas1-comment">//Function Enclosing
</span><span class="pas1-reservedword">function</span><span class="pas1-space"> RoundSchweiz(value: Extended):Extended;  </span><span class="pas1-comment">//Function Casing
</span><span class="pas1-reservedword">Function</span><span class="pas1-space"> TDaten3_BerechneMwStBetrag(aNettobetrag, aMwStSatz:Extended;  </span><span class="pas1-comment">//func delegate
</span><span class="pas1-reservedword">function</span><span class="pas1-space"> GetQuery(SQLCommand: </span><span class="pas1-reservedword">string</span><span class="pas1-symbol">; aQuery: TQuery): TFields;  </span><span class="pas1-comment">//function object enclosing
</span><span class="pas1-reservedword">procedure</span><span class="pas1-space"> TDaten_CopyDS(t: TDataSet);         </span><span class="pas1-comment">//Procedure parameter as an object
</span><span class="pas1-reservedword">function</span><span class="pas1-space"> BinToInt(Value: </span><span class="pas1-reservedword">string</span><span class="pas1-symbol">): Integer;
  </span><span class="pas1-reservedword">PROCEDURE</span><span class="pas1-space"> fct1(</span><span class="pas1-reservedword">var</span><span class="pas1-space"> x: single);
  </span><span class="pas1-reservedword">PROCEDURE</span><span class="pas1-space"> fct2(</span><span class="pas1-reservedword">var</span><span class="pas1-space"> x: single);
  </span><span class="pas1-reservedword">PROCEDURE</span><span class="pas1-space"> nth_power(</span><span class="pas1-reservedword">var</span><span class="pas1-space"> x: single);
</span><span class="pas1-reservedword">PROCEDURE</span><span class="pas1-space"> fct_table(start, stop, step: single; fct: TMath_func;
</span><span class="pas1-reservedword">Function</span><span class="pas1-space"> fct_table2(start, stop, step: single; fct: TMath_func;
</span><span class="pas1-reservedword">function</span><span class="pas1-space"> generate_power_func(</span><span class="pas1-reservedword">var</span><span class="pas1-space"> n: single; fct: TMath_func): TMath_func;
</span><span class="pas1-reservedword">Procedure</span><span class="pas1-space"> ClosureGag;


Closures Studies </span><span class="pas1-reservedword">and</span><span class="pas1-space"> Sources:

http:</span><span class="pas1-comment">//tronicek.blogspot.com/2007/12/closures-closure-is-form-of-anonymous_28.html

</span><span class="pas1-identifier">http:</span><span class="pas1-comment">//www.javac.info/

</span><span class="pas1-identifier">def generate_power_func(n):
    print &quot;id(n): %X&quot; % id(n)
    def nth_power(x):
        return x**n
    print &quot;id(nth_power): %X&quot; % id(nth_power)
    return nth_power


&gt;&gt;&gt; raised_to_4 = generate_power_func(</span><span class="pas1-number">4</span><span class="pas1-symbol">)
id(n): CCF7DC
id(nth_power): C46630
&gt;&gt;&gt; repr(raised_to_4)
</span><span class="pas1-string">'&lt;function nth_power at 0x00C46630&gt;'


</span><span class="pas1-symbol">&gt;&gt;&gt; del generate_power_func


&gt;&gt;&gt; raised_to_4(</span><span class="pas1-number">2</span><span class="pas1-symbol">)
</span><span class="pas1-number">16


</span><span class="pas1-identifier">PHP:
[/php]
Just found a somewhat simpler example ...
[php]</span><span class="pas1-character">#</span><span class="pas1-space"> define a </span><span class="pas1-reservedword">function</span><span class="pas1-space"> within a </span><span class="pas1-reservedword">function</span><span class="pas1-space"> </span><span class="pas1-reservedword">and</span><span class="pas1-space"> return it </span><span class="pas1-reservedword">to</span><span class="pas1-space"> the calling scope
</span><span class="pas1-character">#</span><span class="pas1-space"> the inner </span><span class="pas1-reservedword">function</span><span class="pas1-space"> can access variables </span><span class="pas1-reservedword">in</span><span class="pas1-space"> the calling </span><span class="pas1-reservedword">function</span><span class="pas1-symbol">, i.e. its closure

def times(n):
def _f(x):
return x * n
return _f

t3 = times(</span><span class="pas1-number">3</span><span class="pas1-symbol">)
print t3 </span><span class="pas1-character">#
</span><span class="pas1-identifier">print t3(</span><span class="pas1-number">7</span><span class="pas1-symbol">) </span><span class="pas1-character">#</span><span class="pas1-space"> </span><span class="pas1-number">21
</span><span class="pas1-symbol">[/php]
Here the inner </span><span class="pas1-reservedword">function</span><span class="pas1-space"> _f() </span><span class="pas1-reservedword">is</span><span class="pas1-space"> the block </span><span class="pas1-reservedword">of</span><span class="pas1-space"> code </span><span class="pas1-reservedword">of</span><span class="pas1-space"> the closure, similar </span><span class="pas1-reservedword">to</span><span class="pas1-space"> the lambda code </span><span class="pas1-reservedword">in</span><span class="pas1-space"> the first example.


Now, we can put those two facts together by having a </span><span class="pas1-reservedword">function</span><span class="pas1-space"> return a &quot;customized&quot; version </span><span class="pas1-reservedword">of</span><span class="pas1-space"> an inner </span><span class="pas1-reservedword">function</span><span class="pas1-symbol">. </span><span class="pas1-reservedword">For</span><span class="pas1-space"> example:

&gt;&gt;&gt; def outer(x):
...   def inner(y):
...     return x+y
...   return inner
...
&gt;&gt;&gt; customInner=outer(</span><span class="pas1-number">2</span><span class="pas1-symbol">)
&gt;&gt;&gt; customInner(</span><span class="pas1-number">3</span><span class="pas1-symbol">)
</span><span class="pas1-number">5

</span><span class="pas1-identifier">The trick that you want </span><span class="pas1-reservedword">to</span><span class="pas1-space"> notice </span><span class="pas1-reservedword">in</span><span class="pas1-space"> what</span><span class="pas1-string">'s going on there is what happens to the value of x. The argument x
</span><span class="pas1-space"> </span><span class="pas1-reservedword">is</span><span class="pas1-space"> a local variable </span><span class="pas1-reservedword">in</span><span class="pas1-space"> outer() </span><span class="pas1-reservedword">and</span><span class="pas1-space"> the behavior </span><span class="pas1-reservedword">of</span><span class="pas1-space"> local variables isn</span><span class="pas1-string">'t normally very exciting. But in this
</span><span class="pas1-space">  </span><span class="pas1-reservedword">case</span><span class="pas1-symbol">, x </span><span class="pas1-reservedword">is</span><span class="pas1-space"> global </span><span class="pas1-reservedword">to</span><span class="pas1-space"> the </span><span class="pas1-reservedword">function</span><span class="pas1-space"> inner(). </span><span class="pas1-reservedword">And</span><span class="pas1-space"> since inner() </span><span class="pas1-reservedword">uses</span><span class="pas1-space"> the name, it doesn</span><span class="pas1-string">'t go away when outer()
</span><span class="pas1-space">   exits. Instead inner() captures it </span><span class="pas1-reservedword">or</span><span class="pas1-space"> &quot;closes over&quot; it. You can call outer() </span><span class="pas1-reservedword">as</span><span class="pas1-space"> many times </span><span class="pas1-reservedword">as</span><span class="pas1-space"> you like </span><span class="pas1-reservedword">and</span><span class="pas1-space"> each value </span><span class="pas1-reservedword">of</span><span class="pas1-space"> x will be captured separately.

The </span><span class="pas1-reservedword">function</span><span class="pas1-space"> that</span><span class="pas1-string">'s returned is called a closure. The idea is potentially useful because we can specify part
</span><span class="pas1-space"> </span><span class="pas1-reservedword">of</span><span class="pas1-space"> the behavior </span><span class="pas1-reservedword">of</span><span class="pas1-space"> a </span><span class="pas1-reservedword">function</span><span class="pas1-space"> based </span><span class="pas1-reservedword">on</span><span class="pas1-space"> data at runtime.


At this stage you might say, &quot;OK, I followed your tedious explanation, but what good </span><span class="pas1-reservedword">is</span><span class="pas1-space"> such a thing? </span><span class="pas1-reservedword">Is</span><span class="pas1-space"> it
 anything more than a curiosity </span><span class="pas1-reservedword">for</span><span class="pas1-space"> ordinary programming?&quot; The answer </span><span class="pas1-reservedword">to</span><span class="pas1-space"> that </span><span class="pas1-reservedword">is</span><span class="pas1-space"> that it </span><span class="pas1-reservedword">is</span><span class="pas1-space"> occasionally
  useful when something, such </span><span class="pas1-reservedword">as</span><span class="pas1-space"> a </span><span class="pas1-reservedword">library</span><span class="pas1-space"> </span><span class="pas1-reservedword">interface</span><span class="pas1-symbol">, </span><span class="pas1-reservedword">requires</span><span class="pas1-space"> a </span><span class="pas1-reservedword">function</span><span class="pas1-space"> </span><span class="pas1-reservedword">and</span><span class="pas1-space"> you want </span><span class="pas1-reservedword">to</span><span class="pas1-space"> specify more than a
   couple </span><span class="pas1-reservedword">of</span><span class="pas1-space"> them that are very similar.

Imagine that you</span><span class="pas1-string">'re designing a GUI interface and you need six buttons that do similar things. Tkinter
</span><span class="pas1-space"> buttons take a </span><span class="pas1-reservedword">function</span><span class="pas1-space"> </span><span class="pas1-reservedword">to</span><span class="pas1-space"> call </span><span class="pas1-reservedword">as</span><span class="pas1-space"> an argument </span><span class="pas1-reservedword">and</span><span class="pas1-space"> it would be tedious </span><span class="pas1-reservedword">to</span><span class="pas1-space"> write six very similar functions.
  Instead you might </span><span class="pas1-reservedword">do</span><span class="pas1-space"> something like this:

from Tkinter import *

def makeButtonFunc(buttonName):

  def buttonFunc():
    print buttonName

  return buttonFunc

</span><span class="pas1-reservedword">class</span><span class="pas1-space"> mainWin:

  def __init__(self,root):
    self.root=root
    self.createWidgets()
    return None

  def createWidgets(self):
    </span><span class="pas1-reservedword">for</span><span class="pas1-space"> buttonName </span><span class="pas1-reservedword">in</span><span class="pas1-space"> (&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;):
      b=Button(self.root,text=buttonName,
        command=makeButtonFunc(buttonName))
      b.pack()
    return None

def main():
  root=Tk()
  mainWin(root)
  root.mainloop()
  return None

</span><span class="pas1-reservedword">if</span><span class="pas1-space"> __name__==&quot;__main__&quot;:
  main()


That</span><span class="pas1-string">'s clearly better than writing six functions that are virtually identical.

</span><span class="pas1-identifier">There are lots </span><span class="pas1-reservedword">of</span><span class="pas1-space"> people who like using closures. I, personally, don</span><span class="pas1-string">'t. To me, it feels like using a subtle
</span><span class="pas1-space"> trick </span><span class="pas1-reservedword">and</span><span class="pas1-space"> I prefer my programs </span><span class="pas1-reservedword">to</span><span class="pas1-space"> be </span><span class="pas1-reservedword">as</span><span class="pas1-space"> obvious </span><span class="pas1-reservedword">as</span><span class="pas1-space"> possible. </span><span class="pas1-reservedword">In</span><span class="pas1-space"> a similar situation, I</span><span class="pas1-string">'d use a Python object
</span><span class="pas1-space">  </span><span class="pas1-reservedword">with</span><span class="pas1-space"> a __call__() method. </span><span class="pas1-reservedword">If</span><span class="pas1-space"> a Python </span><span class="pas1-reservedword">object</span><span class="pas1-space"> has that method </span><span class="pas1-reservedword">and</span><span class="pas1-space"> it</span><span class="pas1-string">'s called as though it were a function,
</span><span class="pas1-space">   that method </span><span class="pas1-reservedword">is</span><span class="pas1-space"> run. </span><span class="pas1-reservedword">In</span><span class="pas1-space"> a </span><span class="pas1-reservedword">program</span><span class="pas1-space"> I wrote, I</span><span class="pas1-string">'d probably replace makeButtonFunc() with something like:


</span><span class="pas1-reservedword">class</span><span class="pas1-space"> makeButtonFunc:
  def __init__(self,buttonName):
    self.buttonName=buttonName

  def __call__(self):
    print self.buttonName


Which would </span><span class="pas1-reservedword">do</span><span class="pas1-space"> the same thing. </span><span class="pas1-reservedword">Of</span><span class="pas1-space"> course, I</span><span class="pas1-string">'d give the class a different name.

</span><span class="pas1-identifier">Posted: Mon - September </span><span class="pas1-number">18</span><span class="pas1-symbol">, </span><span class="pas1-number">2006</span><span class="pas1-space"> at </span><span class="pas1-number">08</span><span class="pas1-symbol">:</span><span class="pas1-number">07</span><span class="pas1-space"> PM   Main   Category:  Geek


</span><span class="pas1-float">6.1</span><span class="pas1-space"> – Closures

When a </span><span class="pas1-reservedword">function</span><span class="pas1-space"> </span><span class="pas1-reservedword">is</span><span class="pas1-space"> written enclosed </span><span class="pas1-reservedword">in</span><span class="pas1-space"> another </span><span class="pas1-reservedword">function</span><span class="pas1-symbol">, it has full access </span><span class="pas1-reservedword">to</span><span class="pas1-space"> local variables from the
 enclosing </span><span class="pas1-reservedword">function</span><span class="pas1-symbol">; this feature </span><span class="pas1-reservedword">is</span><span class="pas1-space"> called lexical scoping. Although that may sound obvious, it </span><span class="pas1-reservedword">is</span><span class="pas1-space"> </span><span class="pas1-reservedword">not</span><span class="pas1-symbol">.
  Lexical scoping, plus first-</span><span class="pas1-reservedword">class</span><span class="pas1-space"> functions, </span><span class="pas1-reservedword">is</span><span class="pas1-space"> a powerful concept </span><span class="pas1-reservedword">in</span><span class="pas1-space"> a programming language, but few
   languages support that concept.

Let us start </span><span class="pas1-reservedword">with</span><span class="pas1-space"> a simple example. Suppose you have a list </span><span class="pas1-reservedword">of</span><span class="pas1-space"> student names </span><span class="pas1-reservedword">and</span><span class="pas1-space"> a table that associates
 names </span><span class="pas1-reservedword">to</span><span class="pas1-space"> grades; you want </span><span class="pas1-reservedword">to</span><span class="pas1-space"> sort the list </span><span class="pas1-reservedword">of</span><span class="pas1-space"> names, according </span><span class="pas1-reservedword">to</span><span class="pas1-space"> their grades (higher grades first). You
  can </span><span class="pas1-reservedword">do</span><span class="pas1-space"> this task </span><span class="pas1-reservedword">as</span><span class="pas1-space"> follows:

    names = </span><span class="pas1-comment">{&quot;Peter&quot;, &quot;Paul&quot;, &quot;Mary&quot;}
</span><span class="pas1-space">    grades = </span><span class="pas1-comment">{Mary = 10, Paul = 7, Peter = 8}
</span><span class="pas1-space">    table.sort(names, </span><span class="pas1-reservedword">function</span><span class="pas1-space"> (n1, n2)
      return grades[n1] &gt; grades[n2]    -- compare the grades
    </span><span class="pas1-reservedword">end</span><span class="pas1-symbol">)

Now, suppose you want </span><span class="pas1-reservedword">to</span><span class="pas1-space"> create a </span><span class="pas1-reservedword">function</span><span class="pas1-space"> </span><span class="pas1-reservedword">to</span><span class="pas1-space"> </span><span class="pas1-reservedword">do</span><span class="pas1-space"> this task:

    </span><span class="pas1-reservedword">function</span><span class="pas1-space"> sortbygrade (names, grades)
      table.sort(names, </span><span class="pas1-reservedword">function</span><span class="pas1-space"> (n1, n2)
        return grades[n1] &gt; grades[n2]    -- compare the grades
      </span><span class="pas1-reservedword">end</span><span class="pas1-symbol">)
    </span><span class="pas1-reservedword">end

</span><span class="pas1-identifier">The interesting point </span><span class="pas1-reservedword">in</span><span class="pas1-space"> the example </span><span class="pas1-reservedword">is</span><span class="pas1-space"> that the anonymous </span><span class="pas1-reservedword">function</span><span class="pas1-space"> given </span><span class="pas1-reservedword">to</span><span class="pas1-space"> sort accesses the parameter
 grades, which </span><span class="pas1-reservedword">is</span><span class="pas1-space"> local </span><span class="pas1-reservedword">to</span><span class="pas1-space"> the enclosing </span><span class="pas1-reservedword">function</span><span class="pas1-space"> sortbygrade. Inside this anonymous </span><span class="pas1-reservedword">function</span><span class="pas1-symbol">, grades </span><span class="pas1-reservedword">is
</span><span class="pas1-space"> neither a global variable nor a local variable. We call it an </span><span class="pas1-reservedword">external</span><span class="pas1-space"> local variable, </span><span class="pas1-reservedword">or</span><span class="pas1-space"> an upvalue. (The
  term &quot;upvalue&quot; </span><span class="pas1-reservedword">is</span><span class="pas1-space"> a little misleading, because grades </span><span class="pas1-reservedword">is</span><span class="pas1-space"> a variable, </span><span class="pas1-reservedword">not</span><span class="pas1-space"> a value. However, this term has
   historical roots </span><span class="pas1-reservedword">in</span><span class="pas1-space"> Lua </span><span class="pas1-reservedword">and</span><span class="pas1-space"> it </span><span class="pas1-reservedword">is</span><span class="pas1-space"> shorter than &quot;</span><span class="pas1-reservedword">external</span><span class="pas1-space"> local variable&quot;.)

Why </span><span class="pas1-reservedword">is</span><span class="pas1-space"> that so interesting? Because functions are first-</span><span class="pas1-reservedword">class</span><span class="pas1-space"> values. Consider the following code:

    </span><span class="pas1-reservedword">function</span><span class="pas1-space"> newCounter ()
      local i = </span><span class="pas1-number">0
</span><span class="pas1-space">      return </span><span class="pas1-reservedword">function</span><span class="pas1-space"> ()   -- anonymous </span><span class="pas1-reservedword">function
</span><span class="pas1-space">               i = i + </span><span class="pas1-number">1
</span><span class="pas1-space">               return i
             </span><span class="pas1-reservedword">end
</span><span class="pas1-space">    </span><span class="pas1-reservedword">end
</span><span class="pas1-space">    
    c1 = newCounter()
    print(c1())  --&gt; </span><span class="pas1-number">1
</span><span class="pas1-space">    print(c1())  --&gt; </span><span class="pas1-number">2

</span><span class="pas1-identifier">Now, the anonymous </span><span class="pas1-reservedword">function</span><span class="pas1-space"> </span><span class="pas1-reservedword">uses</span><span class="pas1-space"> an upvalue, i, </span><span class="pas1-reservedword">to</span><span class="pas1-space"> keep its counter. However, by the time we call the
 anonymous </span><span class="pas1-reservedword">function</span><span class="pas1-symbol">, i </span><span class="pas1-reservedword">is</span><span class="pas1-space"> already </span><span class="pas1-reservedword">out</span><span class="pas1-space"> </span><span class="pas1-reservedword">of</span><span class="pas1-space"> scope, because the </span><span class="pas1-reservedword">function</span><span class="pas1-space"> that created that variable (newCounter)
  has returned. Nevertheless, Lua handles that situation correctly, using the concept </span><span class="pas1-reservedword">of</span><span class="pas1-space"> closure. Simply put,
   a closure </span><span class="pas1-reservedword">is</span><span class="pas1-space"> a </span><span class="pas1-reservedword">function</span><span class="pas1-space"> plus all it needs </span><span class="pas1-reservedword">to</span><span class="pas1-space"> access its upvalues correctly. </span><span class="pas1-reservedword">If</span><span class="pas1-space"> we call newCounter again,
    it will create a new local variable i, so we will get a new closure, acting over that new variable:

    c2 = newCounter()
    print(c2())  --&gt; </span><span class="pas1-number">1
</span><span class="pas1-space">    print(c1())  --&gt; </span><span class="pas1-number">3
</span><span class="pas1-space">    print(c2())  --&gt; </span><span class="pas1-number">2

</span><span class="pas1-identifier">So, c1 </span><span class="pas1-reservedword">and</span><span class="pas1-space"> c2 are different closures over the same </span><span class="pas1-reservedword">function</span><span class="pas1-space"> </span><span class="pas1-reservedword">and</span><span class="pas1-space"> each acts upon an independent instantiation
 </span><span class="pas1-reservedword">of</span><span class="pas1-space"> the local variable i. Technically speaking, what </span><span class="pas1-reservedword">is</span><span class="pas1-space"> a value </span><span class="pas1-reservedword">in</span><span class="pas1-space"> Lua </span><span class="pas1-reservedword">is</span><span class="pas1-space"> the closure, </span><span class="pas1-reservedword">not</span><span class="pas1-space"> the </span><span class="pas1-reservedword">function</span><span class="pas1-symbol">. The
 </span><span class="pas1-reservedword">function</span><span class="pas1-space"> itself </span><span class="pas1-reservedword">is</span><span class="pas1-space"> just a prototype </span><span class="pas1-reservedword">for</span><span class="pas1-space"> closures. Nevertheless, we will continue </span><span class="pas1-reservedword">to</span><span class="pas1-space"> use the term &quot;</span><span class="pas1-reservedword">function</span><span class="pas1-symbol">&quot;
  </span><span class="pas1-reservedword">to</span><span class="pas1-space"> refer </span><span class="pas1-reservedword">to</span><span class="pas1-space"> a closure whenever there </span><span class="pas1-reservedword">is</span><span class="pas1-space"> no possibility </span><span class="pas1-reservedword">of</span><span class="pas1-space"> confusion.

Closures provide a valuable tool </span><span class="pas1-reservedword">in</span><span class="pas1-space"> many contexts. </span><span class="pas1-reservedword">As</span><span class="pas1-space"> we have seen, they are useful </span><span class="pas1-reservedword">as</span><span class="pas1-space"> arguments </span><span class="pas1-reservedword">to</span><span class="pas1-space"> higher
-order functions such </span><span class="pas1-reservedword">as</span><span class="pas1-space"> sort. Closures are valuable </span><span class="pas1-reservedword">for</span><span class="pas1-space"> functions that build other functions too, like our
 newCounter example; this mechanism allows Lua programs </span><span class="pas1-reservedword">to</span><span class="pas1-space"> incorporate fancy programming techniques from the
  functional world. Closures are useful </span><span class="pas1-reservedword">for</span><span class="pas1-space"> callback functions, too. The typical example here occurs when you
   create buttons </span><span class="pas1-reservedword">in</span><span class="pas1-space"> a typical GUI toolkit. Each button has a callback </span><span class="pas1-reservedword">function</span><span class="pas1-space"> </span><span class="pas1-reservedword">to</span><span class="pas1-space"> be called when the user
    presses the button; you want different buttons </span><span class="pas1-reservedword">to</span><span class="pas1-space"> </span><span class="pas1-reservedword">do</span><span class="pas1-space"> slightly different things when pressed. </span><span class="pas1-reservedword">For</span><span class="pas1-space"> instance
    , a digital calculator needs ten similar buttons, one </span><span class="pas1-reservedword">for</span><span class="pas1-space"> each digit. You can create each </span><span class="pas1-reservedword">of</span><span class="pas1-space"> them </span><span class="pas1-reservedword">with</span><span class="pas1-space"> a
     </span><span class="pas1-reservedword">function</span><span class="pas1-space"> like the next one:

    </span><span class="pas1-reservedword">function</span><span class="pas1-space"> digitButton (digit)
      return Button</span><span class="pas1-comment">{ label = digit,
                     action = function ()
                                add_to_display(digit)
                              end
                   }
</span><span class="pas1-space">    </span><span class="pas1-reservedword">end


</span><span class="pas1-identifier">Anonymous </span><span class="pas1-reservedword">in</span><span class="pas1-space"> Delphi
</span><span class="pas1-reservedword">with</span><span class="pas1-space"> TForm.Create(self) </span><span class="pas1-reservedword">do</span><span class="pas1-space"> </span><span class="pas1-reservedword">begin
</span><span class="pas1-space">  BorderStyle := bsNone;
  WindowState := wsMaximized;
  Show;
</span><span class="pas1-reservedword">end</span><span class="pas1-symbol">;   
  
  This JSR provides support </span><span class="pas1-reservedword">for</span><span class="pas1-space"> operating </span><span class="pas1-reservedword">on</span><span class="pas1-space"> an arbitrary &quot;block </span><span class="pas1-reservedword">of</span><span class="pas1-space"> Java code&quot;, </span><span class="pas1-reservedword">or</span><span class="pas1-space"> body, which </span><span class="pas1-reservedword">is</span><span class="pas1-space"> either a
   statement list, an expression, </span><span class="pas1-reservedword">or</span><span class="pas1-space"> a combination </span><span class="pas1-reservedword">of</span><span class="pas1-space"> both. We call the mechanism a closure expression.
    Wrapping statements </span><span class="pas1-reservedword">or</span><span class="pas1-space"> an expression </span><span class="pas1-reservedword">in</span><span class="pas1-space"> a closure expression does </span><span class="pas1-reservedword">not</span><span class="pas1-space"> change their meaning, but merely
     defers their execution. Evaluating a closure expression produces a closure </span><span class="pas1-reservedword">object</span><span class="pas1-symbol">. The closure </span><span class="pas1-reservedword">object
</span><span class="pas1-space">      can later be invoked, which results </span><span class="pas1-reservedword">in</span><span class="pas1-space"> execution </span><span class="pas1-reservedword">of</span><span class="pas1-space"> the body, yielding the value </span><span class="pas1-reservedword">of</span><span class="pas1-space"> the expression (</span><span class="pas1-reservedword">if
</span><span class="pas1-space"> one was present) </span><span class="pas1-reservedword">to</span><span class="pas1-space"> the invoker. A closure expression can have parameters, which act </span><span class="pas1-reservedword">as</span><span class="pas1-space"> variables whose
  scope </span><span class="pas1-reservedword">is</span><span class="pas1-space"> the body. </span><span class="pas1-reservedword">In</span><span class="pas1-space"> this </span><span class="pas1-reservedword">case</span><span class="pas1-space"> the invoker </span><span class="pas1-reservedword">of</span><span class="pas1-space"> the closure </span><span class="pas1-reservedword">object</span><span class="pas1-space"> must provide compatible arguments, which
   become the values </span><span class="pas1-reservedword">for</span><span class="pas1-space"> the parameters.</span><span class="pas1-string">' 
</span></code></pre><!--EndFragment--></body>
</html>