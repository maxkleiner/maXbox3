Program CindyFunctionFun_Truth;          //on progress

//#net>D1.40DNS: 192.168.1.1; local IPs: fe80::102b:66c2:9557:7a93%10,fe80::39cb:cc4a:b4e7:9e03%20,fe80::25d2:cdb2:b4d2:1291%21,192.168.1.40,192.168.25.1,192.168.18.1; local IP: 192.168.1.401,2001:0:9d38:6ab8:10e5:1df6:4d3e:95ae; local IP: 192.168.1.40
//TODO: just missing a filestream mime file; search and get one
//TODO: Refactor boolean shorter #locs:680

{uses
  SysUtils,
  Classes;}
  
Const fstreamname = 'cindystreamtest.txt';  
 
var
  fs: TFileStream;
  v: byte;
  vs: string;
  vsf: double;
  i: integer;
  start: LongWord;

function StripString(st: String; CharsToStrip: String): String;
var
  i: Integer;
begin
  result:= '';
  for i:= 1 to Length(st) do begin
    if Pos(st[i], CharsToStrip) = 0 then
      result:= result + st[i];
  end;
end;
 
  

procedure fileStreamByte;
var I: Integer;
    Buff: Byte;
    FileS: TFilestream;  
begin

Files:= TFileStream.Create(Exepath+'examples\firstdemoBYTE.txt', fmCreate);
try
  //files.Seek(0, soBeginning);
  for I := 0 to 299 do begin
    Buff:= Random(255);
    //FileS.WriteBufferInt(Buff,1);
    FileS.WriteInt(Buff,1);
    end;
  finally
    FileS.Free;
  end;
end;   

//TODO: However, since the file is opened only in write mode (fmOpenWrite), if you try to add fs.ReadBuffer(v, SizeOf(v)); you will have an exception 'Stream Read Error' raised.


//How about the time difference if you use fmOpenReadWrite or fmOpenWrite whichever makes no difference?

procedure fileStreamTwo;
begin
  start := GetTickCount;
  fs := TFileStream.Create('C:\test.txt', fmOpenWrite or fmCreate);
  v := 65;
  try
    fs.Seek(0, soBeginning);
    for i := 0 to 10000000 do begin
      fs.WriteBufferInt(v, SizeOf(v));
    end;
  finally
    fs.Free;
  end;
  Writeln(IntToStr(GetTickCount - start));
  start := GetTickCount;
  fs := TFileStream.Create('C:\test.txt', fmOpenReadWrite or fmCreate);
  v := 65;
  try
    fs.Seek(0, soBeginning);
    for i := 0 to 10000000 do begin
      fs.WriteBufferInt(v, SizeOf(v));
    end;
  finally
    fs.Free;
  end;
  Writeln(IntToStr(GetTickCount - start));
  //Readln; 
end;  

function FileToStringStep(const AFilename: string;
                                 StartPos: Integer; EndPos: Integer): string;
var
  FileStream : TFileStream;
  wlCount: Integer;
begin
  if FileExists(AFilename) then begin
    if StartPos < 0 then
      StartPos := 0;
    FileStream:= TFileStream.Create(AFilename, fmOpenRead or fmShareDenyWrite);
    try
      if (EndPos <= StartPos) or (EndPos > FileStream.Size) then
        EndPos := FileStream.Size;
      wlCount := EndPos - StartPos;
      if FileStream.Size > StartPos then begin
        SetLength(Result, wlCount);
        //FileStream.Seek(StartPos, soFromBeginning);
        FileStream.Seek(StartPos, soBeginning);
        //FileStream.Read(Result[1], wlCount);
        FileStream.Read(Result, wlCount);
      end;
    finally
      FileStream.Free;
    end;
  end
  else
    Result:= '';
    //MessagePlainText
    //MessageHtml_Attach
    //ForceDecodeHeader
    
end;

//The timing is roughly the same (but using fmOpenWrite if you intend no read might be a slightly bit faster). 


function IdHttp_DownloadFile(aSrcUrlFile,aDestFile: String; const OnWorkEvent: TWorkEvent): Boolean;
var
  Http: TIdHTTP;
  MS: TMemoryStream;
begin
  Result := false;
  Http := TIdHTTP.Create(nil);
  try
    MS := TMemoryStream.Create;
    try
      //if Assigned(TObject(OnWorkEvent)) then
      if OnWorkEvent <> NIL then
        Http.OnWork:= OnWorkEvent;
      Http.Get1(aSrcUrlFile, MS);
      MS.SaveToFile(aDestFile);
      Result := true;
    finally
      MS.Free;
    end;
  finally
    Http.Free;
  end;
end;


function IsNetworkConnected2: Boolean;
begin
  if GetSystemMetrics(SM_NETWORK) and $01 = $01 then
  begin
    Result := True;
  end
  else
  begin
    Result := False;
  end;
end;

//To Refactor:
function IsNetworkConnected3: Boolean;
begin
  result:= GetSystemMetrics(SM_NETWORK) and $01 = $01
end;

function IsInternetConnected2: Boolean;
begin
  Result:= InternetGetConnectedState(0, 0);      //of wininet
end;

function IsCOMConnected2: Boolean;
begin
  result:= getComports.Count > 0;
end;

procedure PlayMediaUniversal;
var wmp: OLEVariant; 
 //Maybe you'll be more comfortable with automation.
begin
   wmp:= CreateOleObject('WMPlayer.OCX');
   //wmp.OpenPlayer(Exepath+'examples\maxbox.wav');
   if ISInternetOn then begin
     wmp.URL:= 'http://www.softwareschule.ch/download/airmaxloop3.mp3';
     wmp.OpenPlayer(wmp.URL);
   end else
     wmp.OpenPlayer(Exepath+'examples\maxbox.wav');
  //wmp.controls.play;
end; 

const   BufferSize1 = 1024; 
 
function GetInetFile (const fileURL, FileName: String): boolean;
 var   hSession, hURL: HInternet;   Buffer: array[1..BufferSize] of Byte;   BufferLen1: DWORD;   f: File;  sAppName: string; begin  result:= false;  sAppName:= ExtractFileName(Application.ExeName) ; //Function InternetOpen(lpszAgent:PChar;dwAccessType:DWORD;lpszProxy,
//lpszProxBypass:PChar;dwFlags:DWORD):HINTERNET;
//15165: 
 InternetOpen(pchar(sAppName),INTERNET_OPEN_TYPE_PRECONFIG,'0','0',0);
 hSession:= InternetOpen(PChar(sAppName),INTERNET_OPEN_TYPE_PRECONFIG,'0','0',0); 
 { hSession:= InternetOpen(sAppName,INTERNET_OPEN_TYPE_PRECONFIG, nil, nil, 0) ; 
  try   
 hURL := InternetOpenURL(hSession, PChar(fileURL), nil, 0, 0, 0) ;   try    AssignFile(f, FileName) ;    Rewrite(f,1) ;    repeat     InternetReadFile(hURL, @Buffer, SizeOf(Buffer), BufferLen) ;     BlockWrite(f, Buffer, BufferLen)    until BufferLen = 0;    CloseFile(f) ;    result := True;   finally    InternetCloseHandle(hURL)   end  finally   InternetCloseHandle(hSession)  end} end;

//Note: In order to provide some vi

//-----------------------------------------------------}
function Str2Comp(MyString: string): Comp;
var
  ErrCode: Integer;
  Temp: Comp;
begin
  If Mystring[0] = #0 then result:= 0
  else begin
    //Val(Mystring, Temp, ErrCode);
    //StrtoInt
    Temp:= StrToIntDef(myString,0);  //// if invalid, result is 0
    if ErrCode = 0 then
      result:= temp
    else
      result:= 0;
  end;
end;


function Str2CompBetter(MyString: string): Comp;
var
  ErrCode: Integer;
  Temp: Comp;
begin
  If Mystring[1] = #0 then result:= 0
  else begin
    //Val(Mystring, Temp, ErrCode);
    //StrtoInt
    Temp:= StrToIntDef(myString,0);  //// if invalid, result is 0
    if ErrCode <> 0 then
      result:= temp
    else
      result:= 0;
  end;
end;


{----------------------------------------------------
       Name: Str2Pennies function
Declaration: Str2Pennies(MyString: string)
       Unit: MathBox
       Code: N
       Date: 02/17/94	
Description: Converts a String to a Comp
-----------------------------------------------------}
function Str2PenniesX(S: String): Comp;
 var
  C: Comp;
  i: Integer;
 begin
    if S[1] = '$' then Delete(S, 1, 1);
    i:= Pos('.', S);
    if i = Length(S) then begin   { Is last character a period? }
      Delete(S, i, 1);
      S:= S + '00';
    end else
      if i <> 0 then begin        { Some pennies?               }
        Delete(S, i, 1);
        if i = (Length(S)) then   { Only one char after decimal?}
          S:= S + '0'
      end else
        S:= S + '00';            { No decimal, no pennies       }
    C:= Str2CompBetter(S);
    result:= C;
end;

procedure CYNDIwwStrMathBoxTest;
var hURL: HInternet;
begin
 
   //IsFolder(SRec: TSearchrec): Boolean;

  writeln('isFolderReadOnly '+BooleanToString(isFolderReadOnly(Exepath)));

  //DirectoryIsEmpty(Directory: String): Boolean;

   //DirectoryWithSubDir(Directory: String): Boolean;

  //GetSubDirs(FromDirectory: String; aList: TStrings);

  writeln('DiskFreeBytes C: '+int64toStr(DiskFreeBytes('C')));

  //DiskBytes(Drv: Char): Int64;

  //GetFileBytes(Filename: String): Int64;

  //GetFilesBytes(Directory, Filter: String): Int64;
  
  //ShellGetExtensionName( FileName : String) : String');
 //ShellGetIconIndex( FileName : String) : Integer');
 //ShellGetIconHandle( FileName : String) : HIcon');
 //ShellThreadCopy( App_Handle : THandle; fromFile : string; toFile : string)');
  //ShellThreadMove( App_Handle : THandle; fromFile : string; toFile : string)');
  //ShellRenameDir( DirFrom, DirTo : string)');
 //ShellExecute(Operation,FileName,Parameters,Directory : String; ShowCmd : Integer) : Cardinal;');
  //ShellExecute1( ExeFilename, Parameters, ApplicationName, ApplicationClass : String; Restore : Boolean);');
  //ShellExecuteAsModal( ExeFilename, ApplicationName, Directory : String)');
  //ShellExecuteExAsAdmin( hWnd : HWND; Filename : string; Parameters : string)');
 //ShellExecuteEx( aFileName : string; const Parameters : string; const Directory : string; const WaitCloseCompletion : boolean) : Boolean');
  //RestoreAndSetForegroundWindow( Hnd : Integer)');
 //RemoveDuplicatedPathDelimiter( Str : String) : String');
 //cyFileTimeToDateTime( _FT : TFileTime) : TDateTime');
 //GetModificationDate( Filename : String) : TDateTime');
 //GetCreationDate( Filename : String) : TDateTime');
 //GetLastAccessDate( Filename : String) : TDateTime');
 //FileDelete( Filename : String) : Boolean');
 //FileIsOpen( Filename : string) : boolean');
  //7/FilesDelete( FromDirectory : String; Filter : ShortString)');
 //DirectoryDelete( Directory : String) : Boolean');
 //GetPrinters( PrintersList : TStrings) : Integer');
  //SetDefaultPrinter( PrinterName : String)');
  //ShowDefaultPrinterWindowProperties( FormParent_Handle : Integer)');
 //WinToDosPath( WinPathName : String) : String');
 //DosToWinPath( DosPathName : String) : String');
 //GetWindowsVersion : TWindowsVersion');
 //NTSetPrivilege( sPrivilege : string; bEnabled : Boolean) : Boolean');
  //WindowsShutDown( Restart : boolean)');
  //CreateShortCut( FileSrc, Parametres, FileLnk, Description, DossierDeTravail, FileIcon : string; NumIcone : integer)');
  //GetWindowsFonts( FontsList : TStrings)');
 //GetAvailableFilename( DesiredFileName : String) : String');
//e
     //getword
   //TWordsOption
   
 //LongDayName( aDate : TDate) : String');
  //LongMonthName( aDate : TDate) : String');
  //ShortYearOf( aDate : TDate) : byte');
  //DateToStrYYYYMMDD( aDate : TDate) : String');
  //StrYYYYMMDDToDate( aStr : String) : TDate');
  //SecondsToMinutes( Seconds : Integer) : Double');
  //MinutesToSeconds( Minutes : Double) : Integer');
  //MinutesToHours( Minutes : Integer) : Double');
  //HoursToMinutes( Hours : Double) : Integer');
  //ShortTimeStringToTime( ShortTimeStr : String; const ShortTimeFormat : String) : TDateTime');
 //cyAddMonths( var aMonth, aYear : Word; Months : Integer)');
  //MergeDateWithTime( aDate : TDate; aTime : TDateTime) : TDateTime');
  //GetMinutesBetween( DateTime1, DateTime2 : TDateTime) : Int64;');
  //GetMinutesBetween1( From_ShortTimeStr, To_ShortTimeStr : String; const ShortTimeFormat : String) : Int64;');
  //GetSecondsBetween( DateTime1, DateTime2 : TDateTime) : Int64;');
  //IntersectPeriods( Period1Begin, Period1End, Period2Begin, Period2End : TDateTime; var RsltBegin : TDateTime; RsltEnd : TDateTime) : Boolean;');
  //IntersectPeriods1( Period1Begin, Period1End, Period2Begin, Period2End : TDateTime) : Boolean;');
  //TryToEncodeDate( Year, Month, Day : Integer; var RsltDate : TDateTime) : Boolean');
 
 //StringsLocate( aList : TStrings; Value : String; Options : TcyLocateOptions) : Integer;');
 //StringsLocate1( aList : TStrings; Value : String; ValueKind : TStringsValueKind) : Integer;');
 //StringsAdd( aList : TStrings; Value : String; Unique : Boolean; SortType : TStringsSortType) : Integer');
 //StringsReplace(aList: TStrings; OldStr: String; NewStr: String; ValueKind : TStringsValueKind)');
  //StringsSort( aList : TStrings; SortType : TStringsSortType)');
 //TreeNodeLocate( ParentNode : TTreeNode; Value : String) : TTreeNode');
 //TreeNodeLocateOnLevel( TreeView : TTreeView; OnLevel : Integer; Value : String) : TTreeNode');
 //TreeNodeGetChildFromIndex( TreeView : TTreeView; ParentNode : TTreeNode; ChildIndex : Integer) : TTreeNode');
 //TreeNodeGetParentOnLevel( ChildNode : TTreeNode; ParentLevel : Integer) : TTreeNode');
  //TreeNodeCopy( FromNode : TTreeNode; ToNode : TTreeNode; const CopyChildren : Boolean; const CopySubChildren : Boolean)');
  //RichEditSetStr( aRichEdit : TRichEdit; FormatedString : String)');
  //RichEditStringReplace( aRichEdit : TRichEdit; OldPattern, NewPattern : string; Flags : TReplaceFlags)');
 //GetTopMostControlAtPos( FromControl : TWinControl; aControlPoint : TPoint) : TControl');
  //cyCenterControl( aControl : TControl)');
 //GetLastParent( aControl : TControl) : TWinControl');
 //GetControlBitmap( aControl : TWinControl) : TBitmap');
 //GetRichEditBitmap( aRichEdit : TRichEdit) : TBitmap');
   //isfolder
     //TablePackTable( Tab : TTable) : Boolean');
 //TableRegenIndexes( Tab : TTable) : Boolean');
 //TableShowDeletedRecords( Tab : TTable; Show : Boolean) : Boolean');
 //TableUndeleteRecord( Tab : TTable) : Boolean');
 //TableAddIndex( Tab : TTable; FieldName : String; FieldExpression : String; IOpt : TIndexOptions) : Boolean');
 //TableDeleteIndex( Tab : TTable; IndexFieldName : String) : Boolean');
 //TableEmptyTable( Tab : TTable) : Boolean');
 //TableFindKey( aTable : TTable; Value : String) : Boolean');
 //TableFindNearest( aTable : TTable; Value : String)');
 //TableCreate( Owner : TComponent; DataBaseName : ShortString; TableName : String; IndexName : ShortString; ReadOnly : Boolean) : TTable');
 //TableOpen( Tab : TTable; FileName : String; IndexFieldName : String; RecordIndexValue : Variant; GotoRecordIndexValue : Boolean) : Boolean');
 //DateToBDESQLDate( aDate : TDate; const DateFormat : String) : String');
   //TLineCoord
 // procedure SIRegister_cyGraphics(CL: TPSPascalCompiler);
//begin
  //cyGradientFill( aCanvas : TCanvas; aRect : TRect; fromColor, toColor : TColor; adgradOrientation : TdgradOrientation; Balance, AngleDegree : Word; balanceMode : TDgradBalanceMode; Maxdegrade : Byte;'+' SpeedPercent : Integer; const AngleClipRect : Boolean; const AngleBuffer : TBitmap)');
  {cyGradientFillVertical( aCanvas : TCanvas; aRect : TRect; fromColor, toColor : TColor; MaxDegrad : byte)');
  cyGradientFillHorizontal( aCanvas : TCanvas; aRect : TRect; fromColor, toColor : TColor; MaxDegrad : byte)');
  cyGradientFillShape( aCanvas : TCanvas; aRect : TRect; fromColor, toColor : TColor; MaxDegrad : Byte; toRect : TRect; OrientationShape : TDgradOrientationShape)');
  cyGradientFillAngle( aCanvas : TCanvas; aRect : TRect; fromColor, toColor : TColor; MaxDegrad : Byte; AngleDegree : Word; const ClipRect : Boolean; const Buffer : TBitmap)');
  DrawRectangleInside( aCanvas : TCanvas; InsideRect : TRect; FrameWidth : Integer)');
  cyFrame( aCanvas : TCanvas; var InsideRect : TRect; Color : TColor; const Width : Integer);');
  cyFrame1( Canvas : TCanvas; var InsideRect : TRect; LeftColor, TopColor, RightColor, BottomColor : TColor; const Width : Integer; const RoundRect : boolean);');
  cyFrame3D( Canvas : TCanvas; var Rect : TRect; TopLeftColor, BottomRightColor : TColor; Width : Integer; const DrawLeft : Boolean; const DrawTop : Boolean; const DrawRight : Boolean; const DrawBottom : Boolean; const RoundRect : boolean)');
  cyDrawButtonFace( Canvas : TCanvas; var Rect : TRect; GradientColor1, GradientColor2 : TColor; aState : TButtonState; Focused, Hot : Boolean)');
  cyDrawButton( Canvas : TCanvas; Caption : String; ARect : TRect; GradientColor1, GradientColor2 : TColor; aState : TButtonState; Focused, Hot : Boolean)');
  cyDrawSpeedButtonFace( Canvas : TCanvas; var Rect : TRect; GradientColor1, GradientColor2 : TColor; aState : TButtonState; Focused, Hot : Boolean)');
  cyDrawSpeedButton( Canvas : TCanvas; Caption : String; ARect : TRect; GradientColor1, GradientColor2 : TColor; aState : TButtonState; Focused, Hot : Boolean)');
  cyDrawCheckBox( Canvas : TCanvas; IsChecked : Boolean; ARect : TRect; const BgColor : TColor; const DarkFrameColor : TColor; const LightFrameColor : TColor; const MarkColor : TColor)');
  cyDrawSingleLineText( Canvas : TCanvas; Text : String; ARect : TRect; Alignment : TAlignment; TextLayout : TTextLayout; const IndentX : Integer; const IndentY : Integer)');}
 //DrawTextFormatFlags( aTextFormat : LongInt; Alignment : TAlignment; Layout : TTextLayout; WordWrap : Boolean) : LongInt;');
  //DrawTextFormatFlags1( aTextFormat : LongInt; Alignment : TAlignment; Layout : TTextLayout; WordWrap : Boolean; CaptionRender : TCaptionRender) : LongInt;');
  //cyDrawText( CanvasHandle : Cardinal; Text : String; var Rect : TRect; TextFormat : LongInt)');
 //cyCreateFontIndirect( fromFont : TFont; Angle : Double) : TFont;');
 //cyCreateFontIndirect1( fromFont : TFont; CaptionOrientation : TCaptionOrientation) : TFont;');
  //cyDrawVerticalText( Canvas : TCanvas; Text : String; var Rect : TRect; TextFormat : Longint; CaptionOrientation : TCaptionOrientation; Alignment : TAlignment; Layout : TTextLayout)');
 //DrawLeftTurnPageEffect( Canvas : TCanvas; PageColor : TColor; PageRect : TRect; PercentDone : Integer; const OnlyCalcFoldLine : Boolean) : TLineCoord');
 //DrawRightTurnPageEffect( Canvas : TCanvas; PageColor : TColor; PageRect : TRect; PercentDone : Integer; const OnlyCalcFoldLine : Boolean) : TLineCoord');
 //PictureIsTransparentAtPos( aPicture : TPicture; aPoint : TPoint) : boolean');
 //IconIsTransparentAtPos( aIcon : TIcon; aPoint : TPoint) : boolean');
 //MetafileIsTransparentAtPos( aMetafile : TMetafile; aPoint : TPoint) : boolean');
 //PngImageIsTransparentAtPos( aPngImage : TPngImage; aPoint : TPoint) : boolean');
  //DrawCanvas( Destination : TCanvas; DestRect : TRect; Source : TCanvas; SourceRect : TRect);');
  //DrawCanvas1( Destination : TCanvas; DestRect : TRect; Src : TCanvas; SrcRect : TRect; TransparentColor : TColor; const aStyle : TBgStyle; const aPosition : TBgPosition; const IndentX : Integer; const IndentY : Integer;'+
 //' const IntervalX : Integer; const IntervalY : Integer; const RepeatX : Integer; const RepeatY : Integer);');
  //DrawGraphic( Destination : TCanvas; DestRect : TRect; aGraphic : TGraphic; SrcRect : TRect; TransparentColor : TColor; const aStyle : TBgStyle; const aPosition : TBgPosition; const IndentX : Integer; const IndentY : '+
 //'Integer; const IntervalX : Integer; const IntervalY : Integer; const RepeatX : Integer; const RepeatY : Integer);');
  //DrawGraphic1( Destination : TCanvas; DestRect : TRect; aGraphic : TGraphic; Transparent : Boolean; const aStyle : TBgStyle; const aPosition : TBgPosition; const IndentX : Integer; const IndentY : Integer; const '+
 //'IntervalX : Integer; const IntervalY : Integer; const RepeatX : Integer; const RepeatY : Integer);');
  //DrawMosaicPortion( Destination : TCanvas; Portion : TRect; Pattern : TBitmap)');
 //ValidGraphic( aGraphic : TGraphic) : Boolean');
 //ColorSetPercentBrightness( Color : TColor; PercentLight : Integer) : TColor');
 //ColorModify( Color : TColor; incR, incG, incB : Integer) : TColor');
 //ColorSetPercentContrast( Color : TColor; IncPercent : Integer) : TColor');
 //ColorSetPercentPale( Color : TColor; IncPercent : integer) : TColor');
 //MediumColor( Color1, Color2 : TColor) : TColor');
 //ClientToScreenRect( aControl : TControl; aControlRect : TRect) : TRect');
 //ScreenToClientRect( aControl : TControl; aScreenRect : TRect) : TRect');
 //CombineRectKeepingCenterPosition( RectPos, AddRect : TRect) : TRect');
  //InflateRectPercent( var aRect : TRect; withPercent : Double)');
 //GetIntermediateRect( Rect1, Rect2 : TRect; Percent : Double) : TRect');
 //GetProportionalRect( fromRect, InsideRect : TRect) : TRect');
 //cyPointInRect( const aPt : TPoint; const aRect : TRect) : boolean');
 //PointInEllispe( const aPt : TPoint; const aRect : TRect) : boolean');
 //CanvasAcceleratorTextWidth( aCanvas : TCanvas; aText : String) : Integer');
//end;
 //TGlyphAlignment', '( gaLeft, gaCenter, gaRight )');
  //TGlyphLayout', '( glTop, glCenter, glBottom )');
  //TDisabledGlyphOptions', '( dgDoNotDraw, dgDrawNormal, dgDrawMonochrome )');
  //TCaptionRender', '( crNormal, crPathEllipsis, crEndEllipsis, crWordEllipsis )');
  //TCaptionOrientation', '( coHorizontal, coHorizontalReversed, coVertical, coVerticalReversed )');
 
 
 //strBreakApart(s: string; delimeter: string; parts: TStrings);
 //strGetToken(s: string; delimeter: string; var APos: integer): string;
 //strStripPreceding(var s: string; delimeter: strCharSet);
 //strStripTrailing(var s: string; delimeter: strCharSet);
 //strStripWhiteSpace(var s: string);
 //strRemoveChar(str: string; removeChar: char): string;
 //strReplaceChar(str: string; removeChar, replaceChar: char): string;
 //strReplaceCharWithStr(str: string; removeChar: char;replaceStr: string): string;
 //wwEqualStr(s1, s2: string): boolean;
 //strCount(s: string; delimeter: char): integer;
  writeln(inttoStr(strCount(FileToString(exepath+'firstdemo.txt'),'z')));
  //function CountOfChar(const Ch: Char; const S: string): Integer;
  writeln(inttoStr(CountOfChar('z',FileToString(exepath+'firstdemo.txt'))));
 
 //strWhiteSpace : strCharSet;
 //wwExtractFileNameOnly(const FileName: string): string;
 //wwGetWord(s: string; var APos: integer; Options: TwwGetWordOptions;
                   //DelimSet: strCharSet): string;
 //strTrailing(s: string; delimeter: char): string;
 //strPreceding(s: string; delimeter: char): string;
 //strReplace(s, Find, Replace: string): string;
  //cwMaxPages
  //THTTPServer
  //StripString
 // mxArcCos( x : Real) : Real');
 //mxArcSin( x : Real) : Real');
 //Comp2Str( N : Comp) : String');
 //Int2StrPad0( N : LongInt; Len : Integer) : String');
 //Int2Str( N : LongInt) : String');
 //mxIsEqual( R1, R2 : Double) : Boolean');
 //LogXY( x, y : Real) : Real');
 //Pennies2Dollars( C : Comp) : String');
 //mxPower( X : Integer; Y : Integer) : Real');
 //Real2Str( N : Real; Width, Places : integer) : String');
 //mxStr2Comp( MyString : string) : Comp');
 //mxStr2Pennies( S : String) : Comp');
 //Str2Real( MyString : string) : Real');
 //XToTheY( x, y : Real) : Real');
     //Str2Pennies
   writeln('mXVersion: '+version);  
   writeln('mXVersion: '+mbversion);
   //Function InternetCloseHandle( hInet : HINTERNET) : BOOL'); 
   //InternetOpenURL(hURl, '127.0.0.1', '0', 0, 0, 0)
   hURL:= InternetOpenURL(hURL, '127.0.0.1', '0', 0, 0, 0) 
   InternetCloseHandle(hURL);
    //TGlyphAlignment', '( gaLeft, gaCenter, gaRight )');
  //TGlyphLayout', '( glTop, glCenter, glBottom )');
  //TDisabledGlyphOptions', '( dgDoNotDraw, dgDrawNormal, dgDrawMonochrome )');
  //TCaptionRender', '( crNormal, crPathEllipsis, crEndEllipsis, crWordEllipsis )');
  //TCaptionOrientation', '( coHorizontal, coHorizontalReversed, coVertical, coVerticalReversed )');
  //TBgPosition', '( bgCentered, bgTopLeft, bgTopCenter, bgTopRight,'
   //+' bgCenterRight, bgBottomRight, bgBottomCenter, bgBottomLeft, bgCenterLeft)');
  //TBgStyle', '( bgNone, bgNormal, bgMosaic, bgStretch, bgStretchProportional )');
  //TcyBevelCut', '( bcLowered, bcRaised, bcNone, bcTransparent, bcGradientToNext )');
  //TDgradOrientation', '( dgdVertical, dgdHorizontal, dgdAngle, dgdRadial, dgdRectangle )');
  //TDgradOrientationShape', '( osRadial, osRectangle )');
  //TDgradBalanceMode', '( bmNormal, bmMirror, bmReverse, bmReverseFromColor, bmInvertReverse, bmInvertReverseFromColor )');
  //TRunTimeDesignJob', '( rjNothing, rjMove, rjResizeTop, rjResizeBottom, rjResizeLeft, rjResizeTopLeft, rjResizeBottomLeft, rjResizeRight, r'
   //+'jResizeTopRight, rjResizeBottomRight )');
  //TLineCoord', 'record BottomCoord : TPoint; TopCoord : TPoint; end');
 //cCaptionOrientationWarning','String').SetString( 'Note that text orientation doesn''t work with all fonts!');
 //TStringsSortType', '( stNone, stStringSensitive, stStringInsensitive, stExtended )');
 //TStringsValueKind', '( skStringSensitive, skStringInsensitive, skExtended )');
   //TStrLocateOption', '( strloCaseInsensitive, strloPartialKey )');
  //TStrLocateOptions', 'set of TStrLocateOption');
  //TStringRead', '( srFromLeft, srFromRight )');
  //TStringReads', 'set of TStringRead');
  //TCaseSensitive', '( csCaseSensitive, csCaseNotSensitive )');
  //TWordsOption', '( woOnlyFirstWord, woOnlyFirstCar )');
  //TWordsOptions', 'set of TWordsOption');
  //TCarType', '( ctAlphabeticUppercase, ctAlphabeticLowercase, ctNumeric, ctOther )');
  //TCarTypes', 'set of TCarType');
  //  TWindowsVersion
  writeln(inttostr(ord(GetWindowsVersion)));
    //cyGetWindowsVersion
    
  
end;


  type  TdbOpenDlg = TForm;

var
  dbOpenDlg: TdbOpenDlg;


procedure TdbOpenDlg_Button1Click(Sender: TObject);
begin
  dbOpenDlg.ModalResult:= mrOK;
end;

procedure TdbOpenDlg_CalBtnFromClick(Sender: TObject);
begin
  dbOpenDlg:= TdbOpenDlg.create(self)
  with dbOpenDlg do begin
    setbounds(0,0,400,400)
    //showmodal later
   //self.onmessage:= @doonMessage;
   
  end;
   with TButton.create(dbopenDlg) do begin
     parent:= dbopenDlg;
     setbounds(20,200,100,40)
     caption:= 'OK Date';
     onclick:= @TdbOpenDlg_Button1Click;
   end;  
  try
   with TDateTimePicker.create(dbopenDlg) do begin
     parent:= dbopenDlg;
     SetBounds(20,20,100,100);
     if dbopenDlg.showModal = mrOK then
       //BeginDate:= Datetime;
     writeln('date with time: '+datetimetostr(Datetime));
   end;
  finally
    dbopenDlg.Free;
  end;
end;

procedure ServiceAppTest;
var App: TServiceApplication;
begin
  App:= TServiceApplication.Create(Nil);
  App.Title:= 'just a second Service App';
  //App.onmessage:= 
  App.Free;
  App:= Nil;
  with TEventLogger.create('TEventLogger_txt') do begin
    LogMessage('second app started',1,0,0);
    Free;
  end;
  //OpenDoc(Exepath+'TEventLogger.txt');  
end;  




//const WM_DEVICECHANGE = $219;

  procedure doonmessage(var msg: TMsg; var handled: boolean);
  var i: integer;
    apchar: Pchar;
    apchar2: array[0..500] of char;

  begin
  if (msg.message = WM_Devicechange) then begin
    writeln('any device changed')
    getwindowtext(msg.hwnd, pchar(apchar), sizeof(apchar));
    writeln('message got');
    handled:= true;
  end;  
end;  





var adyn: TDynCardinalArray;
    mymime: TMimeChar;
    svcapp: TServiceApplication;
    ata: TService;
    //ats: TStartType;
     //sve: TEventLogger



begin
 //wwScanDate
   //loadMimeForm;
   //fileStreamOne;
   //OpenService
   //WordGridFormatIdentToInt
   OpenDoc(Exepath+'examples\firstdemo22.txt');
   writeln(FileToStringStep(exepath+'firstdemo.txt',0,200));
   //fileStreamByte;
   //OpenDoc(Exepath+'examples\firstdemoBYTE.txt');
   writeln('Is Network Connected1 '+BooleanToString(IsNetworkConnected));
   writeln('Is Network Connected2 '+BooleanToString(IsNetworkConnected2));
   writeln('Is Network Connected3 '+BooleanToString(IsNetworkConnected3));
   writeln('Is Internet Connected1 '+BooleanToString(IsInternetConnected));
   writeln('Is Internet Connected2 '+BooleanToString(IsInternetConnected2));
   writeln('Is COM Port Available1 '+BooleanToString(IsCOMConnected));
   writeln('Is COM Port Available2 '+BooleanToString(IsCOMConnected2));
  
   maxForm1.color:= clSilver;
   
    adyn:= PrimeFactors(1270);
    for i:= 0 to length(adyn)-1 do 
      write(inttostr(adyn[i])+' ');
    for i:= 0 to length(PrimeFactors(20))-1 do 
      writeln(inttostr(adyn[i]));
    //299792458
    writeln(floattoStr(MetersPerLightSecond));
    writeln(floattoStr(1/ (MetersPerLightSecond / 2000)));
    writeln(floattoStr((2000 /MetersPerLightSecond)));
    printF('light speed of 2000 meters %.14f',[2000 /MetersPerLightSecond]);
    printF('light speed test back %.14f',
                  [(2000 /MetersPerLightSecond)*-(1-MetersPerLightSecond/2000)]);
    printF('light speed test back %.14f',
                  [(2000 /MetersPerLightSecond)+
                    (2000 /MetersPerLightSecond)*-(1-MetersPerLightSecond/2000)]);
 
    //TJvMemoryTable
    //TJvObjectStrings
   //PlayMediaUniversal;
   //TDBLookupCombo
   //TDBLookupList
   //TDBLookup
    // THotspot
      //TPrintGrid
      //sTDBCtrlGrid
    //TColumn
     // TDBGridColumns
       //TBookmarkList
    //TCustomDBGrid
      //TDBGrid
      //TQueryDescription
      //strCharSet
    
    writeln(GetIDFromCP(mymime));
 
    mymime:= GetCurCP;
    writeln(GetIDFromCP(mymime));
    writeln(GetIDFromCP(getCurCP));
    writeln('GetDomainName1: '+GetDomainName);
    writeln('GetDomainName2: '+GetDomainName2);
    writeln(inttoStr(mxStr2Pennies('$234.34')))
    writeln(inttoStr(Str2PenniesX('$234.34')))
      writeln(inttostr(ord(GetWindowsVersion)));
      writeln(inttostr(ord(cyGetWindowsVersion)));
      writeln((GetWindowsVersionJ));

    CYNDIwwStrMathBoxTest;
        
    //writeln(sha1('E:\maxbox3\mXGit39991\maxbox3.zip'));
    maxcalcF('450 / 100 *19') 
    //Application.OnMessage:= @doonMessage;
    
    TdbOpenDlg_CalBtnFromClick(self);
    ServiceAppTest;
    writeln(inttohex(WM_DEVICECHANGE,4))

End.  

Doc:
//maxform1

this script environment has many ways and need no installation or administration just copy a script and run from stick or whereever

http://www.cryer.co.uk/brian/delphi/wininet.htm
------------------------------

d1be03513f8bd6fce7293f7bb398cc0f3ff12634
D1BE03513F8BD6FCE7293F7BB398CC0F3FF12634

  memo1 and memo2 is keyword!  and maxform1 is main OpenTools API window
  
  The File Open modes are defined in SysUtils.pas as below.

  
  {$IFDEF MSWINDOWS}
  fmOpenRead       = $0000;
  fmOpenWrite      = $0001;
  fmOpenReadWrite  = $0002;
 
  fmShareCompat    = $0000 platform; // DOS compatibility mode is not portable
  fmShareExclusive = $0010;
  fmShareDenyWrite = $0020;
  fmShareDenyRead  = $0030 platform; // write-only not supported on all platforms
  fmShareDenyNone  = $0040;
{$ENDIF}

We can see that the fmOpenReadWrite is not as the same as fmOpenRead or fmOpenWrite.

The fmShareExclusive specifies that the file cannot be read or write by other processes. 
The fmShareDenyWrite specifies that the file can by read but not write by other processes. 
The fmShareDenyRead specifies that the file can by write but not read by other processes. 
The fmShareDenyNone specifies that the file can by read or write (no limitation) by other processes

If you specify the fmCreate, the file will always be cleared as empty if created or always exists. In this case, if you specify fmCreate or fmOpenWrite, it is actually the same a fmCreate or fmOpenReadWrite, in such case, you can use ReadBuffer to read the data you have written before (or zero if it has not been written by WriteBuffer).


 Urknall: Erster direkter Beweis für kosmologische Inflation
Meldung vorlesen und MP3-Download

Offenbar ist es gelungen, erstmals direkte Beweise für die kurzzeitige überlichtschnelle Expansion des Universums nach dem Urknall zu finden. Den Nachweis für diese sogenannte Inflation fanden Forscher in der kosmischen Hintergrundstrahlung.

Astronomen ist es mithilfe von Radioteleskopen am Südpol offenbar gelungen, erstmals direkte Beweise für die sogenannte kosmologische Inflation nachzuweisen. Dabei handelt es sich um eine überlichtschnelle Expansion des Universums in einem äußerst kurzen Zeitraum direkt nach dem Urknall, die in Bruchteilen einer Sekunde stattfand.

Die bislang nur in der Theorie beschriebene Inflation erklärt einige Probleme, die sich aus der Beschreibung des Urknalls ergeben hatten, etwa die große Gleichförmigkeit unseres Universums. Nun konnte sie experimentell bestätigt und dabei erstmals auch Bilder sogenannter Gravitationswellen gemacht werden. Die Ergebnisse bestätigen außerdem die enge Verbindung zwischen der Quantenmechanik und der Relativitätstheorie.


 Lazarus-IDE für Pascal und Object Pascal in Version 1.2 veröffentlicht

Die freie Entwicklungsumgebung enthält im ersten größeren Release nach etwa anderthalb Jahren unter anderem einen Makro-Recorder, einen verbesserten Debugger und überarbeiteten Compiler-Optionen.

Version 1.2 der integrierten Entwicklungsumgebung Lazarus steht zum Download bereit. Sie ist zum Rapid Application Development (RAD) mit Pascal und Object Pascal gedacht und zu Delphi kompatibel, während andere Pascal-IDEs sich eher an Turbo Pascal anlehnen. Intern kommt der Free-Pascal-Compiler zum Einsatz.

object Form1: TForm1
  Left = 249
  Top = 130
  Width = 672
  Height = 480
  Caption = 'Form1'
  Font.Charset = DEFAULT_CHARSET
  Font.Color = clWindowText
  Font.Height = -13
  Font.Name = 'MS Sans Serif'
  Font.Style = []
  OnCreate = FormCreate
  OnDestroy = FormDestroy
  PixelsPerInch = 120
  TextHeight = 16
  object Label1: TLabel
    Left = 8
    Top = 56
    Width = 47
    Height = 16
    Caption = 'Part-list:'
  end
  object Label2: TLabel
    Left = 8
    Top = 192
    Width = 61
    Height = 16
    Caption = 'RAW part:'
  end
  object Edit1: TEdit
    Left = 8
    Top = 8
    Width = 553
    Height = 24
    TabOrder = 0
    Text = 'filename'
  end
  object Button1: TButton
    Left = 576
    Top = 8
    Width = 75
    Height = 25
    Caption = 'Load'
    TabOrder = 1
    OnClick = Button1Click
  end
  object Memo1: TMemo
    Left = 8
    Top = 208
    Width = 641
    Height = 193
    ScrollBars = ssBoth
    TabOrder = 2
  end
  object Button2: TButton
    Left = 8
    Top = 416
    Width = 641
    Height = 25
    Caption = 
      'save selected decoded part to file (default filename is '#39'mimedem' +
      'o.txt'#39')'
    TabOrder = 3
    OnClick = Button2Click
  end
  object TreeView1: TTreeView
    Left = 8
    Top = 72
    Width = 641
    Height = 113
    ReadOnly = True
    Indent = 19
    OnChange = TreeView1Change
    TabOrder = 4
  end
end
----Simple Browser started----


http://sourceforge.net/projects/maxbox/files/maxbox3clx.tar.gz/download
SHA1 
15fa2216f84f11433123c2d87cb264fa2e82c466


review

Professor Dr. Nikolaus Wirth - Niklaus


process using. By the way the script you get all this is:
http://www.softwareschule.ch/examples/440_DL
L_Tutor2.txt

function
stdcall external
( : ): ;
;
xFoobox param Integer Integer
Foobox
'mytools.dll' name
' ';

This first script (project)  440_DLL_Tutor2 - script


When you call a DLL written in C or C++,
you have to use the stdcall or cdecl convention.
External 'GetVersionExA@kernel32.dll cdecl';  cdecl


  		jmp	System._AbstractError


        WM_DEVICECHANGE = &H219
Public Enum WM_DEVICECHANGE As Integer
    [TRUE] = 1
    BROADCAST_QUERY_DENY = &H424D5144
End Enum
Public Enum WM_DEVICECHANGE As Integer
    DBT_CONFIGCHANGECANCELED = &H19
    DBT_CONFIGCHANGED = &H18
    DBT_CUSTOMEVENT = &H8006
    DBT_DEVICEARRIVAL = &H8000
    DBT_DEVICEQUERYREMOVE = &H8001
    DBT_DEVICEQUERYREMOVEFAILED = &H8002
    DBT_DEVICEREMOVECOMPLETE = &H8004
    DBT_DEVICEREMOVEPENDING = &H8003
    DBT_DEVICETYPESPECIFIC = &H8005
    DBT_DEVNODES_CHANGED = &H7
    DBT_QUERYCHANGECONFIG = &H17
    DBT_USERDEFINED = &HFFFF
End Enum